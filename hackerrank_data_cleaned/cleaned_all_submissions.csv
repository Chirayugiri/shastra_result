submission_id,username,problem_name,language,code,page,url
1390069692,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommissioning {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume the newline
        for (int i = 0; i < t; i++) {
            String serverRack = scanner.nextLine();
            int minCost = findMinimumCost(serverRack);
            System.out.println(minCost);
        }
        scanner.close();
    }
    public static int findMinimumCost(String serverRack) {
        int n = serverRack.length();
        int minCost = Integer.MAX_VALUE;
        // Try all possible combinations of removing servers from the beginning and end
        for (int front = 0; front <= n; front++) {
            for (int back = 0; back <= n - front; back++) {
                // Calculate the servers that will remain after decommissioning
                String remainingServers = serverRack.substring(front, n - back);
                // Calculate the cost factors
                int remainingIdleServers = countChar(remainingServers, '0');
                int decommissionedActiveServers = countChar(serverRack.substring(0, front), '1') + 
                                                countChar(serverRack.substring(n - back, n), '1');
                // The cost is the maximum of the two factors
                int cost = Math.max(remainingIdleServers, decommissionedActiveServers);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
    private static int countChar(String str, char target) {
        int count = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == target) {
                count++;
            }
        }
        return count;
    }
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390069692
1390069704,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommissioning {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume the newline
        for (int i = 0; i < t; i++) {
            String serverRack = scanner.nextLine();
            int minCost = findMinimumCost(serverRack);
            System.out.println(minCost);
        }
        scanner.close();
    }
    public static int findMinimumCost(String serverRack) {
        int n = serverRack.length();
        // Precompute prefix sums for faster counting
        int[] activePrefix = new int[n + 1]; // Count of 1's from beginning
        int[] idlePrefix = new int[n + 1];   // Count of 0's from beginning
        for (int i = 0; i < n; i++) {
            activePrefix[i + 1] = activePrefix[i] + (serverRack.charAt(i) == '1' ? 1 : 0);
            idlePrefix[i + 1] = idlePrefix[i] + (serverRack.charAt(i) == '0' ? 1 : 0);
        }
        int totalActive = activePrefix[n]; // Total active servers
        int totalIdle = idlePrefix[n];     // Total idle servers
        int minCost = Integer.MAX_VALUE;
        // Try all possible combinations of removing servers from the beginning and end
        for (int front = 0; front <= n; front++) {
            for (int back = 0; back <= n - front; back++) {
                // Calculate active servers decommissioned from front and back
                int decommissionedActive = activePrefix[front] + (totalActive - activePrefix[n - back]);
                // Calculate idle servers remaining
                int remainingIdle = idlePrefix[n - back] - idlePrefix[front];
                // The cost is the maximum of the two factors
                int cost = Math.max(remainingIdle, decommissionedActive);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390069704
1390069729,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;
int findMinimumCost(const string& serverRack) {
    int n = serverRack.length();
    // Precompute prefix sums for faster counting
    vector<int> activePrefix(n + 1, 0); // Count of 1's from beginning
    vector<int> idlePrefix(n + 1, 0);   // Count of 0's from beginning
    for (int i = 0; i < n; i++) {
        activePrefix[i + 1] = activePrefix[i] + (serverRack[i] == '1' ? 1 : 0);
        idlePrefix[i + 1] = idlePrefix[i] + (serverRack[i] == '0' ? 1 : 0);
    }
    int totalActive = activePrefix[n]; // Total active servers
    int totalIdle = idlePrefix[n];     // Total idle servers
    int minCost = INT_MAX;
    // Try all possible combinations of removing servers from the beginning and end
    for (int front = 0; front <= n; front++) {
        for (int back = 0; back <= n - front; back++) {
            // Calculate active servers decommissioned from front and back
            int decommissionedActive = activePrefix[front] + (totalActive - activePrefix[n - back]);
            // Calculate idle servers remaining
            int remainingIdle = idlePrefix[n - back] - idlePrefix[front];
            // The cost is the maximum of the two factors
            int cost = max(remainingIdle, decommissionedActive);
            minCost = min(minCost, cost);
        }
    }
    return minCost;
}
int main() {
    int t;
    cin >> t;
    cin.ignore(); // Consume the newline
    for (int i = 0; i < t; i++) {
        string serverRack;
        getline(cin, serverRack);
        int minCost = findMinimumCost(serverRack);
        cout << minCost << endl;
    }
    return 0;
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390069729
1390062518,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> input(n);
        for (int i = 0; i < n; i++) {
            cin >> input[i];
        }
        priority_queue<int,vector<int>> pq(input.begin(), input.end());
        unordered_map<int, int> mapy;
        int dummy = min(k, n);  // Ensure we don't pop more than available
        while (dummy--) {
            mapy[pq.top()]++;
            pq.pop();
        }
        int cnt = 0;
        long long sum = 0;
        for (int i = 0; i < n; i++) {
            if (mapy[input[i]] > 0) {
                mapy[input[i]]--;
                cnt++;
                continue;
            }
            sum += input[i]+cnt;  // Fixed logic (removed `+ cnt`)
        }
        cout << sum << endl;
    }
    return 0;
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390062518
1390063339,unknown,unknown,unknown,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <cmath>
#define int long long int
#define pb push_back
/*---------------------------------------------------------------------------------------------------------------------------------*/
/*ASCII small case-> a-97 to z-122
upper case-> A-65 to Z-90*/
#define nl ""\n""
#define mp map<int, int>
#define all(v) v.begin(), v.end()
#define F first
#define S second
#define ump unordered_map<long long, int, custom_hash>
#define mstpi multiset<pair<int, int> >
#define mst multiset<int>
#define vec vector<int>
#define pi pair<int, int>
#define ld long double
#define vep vector<pair<int, int>>
#define ul unsigned long long
#define loop1 for (int i = 0; i < n; i++)
#define REP(i, a, b) for (int i = a; i <= b; i++)
#define NO cout << ""NO"" << endl
#define YES cout << ""YES"" << endl
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
/*---------------------------------------------------------------------------------------------------------------------------------*/
const double PI = 3.1415926535;
const int inf = 1e18;
const int mod = 1000000007;
/*---------------------------------------------------------------------------------------------------------------------------------*/
int modmul(int a, int b, int m)
{
    a %= m;
    b %= m;
    return (a * b) % m;
}
int modexp(int n, int x)
{
    int ans = 1;
    while (n > 0)
    {
        if (n & 1)
        {
            ans = (ans * x) % mod;
        }
        n >>= 1;
        x = (x * x) % mod;
    }
    return ans;
}
/*---------------------------------------------------------------------------------------------------------------------------------*/
string add(string a, string b)
{
    string ans = """";
    int carry = 0;
    while (!a.empty() || !b.empty() || carry > 0)
    {
        int digitA = a.empty() ? 0 : a.back() - '0';
        int digitB = b.empty() ? 0 : b.back() - '0';
        int sum = digitA + digitB + carry;
        ans = to_string(sum % 10) + ans;
        carry = sum / 10;
        if (!a.empty())
            a.pop_back();
        if (!b.empty())
            b.pop_back();
    }
    return ans;
}
string ministrnum(string a, string b)
{
    if (a.length() > b.length())
        return b;
    else if (b.length() > a.length())
        return a;
    else
    {
        int n = a.length();
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i])
                return b;
            else if (a[i] < b[i])
                return a;
        }
    }
    return a;
}
vector<int> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    if(n >= 0) isPrime[0] = false;
    if(n >= 1) isPrime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}
class SegmentTree {
public:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(arr, 0, n - 1, 0);
    }
    void build(const std::vector<int>& arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, start, mid, 2 * index + 1);
        build(arr, mid + 1, end, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
    int queryRange(int start, int end, int l, int r, int index = 0) {
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if (start > r || end < l)
            return 0;
        if (start >= l && end <= r)
            return tree[index];
        int mid = (start + end) / 2;
        return queryRange(start, mid, l, r, 2 * index + 1) +
               queryRange(mid + 1, end, l, r, 2 * index + 2);
    }
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
        if(lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if(start > r || end < l)
            return;
        if(start >= l && end <= r) {
            tree[index] += (end - start + 1) * diff;
            if(start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }
            return;
        }
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, diff, 2 * index + 1);
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
};
class DSU {
public:
    std::vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY)
            return false;
        if (rank[rootX] < rank[rootY])
            parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY])
            parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int val;
    int weight, size;
    Node *left, *right;
    bool rev = false;
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
};
ostream &operator<<(ostream &os, Node *n) {
    if(!n) return os;
    os << n -> left;
    os << n -> val;
    os << n -> right;
    return os;
}
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
void push(Node* Treap) {
    if(!Treap) return;
    if(Treap -> rev) {
        Treap -> rev = false;
        swap(Treap->left, Treap->right);
        if(Treap -> left) Treap->left->rev ^= true;
        if(Treap -> right) Treap->right->rev ^= true;
    }
}
void pull(Node *Treap) {
    if(!Treap) return;
    push(Treap -> left), push(Treap -> right);
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
    return;
}
void split(Node *Treap, Node *&left, Node *&right, int val) {
    if(!Treap) {
        left = right = NULL;
        return;
    }
    push(Treap);
    if(size(Treap -> left) < val) {
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
        left = Treap;
    }
    else {
        split(Treap -> left, left, Treap -> left, val);
        right = Treap;
    }
    pull(Treap);
}
void merge(Node *&Treap, Node *left, Node *right) {
    push(left), push(right);
    if(left == NULL) {
        Treap = right;
        return;
    }
    if(right == NULL) {
        Treap = left;
        return;
    }
    if(left -> weight < right -> weight) {
        merge(right -> left, left, right -> left);
        Treap = right;
    }
    else {
        merge(left->right, left->right, right);
        Treap = left;
    }
    pull(Treap);
}
void inOrder(Node *curr, vector<int> &res) {
    if(curr == NULL) return;
    push(curr);
    inOrder(curr->left, res);
    res.pb(curr->val);
    inOrder(curr->right, res);
    pull(curr);
}
struct Treap {
    Node *root = nullptr;
    void insert(int i, int val) {
        Node *l, *r;
        split(root, l, r, i);
        Node *v = new Node(val);
        merge(l, l, v);
        merge(root, l, r);
    }
    void del(int i) {
        Node *l, *r;
        split(root, l, r, i);
        split(r, root, r, 1);
        merge(root, l, r);
    }
    void update(int l, int r, function<void(Node *)> f) {
        Node *a, *b, *c;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        if(b) {f(b);}
        merge(root, a, b);
        merge(root, root, c);
    }
    vector<int> allPr() {
        vector<int> res;
        inOrder(root, res);
        return res;
    }
    void cycShft(int l, int r) {
        Node *a, *b, *c, *d;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        split(b, b, d, r-l);
        merge(root, a, d);
        merge(root, root, b);
        merge(root, root, c);
    }
};
vector<int> computePrefix(const string &pattern) {
    int n = pattern.size();
    vector<int> prefix(n, 0);
    for (int i = 1, j = 0; i < n; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = prefix[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        prefix[i] = j;
    }
    return prefix;
}
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> prefix = computePrefix(pattern);
    vector<int> occurrences;
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = prefix[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == (int)pattern.size()) {
            occurrences.push_back(i - j + 1);
            j = prefix[j - 1];
        }
    }
    return occurrences;
}
void solve()
{
    int n, k;
    cin>>n>>k;
    vector<int> v(n);
    loop1 cin>>v[i];
    vector<int> suff = v;
    suff.pb(0);
    for(int i = n - 2; i>-1; i--) suff[i] += suff[i+1];
    int ans = INT_MAX;
    for(int i = 0; i<=n - k; i++) {
        int cur = suff[0] - suff[i] + (suff[i+k] + (n - i - k));
        ans = min(ans, cur);
    }
    cout<<ans<<'\n';
}
int32_t main()
{
    ios_base ::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390063339
1390063420,unknown,unknown,unknown,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <cmath>
#define int long long int
#define pb push_back
/*---------------------------------------------------------------------------------------------------------------------------------*/
/*ASCII small case-> a-97 to z-122
upper case-> A-65 to Z-90*/
#define nl ""\n""
#define mp map<int, int>
#define all(v) v.begin(), v.end()
#define F first
#define S second
#define ump unordered_map<long long, int, custom_hash>
#define mstpi multiset<pair<int, int> >
#define mst multiset<int>
#define vec vector<int>
#define pi pair<int, int>
#define ld long double
#define vep vector<pair<int, int>>
#define ul unsigned long long
#define loop1 for (int i = 0; i < n; i++)
#define REP(i, a, b) for (int i = a; i <= b; i++)
#define NO cout << ""NO"" << endl
#define YES cout << ""YES"" << endl
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
/*---------------------------------------------------------------------------------------------------------------------------------*/
const double PI = 3.1415926535;
const int inf = 1e18;
const int mod = 1000000007;
/*---------------------------------------------------------------------------------------------------------------------------------*/
int modmul(int a, int b, int m)
{
    a %= m;
    b %= m;
    return (a * b) % m;
}
int modexp(int n, int x)
{
    int ans = 1;
    while (n > 0)
    {
        if (n & 1)
        {
            ans = (ans * x) % mod;
        }
        n >>= 1;
        x = (x * x) % mod;
    }
    return ans;
}
/*---------------------------------------------------------------------------------------------------------------------------------*/
string add(string a, string b)
{
    string ans = """";
    int carry = 0;
    while (!a.empty() || !b.empty() || carry > 0)
    {
        int digitA = a.empty() ? 0 : a.back() - '0';
        int digitB = b.empty() ? 0 : b.back() - '0';
        int sum = digitA + digitB + carry;
        ans = to_string(sum % 10) + ans;
        carry = sum / 10;
        if (!a.empty())
            a.pop_back();
        if (!b.empty())
            b.pop_back();
    }
    return ans;
}
string ministrnum(string a, string b)
{
    if (a.length() > b.length())
        return b;
    else if (b.length() > a.length())
        return a;
    else
    {
        int n = a.length();
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i])
                return b;
            else if (a[i] < b[i])
                return a;
        }
    }
    return a;
}
vector<int> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    if(n >= 0) isPrime[0] = false;
    if(n >= 1) isPrime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}
class SegmentTree {
public:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(arr, 0, n - 1, 0);
    }
    void build(const std::vector<int>& arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, start, mid, 2 * index + 1);
        build(arr, mid + 1, end, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
    int queryRange(int start, int end, int l, int r, int index = 0) {
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if (start > r || end < l)
            return 0;
        if (start >= l && end <= r)
            return tree[index];
        int mid = (start + end) / 2;
        return queryRange(start, mid, l, r, 2 * index + 1) +
               queryRange(mid + 1, end, l, r, 2 * index + 2);
    }
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
        if(lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if(start > r || end < l)
            return;
        if(start >= l && end <= r) {
            tree[index] += (end - start + 1) * diff;
            if(start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }
            return;
        }
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, diff, 2 * index + 1);
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
};
class DSU {
public:
    std::vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY)
            return false;
        if (rank[rootX] < rank[rootY])
            parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY])
            parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int val;
    int weight, size;
    Node *left, *right;
    bool rev = false;
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
};
ostream &operator<<(ostream &os, Node *n) {
    if(!n) return os;
    os << n -> left;
    os << n -> val;
    os << n -> right;
    return os;
}
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
void push(Node* Treap) {
    if(!Treap) return;
    if(Treap -> rev) {
        Treap -> rev = false;
        swap(Treap->left, Treap->right);
        if(Treap -> left) Treap->left->rev ^= true;
        if(Treap -> right) Treap->right->rev ^= true;
    }
}
void pull(Node *Treap) {
    if(!Treap) return;
    push(Treap -> left), push(Treap -> right);
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
    return;
}
void split(Node *Treap, Node *&left, Node *&right, int val) {
    if(!Treap) {
        left = right = NULL;
        return;
    }
    push(Treap);
    if(size(Treap -> left) < val) {
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
        left = Treap;
    }
    else {
        split(Treap -> left, left, Treap -> left, val);
        right = Treap;
    }
    pull(Treap);
}
void merge(Node *&Treap, Node *left, Node *right) {
    push(left), push(right);
    if(left == NULL) {
        Treap = right;
        return;
    }
    if(right == NULL) {
        Treap = left;
        return;
    }
    if(left -> weight < right -> weight) {
        merge(right -> left, left, right -> left);
        Treap = right;
    }
    else {
        merge(left->right, left->right, right);
        Treap = left;
    }
    pull(Treap);
}
void inOrder(Node *curr, vector<int> &res) {
    if(curr == NULL) return;
    push(curr);
    inOrder(curr->left, res);
    res.pb(curr->val);
    inOrder(curr->right, res);
    pull(curr);
}
struct Treap {
    Node *root = nullptr;
    void insert(int i, int val) {
        Node *l, *r;
        split(root, l, r, i);
        Node *v = new Node(val);
        merge(l, l, v);
        merge(root, l, r);
    }
    void del(int i) {
        Node *l, *r;
        split(root, l, r, i);
        split(r, root, r, 1);
        merge(root, l, r);
    }
    void update(int l, int r, function<void(Node *)> f) {
        Node *a, *b, *c;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        if(b) {f(b);}
        merge(root, a, b);
        merge(root, root, c);
    }
    vector<int> allPr() {
        vector<int> res;
        inOrder(root, res);
        return res;
    }
    void cycShft(int l, int r) {
        Node *a, *b, *c, *d;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        split(b, b, d, r-l);
        merge(root, a, d);
        merge(root, root, b);
        merge(root, root, c);
    }
};
vector<int> computePrefix(const string &pattern) {
    int n = pattern.size();
    vector<int> prefix(n, 0);
    for (int i = 1, j = 0; i < n; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = prefix[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        prefix[i] = j;
    }
    return prefix;
}
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> prefix = computePrefix(pattern);
    vector<int> occurrences;
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = prefix[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == (int)pattern.size()) {
            occurrences.push_back(i - j + 1);
            j = prefix[j - 1];
        }
    }
    return occurrences;
}
void solve()
{
    int n, k;
    cin>>n>>k;
    vector<int> v(n);
    loop1 cin>>v[i];
    vector<int> suff = v;
    suff.pb(0);
    for(int i = n - 2; i>-1; i--) suff[i] += suff[i+1];
    int ans = accumulate(all(v), 0LL);
    for(int i = 0; i<=n - k; i++) {
        int cur = suff[0] - suff[i] + (suff[i+k] + (n - i - k));
        ans = min(ans, cur);
    }
    cout<<ans<<'\n';
}
int32_t main()
{
    ios_base ::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390063420
1390059531,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove out-of-window elements
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new faulty readings
        if arr[i] < 0:
            dq.append(i)
        # Collect results for valid windows
        if i >= k - 1:
            result.append(0 if not dq else arr[dq[0]])
    return result
# Driver code
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    faults = earliest_faults(arr, k)
    print(*faults)",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390059531
1390062213,unknown,unknown,unknown,"#include<bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin>>t;
    while(t--)
    {
        int n,k;
        cin>>n>>k;
        vector<int>input(n);
        for(int i=0;i<n;i++)
        {
            cin>>input[i];
        }
        priority_queue<int,vector<int>> pq(input.begin(),input.end());
        unordered_map<int,int> mapy;
        int dummy=k;
        while(dummy--)
        {
            mapy[pq.top()]++;
            pq.pop();
        }
        int cnt=0;
        long long sum=0;
        for(int i=0;i<n;i++)
        {
            if(mapy[input[i]] > 0)
            {
                mapy[input[i]]--;
                cnt++;
                continue;
            }
            sum+=input[i]+cnt;
        }
        cout<<sum<<endl;
    }
    return 0;
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390062213
1390059556,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def main():
    T = int(input())
    for _ in range(T):
        s = input().strip()
        n = len(s)
        total_ones = s.count('1')
        # Calculate max consecutive ones
        max_consecutive_ones = 0
        current = 0
        for c in s:
            if c == '1':
                current += 1
                max_consecutive_ones = max(max_consecutive_ones, current)
            else:
                current = 0
        if total_ones == 0 or total_ones == max_consecutive_ones:
            print(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
            if max_ones >= required_ones:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        print(answer)
if __name__ == ""__main__"":
    main()",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390059556
1390059512,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    int min = Integer.MAX_VALUE;
    Map<String, Integer> memo = new HashMap<>();
    public int rec(int cz, int cone, int i, int j, String s, int totalOne) {
        if (i > j) {
            return Integer.MAX_VALUE;
        }
        String key = i + "","" + j + "","" + cz + "","" + cone;
        if (memo.containsKey(key)) return memo.get(key);
        int currMin = Math.max(cz, cone);
        min = Math.min(min, currMin);
        if (cone == totalOne) {
            min = Math.min(min, totalOne);
            return min;
        }
        if (cz == 0) {
            return min;
        }
        // Try removing from the left
        if (s.charAt(i) == '1') {
            currMin = Math.min(currMin, rec(cz, cone + 1, i + 1, j, s, totalOne));
        } else {
            currMin = Math.min(currMin, rec(cz - 1, cone, i + 1, j, s, totalOne));
        }
        // Try removing from the right
        if (s.charAt(j) == '1') {
            currMin = Math.min(currMin, rec(cz, cone + 1, i, j - 1, s, totalOne));
        } else {
            currMin = Math.min(currMin, rec(cz - 1, cone, i, j - 1, s, totalOne));
        }
        memo.put(key, currMin);
        return currMin;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            String s = sc.next();
            int cz = 0, cone = 0;
            for (char ch : s.toCharArray()) {
                if (ch == '0') cz++;
                else cone++;
            }
            Solution sol = new Solution();
            sol.rec(cz, 0, 0, s.length() - 1, s, cone);
            System.out.println(sol.min);
        }
        sc.close();
    }
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390059512
1390059287,unknown,unknown,unknown,"def early(arr, k):
    result = []
    for i in range(len(arr)-k + 1):
        b = arr[i:i+k]
        faulty = [x for x in b if x < 0]
        result.append(faulty[0] if faulty else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*early(arr, k))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390059287
1390059439,unknown,unknown,unknown,"def early(arr, k):
    result = []
    for i in range(len(arr)-k + 1):
        b = arr[i:i+k]
        faulty = [x for x in b if x < 0]
        result.append(faulty[0] if faulty else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*early(arr, k))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390059439
1390059469,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
void solve() {
    int n, k;
    cin >> n >> k;
    vector<ll> arr(n);
    ll total = 0;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
        total += arr[i];
    }
    vector<ll> benefits(n);
    for (int j = 0; j < n; j++){
        benefits[j] = arr[j] - (n - 1 - j);
    }
    sort(benefits.begin(), benefits.end(), greater<ll>());
    ll best = total;
    ll sumb = 0;
    int m = min(k, n);
    for (int i = 0; i < m; i++){
        if (benefits[i] < 0) {
        }
        sumb += benefits[i];
        int skips = i + 1;
        ll candidate = total - sumb - (skips * (skips - 1LL)) / 2LL;
        best = min(best, candidate);
    }
    cout << best << ""\n"";
}
int main() {
    int t; cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390059469
1390058210,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    int min = Integer.MAX_VALUE;
    public void rec(int cz, int cone, int n, String s, int i, int j,int ct) {
        if (i > j) {
            return;
        }
        int max = Math.max(cz, cone);
        min = Math.min(min, max);
        if (cz == 0 ) {
            return;
        }
        if(cone==ct){
             min = Math.min(min, ct);
            return;
        }
        if (s.charAt(i) == '1') {
            rec(cz, cone + 1, n, s, i + 1, j,ct);
        } else if (s.charAt(i) == '0') {
            rec(cz - 1, cone, n, s, i + 1, j,ct);
        }
        if (s.charAt(j) == '1') {
            rec(cz, cone + 1, n, s, i, j - 1,ct);
        } else if (s.charAt(j) == '0') {
            rec(cz - 1, cone, n, s, i, j - 1,ct);
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            String s = sc.next(); // Read input string
            int cz = 0, cone = 0;
            for (char ch : s.toCharArray()) {
                if (ch == '0') cz++;
                else if (ch == '1') cone++;
            }
            Solution sol = new Solution();
            sol.rec(cz, 0, s.length(), s, 0, s.length() - 1,cone);
            System.out.println(sol.min);
        }
        sc.close();
    }
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058210
1390058501,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    int min = Integer.MAX_VALUE;
    Map<String, Integer> memo = new HashMap<>();
    public void rec(int cz, int cone, int n, String s, int i, int j, int ct) {
        if (i > j ) {
            return;
        }
        String key = i + "","" + j ;
        if (memo.containsKey(key)) return;  // Avoid recomputation
        min = Math.min(min, Math.max(cz, cone));
        memo.put(key, min);
        if (cone == ct) {
            min = Math.min(min, ct);
            return;
        }
        if(cz==0){
            return;
        }
        if (s.charAt(i) == '1') {
            rec(cz, cone + 1, n, s, i + 1, j, ct);
        } else {
            rec(cz - 1, cone, n, s, i + 1, j, ct);
        }
        if (s.charAt(j) == '1') {
            rec(cz, cone + 1, n, s, i, j - 1, ct);
        } else {
            rec(cz - 1, cone, n, s, i, j - 1, ct);
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            String s = sc.next();
            int cz = 0, cone = 0;
            for (char ch : s.toCharArray()) {
                if (ch == '0') cz++;
                else cone++;
            }
            Solution sol = new Solution();
            sol.rec(cz, 0, s.length(), s, 0, s.length() - 1, cone);
            System.out.println(sol.min);
        }
        sc.close();
    }
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058501
1390058774,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    int min = Integer.MAX_VALUE;
    Map<String, Integer> memo = new HashMap<>();
    public void rec(int cz, int cone, int n, String s, int i, int j, int ct) {
        if (i > j ) {
            return;
        }
        String key = i + "","" + j ;
        if (memo.containsKey(key)) return;  
        min = Math.min(min, Math.max(cz, cone));
        memo.put(key, min);
        if (cone == ct) {
            min = Math.min(min, ct);
            memo.put(key, min);
            return;
        }
        if(cz==0){
            return;
        }
        if (s.charAt(i) == '1') {
            rec(cz, cone + 1, n, s, i + 1, j, ct);
        } else {
            rec(cz - 1, cone, n, s, i + 1, j, ct);
        }
        if (s.charAt(j) == '1') {
            rec(cz, cone + 1, n, s, i, j - 1, ct);
        } else {
            rec(cz - 1, cone, n, s, i, j - 1, ct);
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            String s = sc.next();
            int cz = 0, cone = 0;
            for (char ch : s.toCharArray()) {
                if (ch == '0') cz++;
                else cone++;
            }
            Solution sol = new Solution();
            sol.rec(cz, 0, s.length(), s, 0, s.length() - 1, cone);
            System.out.println(sol.min);
        }
        sc.close();
    }
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058774
1390057997,unknown,unknown,unknown,"def min_effort(n, k, arr):
    total = sum(arr)
    if k == n:
        return 0
    return total - min(arr)
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(min_effort(n, k, arr))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057997
1390058040,unknown,unknown,unknown,"def min_decommissioning_cost(binary_string):
    first_one = binary_string.find('1')
    last_one = binary_string.rfind('1')
    if first_one == -1:
        return 0
    substring = binary_string[first_one:last_one + 1]
    return max(substring.count('0'), binary_string.count('1') - substring.count('1'))
t = int(input())
for _ in range(t):
    binary_string = input().strip()
    print(min_decommissioning_cost(binary_string))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058040
1390057889,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Check the first batch
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of this window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Append the first negative number in the current window or 0
        result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    # Compute and print results
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390057889
1390057705,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057705
1390057567,unknown,unknown,unknown,,3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057567
1390057643,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057643
1390057102,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057102
1390057146,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057146
1390057187,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057187
1390056984,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine();
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056984
1390056985,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056985
1390057031,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057031
1390056979,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
class Solution {
  private:
    int check (vector<int> checkVector) {
      for (auto it : checkVector) {
        if (it < 0) {
          return it;
        }
      }
      return 0;
    }
  public:
    vector<int> faultyReadings (vector<int> arr, int k) {
      vector<int> ans;
      // -8 2 3 -6 10
      for (size_t i = 0; i <= arr.size() - k; ++i) {  
        vector<int> checkVector(arr.begin() + i, arr.begin() + i + k);
        ans.push_back(check(checkVector));
      }
      return ans;
    }
};
int main() {
  int t;
  // cout << ""Enter Number of Test Cases: "";
  cin >> t;
  Solution obj;
  while (t--) {
    // cout << ""Enter the Size of Array: "";
    int n;
    cin >> n;
    // cout << ""Enter Batch Size: "";
    int k;
    cin >> k;
    cin.ignore();  
    // cout << ""Enter all the Test Cases Values: "";
    vector<int> arr;
    string input;
    getline(cin, input);
    stringstream ss(input);
    int number;
    while (ss >> number) {
      arr.push_back(number);
    }
    vector<int> ans = obj.faultyReadings(arr, k);
    for (auto nums : ans) {
      cout << nums << ' ';
    } 
    cout << '\n';
  }
  return 0;
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056979
1390056889,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        result.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements no longer in window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add new element if it's faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056889
1390056939,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        result.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements no longer in window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add new element if it's faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute and print output
for res in earliest_faulty_readings(test_cases):
    print(res)",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056939
1390056935,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056935
1390056661,unknown,unknown,unknown,"import java.util.*;
import java.io.*;
public class FirewallSkips {
    public static void main(String[] args) {
        FastReader in = new FastReader(System.in);
        int T = in.nextInt();
        while (T-- > 0) {
            int n = in.nextInt();
            int k = in.nextInt();
            long[] a = new long[n];
            long sumA = 0; // sum of all a[i]
            for (int i = 0; i < n; i++) {
                a[i] = in.nextLong();
                sumA += a[i];
            }
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
            // We'll sort b in descending order to pick the top x.
            long[] b = new long[n];
            for (int i = 0; i < n; i++) {
                b[i] = a[i] + (i + 1);
            }
            Arrays.sort(b);
            // Sort ascending by default; we want descending, so either:
            // 1) reverse in place, or
            // 2) build prefix sums from the end.
            // Let's just reverse in place for clarity.
            reverse(b); // Now b is descending.
            // Build prefix sums of b in descending order:
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
            long[] prefix = new long[n+1];
            prefix[0] = 0;
            for (int x = 1; x <= n; x++) {
                prefix[x] = prefix[x-1] + b[x-1];
            }
            long ans = Long.MAX_VALUE;
            // Try x from 0..k (number of skips)
            for (int x = 0; x <= k; x++) {
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
                // Make sure to use long to avoid overflow
                long cost = sumA 
                            + x * (long)n 
                            - prefix[x]
                            - ((long)x * (x - 1) / 2);
                ans = Math.min(ans, cost);
            }
            System.out.println(ans);
        }
    }
    // Utility to reverse array in place
    private static void reverse(long[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            long tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;
            left++;
            right--;
        }
    }
    // Fast input class (optional, for large I/O)
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        public FastReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream));
        }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
        long nextLong() {
            return Long.parseLong(next());
        }
    }
}",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056661
1390056851,unknown,unknown,unknown,"def earliest_faulty_in_batches(arr, n, k):
    result = []
    # Traverse the array in batches of size k
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        found_fault = False
        # Find the first negative number in the batch
        for num in batch:
            if num < 0:
                result.append(num)
                found_fault = True
                break
        # If no negative number is found, append 0
        if not found_fault:
            result.append(0)
    return result
# Reading input
t = int(input().strip())
outputs = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    outputs.append(earliest_faulty_in_batches(arr, n, k))
# Print results
for output in outputs:
    print("" "".join(map(str, output)))",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056851
1390056460,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056460
1390056535,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split()) ",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056535
1390056633,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    # Try all possible combinations of skipping up to k firewalls
    # and find the minimum effort
    # Initialize with maximum possible effort
    min_effort = float('inf')
    # Helper function to calculate effort when skipping specific firewalls
    def calculate_effort(skip_mask):
        effort = 0
        skipped = 0
        for i in range(n):
            # Check if current firewall is skipped
            if (skip_mask >> i) & 1:
                skipped += 1
            else:
                # Add effort for this firewall (including penalty from skipped firewalls)
                effort += firewalls[i] + skipped
        return effort
    # Try all possible combinations of skipping firewalls
    # For small n, we can use a brute force approach with bitmasks
    for mask in range(1 << n):
        # Count bits to ensure we skip at most k firewalls
        if bin(mask).count('1') <= k:
            effort = calculate_effort(mask)
            min_effort = min(min_effort, effort)
    return min_effort
# Test with the provided examples
test_cases = [
    {""n"": 4, ""k"": 1, ""firewalls"": [5, 10, 11, 5], ""expected"": 21},
    {""n"": 4, ""k"": 4, ""firewalls"": [8, 7, 1, 4], ""expected"": 0}
]
for i, test in enumerate(test_cases):
    result = min_effort_to_breach(test[""n""], test[""k""], test[""firewalls""])
    print(f""Test {i+1}: Result = {result}, Expected = {test['expected']}"")
# Final solution for submission
print(""\nFinal solution:"")
print(""""""
def min_effort_to_breach(n, k, firewalls):
    # Try all possible combinations of skipping up to k firewalls
    # and find the minimum effort
    # Initialize with maximum possible effort
    min_effort = float('inf')
    # Helper function to calculate effort when skipping specific firewalls
    def calculate_effort(skip_mask):
        effort = 0
        skipped = 0
        for i in range(n):
            # Check if current firewall is skipped
            if (skip_mask >> i) & 1:
                skipped += 1
            else:
                # Add effort for this firewall (including penalty from skipped firewalls)
                effort += firewalls[i] + skipped
        return effort
    # Try all possible combinations of skipping firewalls
    # For small n, we can use a brute force approach with bitmasks
    for mask in range(1 << n):
        # Count bits to ensure we skip at most k firewalls
        if bin(mask).count('1') <= k:
            effort = calculate_effort(mask)
            min_effort = min(min_effort, effort)
    return min_effort
# Read input
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))
"""""")",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056633
1390056446,unknown,unknown,unknown,"def min_cost(s):
    total_ones = s.count('1')
    n = len(s)
    scenario_empty = total_ones  # Cost when removing all '1's
    # Scenario 1: Window lengths 1 to min(total_ones, n)
    scenario1_cost = float('inf')
    if total_ones == 0:
        scenario1_cost = 0  # If all are '0's, best is to remove all
    else:
        max_ones = 0
        L = min(total_ones, n)
        current_ones = sum(1 for c in s[:L] if c == '1')  # Initial window count
        max_ones = current_ones  # First window
        for i in range(1, n - L + 1):
            current_ones -= (s[i-1] == '1')
            current_ones += (s[i + L - 1] == '1')
            max_ones = max(max_ones, current_ones)  # Keep track of max found
        scenario1_cost = total_ones - max_ones  # Cost of transforming scenario 1
    # Scenario 2: Window lengths > total_ones
    scenario2_cost = float('inf')
    if n > total_ones:
        min_zeros = float('inf')
        current_zeros = sum(1 for c in s[:total_ones + 1] if c == '0')  # Initial window count
        min_zeros = current_zeros  # First window
        for i in range(1, n - (total_ones + 1) + 1):
            current_zeros -= (s[i-1] == '0')
            current_zeros += (s[i + total_ones] == '0')
            min_zeros = min(min_zeros, current_zeros)  # Keep track of min found
        scenario2_cost = min_zeros  # Cost of transforming scenario 2
    # Choose the best (minimum cost) option
    candidates = [scenario1_cost, scenario_empty]
    if n > total_ones:
        candidates.append(scenario2_cost)
    return min(candidates)
# Read number of test cases
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056446
1390056380,unknown,unknown,unknown,"function minDecommissioningCost(rack) {
    let n = rack.length;
    let prefixZeros = new Array(n + 1).fill(0);
    let prefixOnes = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefixZeros[i + 1] = prefixZeros[i] + (rack[i] === '0' ? 1 : 0);
        prefixOnes[i + 1] = prefixOnes[i] + (rack[i] === '1' ? 1 : 0);
    }
    let totalZeros = prefixZeros[n];
    let totalOnes = prefixOnes[n];
    let minCost = Infinity;
    for (let i = 0; i <= n; i++) {
        for (let j = 0; j <= n - i; j++) {
            if (i + j === n) continue;
            let zerosRemovedStart = prefixZeros[i];
            let onesRemovedStart = prefixOnes[i];
            let zerosRemovedEnd = totalZeros - prefixZeros[n - j];
            let onesRemovedEnd = totalOnes - prefixOnes[n - j];
            let remainingZeros = totalZeros - zerosRemovedStart - zerosRemovedEnd;
            let removedOnes = onesRemovedStart + onesRemovedEnd;
            let cost = Math.max(remainingZeros, removedOnes);
            minCost = Math.min(minCost, cost);
        }
    }
    return minCost;
}
function solveTestCases(input) {
    let lines = input.trim().split(""\n"");
    let T = parseInt(lines[0], 10);
    let results = [];
    for (let i = 1; i <= T; i++) {
        let rack = lines[i].trim();
        results.push(minDecommissioningCost(rack));
    }
    console.log(results.join(""\n""));
}
process.stdin.resume();
process.stdin.setEncoding(""utf8"");
let _input = """";
process.stdin.on(""data"", function (input) {
    _input += input;
});
process.stdin.on(""end"", function () {
    solveTestCases(_input);
});",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056380
1390056434,unknown,unknown,unknown,"T = int(input())  
for _ in range(T):
    n, k = map(int, input().split())  
    a = list(map(int, input().split()))  
    if n ==k:
        print(0)
        continue
    reductions = []
    for i in range(n):
        reductions.append(a[i] - (n - i - 1))
    reductions.sort(reverse=True)
    total_reduction = sum(reductions[:k]) if k > 0 else 0
    total_effort = sum(a) - total_reduction + min(k, n) * (min(k, n) - 1) // 2
    print(total_effort)  ",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056434
1390056443,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [int(c) for c in servers]
    # Compute prefix sum of active servers (1s)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]  # Total active servers
    min_cost = total_ones  # Worst case: decommission all active servers
    # Iterate over all possible windows to calculate the cost
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Number of 0's in the window is the total number of characters minus active 1's in that window
            segment_zeros = (j - i) - (prefix_sum[j] - prefix_sum[i])
            # Active servers removed are total active servers - active servers in this window
            active_removed = total_ones - (prefix_sum[j] - prefix_sum[i])
            cost = max(segment_zeros, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    # Reading input
    t = int(input())
    for _ in range(t):
        servers = input().strip()
        # Calling the function to calculate the minimum decommission cost
        print(minimum_decommission_cost(servers))
# Call the process_input function when the script is run directly
if __name__ == ""__main__"":
    process_input()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056443
1390056300,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056300
1390056324,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    if n == k:
        print(0)
    else:
        result = 0
        for i in range(n - k + 1):
            temp_arr = arr[:i] + arr[i + 1:]
            temp_arr[i % len(temp_arr)] = 0  
            akshu = sum(temp_arr) + (n - 1 - i)
            result = max(result, akshu)
        print(result)
        ",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056324
1390056335,unknown,unknown,unknown,"def min_cost(s):
    total_ones = s.count('1')
    n = len(s)
    scenario_empty = total_ones  # Cost when removing all '1's
    # Scenario 1: Window lengths 1 to min(total_ones, n)
    scenario1_cost = float('inf')
    if total_ones == 0:
        scenario1_cost = 0  # If all are '0's, best is to remove all
    else:
        max_ones = 0
        L = min(total_ones, n)
        current_ones = sum(1 for c in s[:L] if c == '1')  # Initial window count
        max_ones = current_ones  # First window
        for i in range(1, n - L + 1):
            current_ones -= (s[i-1] == '1')
            current_ones += (s[i + L - 1] == '1')
            max_ones = max(max_ones, current_ones)  # Keep track of max found
        scenario1_cost = total_ones - max_ones  # Cost of transforming scenario 1
    # Scenario 2: Window lengths > total_ones
    scenario2_cost = float('inf')
    if n > total_ones:
        min_zeros = float('inf')
        current_zeros = sum(1 for c in s[:total_ones + 1] if c == '0')  # Initial window count
        min_zeros = current_zeros  # First window
        for i in range(1, n - (total_ones + 1) + 1):
            current_zeros -= (s[i-1] == '0')
            current_zeros += (s[i + total_ones] == '0')
            min_zeros = min(min_zeros, current_zeros)  # Keep track of min found
        scenario2_cost = min_zeros  # Cost of transforming scenario 2
    # Choose the best (minimum cost) option
    candidates = [scenario1_cost, scenario_empty]
    if n > total_ones:
        candidates.append(scenario2_cost)
    return min(candidates)
# Read number of test cases
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056335
1390056268,unknown,unknown,unknown,"def min_cost(s: str) -> int:
    n = len(s)
    min_cost = float('inf')
    # Precompute the total number of 0's in the string
    total_zeros = s.count('0')
    # Iterate over all possible ways to decommission from the beginning and end
    for left in range(n + 1):
        for right in range(n + 1 - left):
            # Calculate the number of 0's remaining in the middle part
            middle = s[left : n - right]
            remaining_zeros = middle.count('0')
            # Calculate the number of 1's decommissioned from the left and right
            decommissioned_ones = s[:left].count('1') + s[n - right:].count('1')
            # Calculate the cost
            cost = max(remaining_zeros, decommissioned_ones)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    T = int(data[0])
    for i in range(1, T + 1):
        s = data[i]
        print(min_cost(s))
if __name__ == ""__main__"":
    main()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056268
1390056279,unknown,unknown,unknown,"def min_decommissioning_cost(rack):
    n = len(rack)
    prefix_zeros = [0] * (n + 1)
    prefix_ones = [0] * (n + 1)
    # Compute prefix sums for '0's and '1's
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if rack[i] == '0' else 0)
        prefix_ones[i + 1] = prefix_ones[i] + (1 if rack[i] == '1' else 0)
    total_zeros = prefix_zeros[n]
    total_ones = prefix_ones[n]
    min_cost = float('inf')
    # Try different partition points
    for i in range(n + 1):
        for j in range(n + 1 - i):
            if i + j == n:
                continue
            zeros_removed_start = prefix_zeros[i]
            ones_removed_start = prefix_ones[i]
            zeros_removed_end = total_zeros - prefix_zeros[n - j]
            ones_removed_end = total_ones - prefix_ones[n - j]
            remaining_zeros = total_zeros - zeros_removed_start - zeros_removed_end
            removed_ones = ones_removed_start + ones_removed_end
            cost = max(remaining_zeros, removed_ones)
            min_cost = min(min_cost, cost)
    return min_cost
def solve_test_cases():
    t = int(input().strip())
    results = []
    for _ in range(t):
        rack = input().strip()
        result = min_decommissioning_cost(rack)
        results.append(str(result))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    solve_test_cases()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056279
1390056289,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    total_effort = sum(strengths)  # Case where no firewalls are skipped
    # Calculate the effort for each possible skipping position
    min_effort = total_effort
    for i in range(n):
        if k > 0:
            skipped_effort = strengths[i]
            extra_penalty = (n - (i + 1)) * 1  # Each subsequent firewall gets +1 penalty per skip
            current_effort = total_effort - skipped_effort + extra_penalty
            min_effort = min(min_effort, current_effort)
    return min_effort if k < n else 0  # If k == n, we can skip all firewalls
def main():
    T = int(input())  # Number of test cases
    for _ in range(T):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        print(min_effort(n, k, strengths))
if __name__ == ""__main__"":
    main()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056289
1390056255,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056255
1390056245,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int testCases = scanner.nextInt();
        while (testCases-- > 0) {
            int arraySize = scanner.nextInt();
            int windowSize = scanner.nextInt();
            int[] elements = new int[arraySize];
            for (int index = 0; index < arraySize; index++) {
                elements[index] = scanner.nextInt();
            }
            if (windowSize > arraySize) {
                System.out.println(""0"");
                continue;
            }
            for (int start = 0; start <= arraySize - windowSize; start++) {
                int firstNegative = 0;
                for (int end = start; end < start + windowSize; end++) {
                    if (elements[end] < 0) {
                        firstNegative = elements[end];
                        break;
                    }
                }
                System.out.print(firstNegative + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056245
1390056254,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056254
1390056253,unknown,unknown,unknown,"def solve(servers):
    n = len(servers)
    min_cost = float('inf')
    best_i = 0
    best_j = 0
    for i in range(n + 1):
        for j in range(n + 1 - i):
            rem = servers[i:n-j]
            zeros = rem.count('0')
            ones_removed = servers[:i].count('1') + servers[n-j:].count('1')
            # cost is max of these
            cost = max(zeros, ones_removed)
            # update if better
            if cost < min_cost:
                min_cost = cost
                best_i = i
                best_j = j
    # idk if this is right but let's try
    return min_cost
def main():
    t = int(input())
    for _ in range(t):
        s = input().strip()
        print(solve(s))
if __name__ == ""__main__"":
    main()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056253
1390056181,unknown,unknown,unknown,"import java.util.*;
import java.io.*;
public class FirewallSkips {
    public static void main(String[] args) {
        FastReader in = new FastReader(System.in);
        int T = in.nextInt();
        while (T-- > 0) {
            int n = in.nextInt();
            int k = in.nextInt();
            long[] a = new long[n];
            long sumA = 0; // sum of all a[i]
            for (int i = 0; i < n; i++) {
                a[i] = in.nextLong();
                sumA += a[i];
            }
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
            // We'll sort b in descending order to pick the top x.
            long[] b = new long[n];
            for (int i = 0; i < n; i++) {
                b[i] = a[i] + (i + 1);
            }
            Arrays.sort(b);
            // Sort ascending by default; we want descending, so either:
            // 1) reverse in place, or
            // 2) build prefix sums from the end.
            // Let's just reverse in place for clarity.
            reverse(b); // Now b is descending.
            // Build prefix sums of b in descending order:
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
            long[] prefix = new long[n+1];
            prefix[0] = 0;
            for (int x = 1; x <= n; x++) {
                prefix[x] = prefix[x-1] + b[x-1];
            }
            long ans = Long.MAX_VALUE;
            // Try x from 0..k (number of skips)
            for (int x = 0; x <= k; x++) {
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
                // Make sure to use long to avoid overflow
                long cost = sumA 
                            + x * (long)n 
                            - prefix[x]
                            - ((long)x * (x - 1) / 2);
                ans = Math.min(ans, cost);
            }
            System.out.println(ans);
        }
    }
    // Utility to reverse array in place
    private static void reverse(long[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            long tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;
            left++;
            right--;
        }
    }
    // Fast input class (optional, for large I/O)
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        public FastReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream));
        }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
        long nextLong() {
            return Long.parseLong(next());
        }
    }
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056181
1390056185,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} 3rd",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056185
1390056180,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):  # Iterate through all combinations of skips
        skips = []
        for j in range(n):
            if (i >> j) & 1:
                skips.append(j)
        if len(skips) <= k:
            effort = 0
            increment = 0
            for j in range(n):
                if j in skips:
                    increment += 1
                else:
                    effort += a[j] + increment
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056180
1390056163,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            int ans = findResult(arr, k);
            System.out.print(ans);
            System.out.println();
        }
        scanner.close();
    }
    public static int findResult(int []arr, int k){
        int[] ans= new int[arr.length];
        int sum=0;
        for(int i =0;i<arr.length;i++){
            ans[i]=arr[i]-((arr.length-1)-i);
            sum+=arr[i];
        }
        Arrays.sort(ans);
        reverse(ans);
        for(int i =0;i<k;i++){
            if(ans[i]>0){
               // System.out.println(ans[i]+""w"");
                sum-=ans[i];
            }
        }
        return Math.max(sum,0);
    }
     private static void reverse(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056163
1390056162,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056162
1390056169,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056169
1390056158,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056158
1390056138,unknown,unknown,unknown,"import sys
def min_effort_to_breach(t, test_cases):
    INF = 10**18
    results = []
    for n, k, firewalls in test_cases:
        prev = [INF] * (k + 1)
        prev[0] = 0
        for i in range(n):
            curr = [INF] * (k + 1)
            for s in range(k + 1):
                curr[s] = prev[s] + firewalls[i] + s
                if s > 0:
                    curr[s] = min(curr[s], prev[s - 1])
            prev = curr
        results.append(min(prev))
    return results
t = int(sys.stdin.readline().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, sys.stdin.readline().split())
    firewalls = list(map(int, sys.stdin.readline().split()))
    test_cases.append((n, k, firewalls))
results = min_effort_to_breach(t, test_cases)
# Print output
for res in results:
    print(res)",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056138
1390056140,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        for (int tc = 0; tc < t; tc++) {
            int n = scanner.nextInt(); // Number of firewalls
            int k = scanner.nextInt(); // Maximum firewalls to skip
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextInt();
            }
            System.out.println(minEffortToBreach(n, k, strengths));
        }
        scanner.close();
    }
    public static long minEffortToBreach(int n, int k, int[] strengths) {
        // Create a 2D DP table
        // dp[i][j] = min effort to breach first i firewalls by skipping j firewalls
        long[][] dp = new long[n + 1][k + 1];
        // Initialize with maximum value
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i][j] = Long.MAX_VALUE;
            }
        }
        // Base case: no firewalls, no effort
        dp[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            int firewallIdx = i - 1; // Convert to 0-indexed for strengths array
            for (int j = 0; j <= k; j++) {
                // Option 1: Don't skip the current firewall
                if (j <= firewallIdx) { // We must have skipped at most j firewalls among previous i-1
                    // Calculate increased strength due to j previously skipped firewalls
                    long currentStrength = strengths[firewallIdx] + j;
                    if (dp[i-1][j] != Long.MAX_VALUE) {
                        dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + currentStrength);
                    }
                }
                // Option 2: Skip the current firewall (if we haven't used all skips)
                if (j > 0) {
                    if (dp[i-1][j-1] != Long.MAX_VALUE) {
                        dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);
                    }
                }
            }
        }
        // Find minimum effort across all possible skip counts
        long minEffort = Long.MAX_VALUE;
        for (int j = 0; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[n][j]);
        }
        return minEffort;
    }
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056140
1390056144,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ ==  ""__main__"":
     solve()",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056144
1390056133,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
def min_effort_to_breach(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        min_effort = float('inf')
        for skipped in range(k + 1):
            effort = 0
            penalty = 0
            for i in range(skipped, n):
                effort += firewalls[i] + penalty
                penalty += 1
            min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
if __name__ == ""__main__"":
    try:
        T = int(input())
        test_cases = []
        for _ in range(T):
            try:
                n, k = map(int, input().split())
                firewalls = list(map(int, input().split()))
                if len(firewalls) != n:
                    raise ValueError(""Invalid number of firewall strenghts"")
                test_cases.append((n, k, firewalls))
            except ValueError as e:
                print(f""Invalid input: {e}"")
                exit(1)
        output = min_effort_to_breach(test_cases)
        for res in output:
            print(res)
    except ValueError:
        print(""Invalid input:  Expected an integer for the no of test cases."")      ",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056133
1390056134,unknown,unknown,unknown,"import java.util.*;
import java.io.*;
public class FirewallSkips {
    public static void main(String[] args) {
        FastReader in = new FastReader(System.in);
        int T = in.nextInt();
        while (T-- > 0) {
            int n = in.nextInt();
            int k = in.nextInt();
            long[] a = new long[n];
            long sumA = 0; // sum of all a[i]
            for (int i = 0; i < n; i++) {
                a[i] = in.nextLong();
                sumA += a[i];
            }
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
            // We'll sort b in descending order to pick the top x.
            long[] b = new long[n];
            for (int i = 0; i < n; i++) {
                b[i] = a[i] + (i + 1);
            }
            Arrays.sort(b);
            // Sort ascending by default; we want descending, so either:
            // 1) reverse in place, or
            // 2) build prefix sums from the end.
            // Let's just reverse in place for clarity.
            reverse(b); // Now b is descending.
            // Build prefix sums of b in descending order:
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
            long[] prefix = new long[n+1];
            prefix[0] = 0;
            for (int x = 1; x <= n; x++) {
                prefix[x] = prefix[x-1] + b[x-1];
            }
            long ans = Long.MAX_VALUE;
            // Try x from 0..k (number of skips)
            for (int x = 0; x <= k; x++) {
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
                // Make sure to use long to avoid overflow
                long cost = sumA 
                            + x * (long)n 
                            - prefix[x]
                            - ((long)x * (x - 1) / 2);
                ans = Math.min(ans, cost);
            }
            System.out.println(ans);
        }
    }
    // Utility to reverse array in place
    private static void reverse(long[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            long tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;
            left++;
            right--;
        }
    }
    // Fast input class (optional, for large I/O)
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        public FastReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream));
        }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
        long nextLong() {
            return Long.parseLong(next());
        }
    }
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056134
1390056137,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056137
1390056130,unknown,unknown,unknown,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <cmath>
#define int long long int
#define pb push_back
/*---------------------------------------------------------------------------------------------------------------------------------*/
/*ASCII small case-> a-97 to z-122
upper case-> A-65 to Z-90*/
#define nl ""\n""
#define mp map<int, int>
#define all(v) v.begin(), v.end()
#define F first
#define S second
#define ump unordered_map<long long, int, custom_hash>
#define mstpi multiset<pair<int, int> >
#define mst multiset<int>
#define vec vector<int>
#define pi pair<int, int>
#define ld long double
#define vep vector<pair<int, int>>
#define ul unsigned long long
#define loop1 for (int i = 0; i < n; i++)
#define REP(i, a, b) for (int i = a; i <= b; i++)
#define NO cout << ""NO"" << endl
#define YES cout << ""YES"" << endl
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
/*---------------------------------------------------------------------------------------------------------------------------------*/
const double PI = 3.1415926535;
const int inf = 1e18;
const int mod = 1000000007;
/*---------------------------------------------------------------------------------------------------------------------------------*/
int modmul(int a, int b, int m)
{
    a %= m;
    b %= m;
    return (a * b) % m;
}
int modexp(int n, int x)
{
    int ans = 1;
    while (n > 0)
    {
        if (n & 1)
        {
            ans = (ans * x) % mod;
        }
        n >>= 1;
        x = (x * x) % mod;
    }
    return ans;
}
/*---------------------------------------------------------------------------------------------------------------------------------*/
string add(string a, string b)
{
    string ans = """";
    int carry = 0;
    while (!a.empty() || !b.empty() || carry > 0)
    {
        int digitA = a.empty() ? 0 : a.back() - '0';
        int digitB = b.empty() ? 0 : b.back() - '0';
        int sum = digitA + digitB + carry;
        ans = to_string(sum % 10) + ans;
        carry = sum / 10;
        if (!a.empty())
            a.pop_back();
        if (!b.empty())
            b.pop_back();
    }
    return ans;
}
string ministrnum(string a, string b)
{
    if (a.length() > b.length())
        return b;
    else if (b.length() > a.length())
        return a;
    else
    {
        int n = a.length();
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i])
                return b;
            else if (a[i] < b[i])
                return a;
        }
    }
    return a;
}
vector<int> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    if(n >= 0) isPrime[0] = false;
    if(n >= 1) isPrime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}
class SegmentTree {
public:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(arr, 0, n - 1, 0);
    }
    void build(const std::vector<int>& arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, start, mid, 2 * index + 1);
        build(arr, mid + 1, end, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
    int queryRange(int start, int end, int l, int r, int index = 0) {
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if (start > r || end < l)
            return 0;
        if (start >= l && end <= r)
            return tree[index];
        int mid = (start + end) / 2;
        return queryRange(start, mid, l, r, 2 * index + 1) +
               queryRange(mid + 1, end, l, r, 2 * index + 2);
    }
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
        if(lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if(start > r || end < l)
            return;
        if(start >= l && end <= r) {
            tree[index] += (end - start + 1) * diff;
            if(start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }
            return;
        }
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, diff, 2 * index + 1);
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
};
class DSU {
public:
    std::vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY)
            return false;
        if (rank[rootX] < rank[rootY])
            parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY])
            parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int val;
    int weight, size;
    Node *left, *right;
    bool rev = false;
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
};
ostream &operator<<(ostream &os, Node *n) {
    if(!n) return os;
    os << n -> left;
    os << n -> val;
    os << n -> right;
    return os;
}
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
void push(Node* Treap) {
    if(!Treap) return;
    if(Treap -> rev) {
        Treap -> rev = false;
        swap(Treap->left, Treap->right);
        if(Treap -> left) Treap->left->rev ^= true;
        if(Treap -> right) Treap->right->rev ^= true;
    }
}
void pull(Node *Treap) {
    if(!Treap) return;
    push(Treap -> left), push(Treap -> right);
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
    return;
}
void split(Node *Treap, Node *&left, Node *&right, int val) {
    if(!Treap) {
        left = right = NULL;
        return;
    }
    push(Treap);
    if(size(Treap -> left) < val) {
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
        left = Treap;
    }
    else {
        split(Treap -> left, left, Treap -> left, val);
        right = Treap;
    }
    pull(Treap);
}
void merge(Node *&Treap, Node *left, Node *right) {
    push(left), push(right);
    if(left == NULL) {
        Treap = right;
        return;
    }
    if(right == NULL) {
        Treap = left;
        return;
    }
    if(left -> weight < right -> weight) {
        merge(right -> left, left, right -> left);
        Treap = right;
    }
    else {
        merge(left->right, left->right, right);
        Treap = left;
    }
    pull(Treap);
}
void inOrder(Node *curr, vector<int> &res) {
    if(curr == NULL) return;
    push(curr);
    inOrder(curr->left, res);
    res.pb(curr->val);
    inOrder(curr->right, res);
    pull(curr);
}
struct Treap {
    Node *root = nullptr;
    void insert(int i, int val) {
        Node *l, *r;
        split(root, l, r, i);
        Node *v = new Node(val);
        merge(l, l, v);
        merge(root, l, r);
    }
    void del(int i) {
        Node *l, *r;
        split(root, l, r, i);
        split(r, root, r, 1);
        merge(root, l, r);
    }
    void update(int l, int r, function<void(Node *)> f) {
        Node *a, *b, *c;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        if(b) {f(b);}
        merge(root, a, b);
        merge(root, root, c);
    }
    vector<int> allPr() {
        vector<int> res;
        inOrder(root, res);
        return res;
    }
    void cycShft(int l, int r) {
        Node *a, *b, *c, *d;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        split(b, b, d, r-l);
        merge(root, a, d);
        merge(root, root, b);
        merge(root, root, c);
    }
};
vector<int> computePrefix(const string &pattern) {
    int n = pattern.size();
    vector<int> prefix(n, 0);
    for (int i = 1, j = 0; i < n; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = prefix[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        prefix[i] = j;
    }
    return prefix;
}
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> prefix = computePrefix(pattern);
    vector<int> occurrences;
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = prefix[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == (int)pattern.size()) {
            occurrences.push_back(i - j + 1);
            j = prefix[j - 1];
        }
    }
    return occurrences;
}
void solve()
{
    int n, k;
    cin>>n>>k;
    vector<int> v(n);
    loop1 cin>>v[i];
    queue<int> st;
    for(int i = 0; i<n; i++) {
        if(v[i] < 0) {
             st.push(i);
        }
        if(i >= k-1) {
            if(st.empty()) cout<<0<<"" "";
            else cout<<v[st.front()]<<"" "";
            if(!st.empty() && st.front() <= i - k + 1)
            st.pop();
        }
    }
    cout<<endl;
}
int32_t main()
{
    ios_base ::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056130
1390056131,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  # Skip
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)  # Don't skip
    return min(dp[n])
t = int(input())
for _ in range(t):
    print(solve())",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056131
1390056132,unknown,unknown,unknown,"def min_server_decommissioning_cost():
    T = int(input())
    for _ in range(T):
        servers = input().strip()
        n = len(servers)
        total_zeros = servers.count('0')
        total_ones = servers.count('1')
        min_cost = float('inf')
        # Try all possible prefixes to remove from front (0 to n)
        for l in range(n + 1):
            # Try all possible suffixes to remove from end (0 to n - l)
            for r in range(n - l + 1):
                remaining = servers[l:n - r]
                remaining_zeros = remaining.count('0')
                removed_ones = servers[:l].count('1') + servers[n - r:].count('1')
                cost = max(remaining_zeros, removed_ones)
                min_cost = min(min_cost, cost)
        print(min_cost)",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056132
1390056121,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056121
1390056115,unknown,unknown,unknown,"def min_cost(s):
    total_ones = s.count('1')
    n = len(s)
    scenario_empty = total_ones  # Cost when removing all '1's
    # Scenario 1: Window lengths 1 to min(total_ones, n)
    scenario1_cost = float('inf')
    if total_ones == 0:
        scenario1_cost = 0  # If all are '0's, best is to remove all
    else:
        max_ones = 0
        L = min(total_ones, n)
        current_ones = sum(1 for c in s[:L] if c == '1')  # Initial window count
        max_ones = current_ones  # First window
        for i in range(1, n - L + 1):
            current_ones -= (s[i-1] == '1')
            current_ones += (s[i + L - 1] == '1')
            max_ones = max(max_ones, current_ones)  # Keep track of max found
        scenario1_cost = total_ones - max_ones  # Cost of transforming scenario 1
    # Scenario 2: Window lengths > total_ones
    scenario2_cost = float('inf')
    if n > total_ones:
        min_zeros = float('inf')
        current_zeros = sum(1 for c in s[:total_ones + 1] if c == '0')  # Initial window count
        min_zeros = current_zeros  # First window
        for i in range(1, n - (total_ones + 1) + 1):
            current_zeros -= (s[i-1] == '0')
            current_zeros += (s[i + total_ones] == '0')
            min_zeros = min(min_zeros, current_zeros)  # Keep track of min found
        scenario2_cost = min_zeros  # Cost of transforming scenario 2
    # Choose the best (minimum cost) option
    candidates = [scenario1_cost, scenario_empty]
    if n > total_ones:
        candidates.append(scenario2_cost)
    return min(candidates)
# Read number of test cases
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056115
1390056118,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(i, n + 1):
            sub = s[i:j]
            if not sub:
                remaining_zeros = 0
                removed_ones = s.count('1')
            else:
                remaining_zeros = sub.count('0')
                removed_ones = s.count('1') - sub.count('1')
            cost = max(remaining_zeros, removed_ones)
            min_cost = min(min_cost, cost)
    print(min_cost)",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056118
1390056120,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056120
1390056101,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Compute impact: (strength + index, index)
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Get top k elements based on impact
        impact.sort(reverse=True)
        to_skip = {idx for _, idx in impact[:k]}  # Convert to set for quick lookup
        # Compute minimum effort
        effort, skipped = 0, 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Fast output
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056101
1390056103,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056103
1390056111,unknown,unknown,unknown,"import java.util.*;
import java.io.*;
public class FirewallSkips {
    public static void main(String[] args) {
        FastReader in = new FastReader(System.in);
        int T = in.nextInt();
        while (T-- > 0) {
            int n = in.nextInt();
            int k = in.nextInt();
            long[] a = new long[n];
            long sumA = 0; // sum of all a[i]
            for (int i = 0; i < n; i++) {
                a[i] = in.nextLong();
                sumA += a[i];
            }
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
            // We'll sort b in descending order to pick the top x.
            long[] b = new long[n];
            for (int i = 0; i < n; i++) {
                b[i] = a[i] + (i + 1);
            }
            Arrays.sort(b);
            // Sort ascending by default; we want descending, so either:
            // 1) reverse in place, or
            // 2) build prefix sums from the end.
            // Let's just reverse in place for clarity.
            reverse(b); // Now b is descending.
            // Build prefix sums of b in descending order:
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
            long[] prefix = new long[n+1];
            prefix[0] = 0;
            for (int x = 1; x <= n; x++) {
                prefix[x] = prefix[x-1] + b[x-1];
            }
            long ans = Long.MAX_VALUE;
            // Try x from 0..k (number of skips)
            for (int x = 0; x <= k; x++) {
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
                // Make sure to use long to avoid overflow
                long cost = sumA 
                            + x * (long)n 
                            - prefix[x]
                            - ((long)x * (x - 1) / 2);
                ans = Math.min(ans, cost);
            }
            System.out.println(ans);
        }
    }
    // Utility to reverse array in place
    private static void reverse(long[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            long tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;
            left++;
            right--;
        }
    }
    // Fast input class (optional, for large I/O)
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        public FastReader(InputStream stream) {
            br = new BufferedReader(new InputStreamReader(stream));
        }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
        long nextLong() {
            return Long.parseLong(next());
        }
    }
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056111
1390056095,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056095
1390056098,unknown,unknown,unknown,# Enter your code here. Read input from STDIN. Print output to STDOUT,8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056098
1390056094,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056094
1390056090,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class BreachFirewall {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine()); // Number of test cases
        StringBuilder result = new StringBuilder();
        while (T-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            int[] firewalls = new int[n];
            st = new StringTokenizer(br.readLine());
            int totalEffort = 0;
            for (int i = 0; i < n; i++) {
                firewalls[i] = Integer.parseInt(st.nextToken());
                totalEffort += firewalls[i]; // Calculate total sum
            }
            List<Integer> modifiedValues = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                modifiedValues.add(firewalls[i] - (n - i - 1)); // Transform array
            }
            // Sort in descending order
            modifiedValues.sort(Collections.reverseOrder());
            // Prefix sum calculation with boundary checks
            int[] prefixSum = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixSum[i + 1] = prefixSum[i] + modifiedValues.get(i);
            }
            // Finding the maximum sum with `t` firewall skips
            int maxSum = 0;
            int maxT = Math.min(k, n);
            for (int t = 0; t <= maxT; t++) {
                int current = prefixSum[t] + (t * (t - 1)) / 2;
                maxSum = Math.max(maxSum, current);
            }
            // Output the minimized firewall breach effort
            result.append(totalEffort - maxSum).append(""\n"");
        }
        System.out.print(result);
    }
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056090
1390056082,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>
using namespace std;
using ll = long long;
ll min_effort(int n, int k, const vector<int>& firewalls) {
    if (n == 0) return 0;
    // Maximum useful skips is min(k, n)
    int max_skips = min(k, n);
    vector<vector<ll>> dp(n + 1, vector<ll>(max_skips + 1, LLONG_MAX));
    dp[0][0] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= max_skips; ++j) {
            // Case 1: Do not skip the i-th firewall
            if (dp[i-1][j] != LLONG_MAX) {
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
            }
            // Case 2: Skip the i-th firewall if possible
            if (j > 0) {
                if (dp[i-1][j-1] != LLONG_MAX) {
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                }
            }
        }
    }
    return *min_element(dp[n].begin(), dp[n].end());
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; ++i) {
            cin >> firewalls[i];
        }
        cout << min_effort(n, k, firewalls) << '\n';
    }
    return 0;
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056082
1390056084,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056084
1390056086,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056086
1390056070,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
typedef struct {
    long long strength;
    int index;
} Firewall;
int compare(const void* a, const void* b) {
    Firewall* fw1 = (Firewall*)a;
    Firewall* fw2 = (Firewall*)b;
    if (fw1->strength > fw2->strength) return -1;
    if (fw1->strength < fw2->strength) return 1;
    return 0;
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        long long* strengths = (long long*)malloc(n * sizeof(long long));
        Firewall* firewalls = (Firewall*)malloc(n * sizeof(Firewall));
        for (int i = 0; i < n; i++) {
            scanf(""%lld"", &strengths[i]);
            firewalls[i].strength = strengths[i];
            firewalls[i].index = i;
        }
        qsort(firewalls, n, sizeof(Firewall), compare);
        int* skip = (int*)calloc(n, sizeof(int));
        int skipped = 0;
        for (int i = 0; i < n && skipped < k; i++) {
            skip[firewalls[i].index] = 1;
            skipped++;
        }
        long long totalEffort = 0;
        int penalty = 0;
        for (int i = 0; i < n; i++) {
            if (skip[i]) {
                penalty++;
            } else {
                totalEffort += strengths[i] + penalty;
            }
        }
        printf(""%lld\n"", totalEffort);
        free(strengths);
        free(firewalls);
        free(skip);
    }
    return 0;
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056070
1390056077,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        impact = [(strengths[i] + i, i) for i in range(n)]
        impact.sort(reverse=True)
        to_skip = set(idx for _, idx in impact[:k])
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056077
1390056078,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056078
1390056061,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            int ans = findResult(arr, k);
            System.out.print(ans);
            System.out.println();
        }
        scanner.close();
    }
    public static int findResult(int []arr, int k){
        int[] ans= new int[arr.length];
        int sum=0;
        for(int i =0;i<arr.length;i++){
            ans[i]=arr[i]-((arr.length-1)-i);
            sum+=arr[i];
        }
        Arrays.sort(ans);
        reverse(ans);
        for(int i =0;i<k;i++){
            if(ans[i]>0){
               // System.out.println(ans[i]+""w"");
                sum-=ans[i];
            }
        }
        return Math.max(sum,0);
    }
     private static void reverse(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056061
1390056067,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056067
1390056069,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056069
1390056060,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;
int solve(vector<int>&arr, int i, int skip, int inc,vector<vector<long long>>&dp) {
    int n = arr.size();
    if(i==n){
        return 0;
    }
    if(dp[i][skip]!=-1)return dp[i][skip];
    //skip
    int ans = INT_MAX;
    if(skip>0) {
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
    }
    //no skip
    int recAns = solve(arr,i+1,skip,inc,dp);
    if(recAns!=INT_MAX)
        ans = min(ans,arr[i]+inc+recAns);
    return dp[i][skip]= ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--) {
        int n,skip;
        cin>>n>>skip;
        vector<int>arr;
        vector<vector<long long>>dp(n,vector<long long>(skip+1,-1));
        while(n--) {
            int a;
            cin>>a;
            arr.push_back(a);
        }
        cout<<solve(arr,0,skip,0,dp)<<endl;
    }
    return 0;
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056060
1390056053,unknown,unknown,unknown,"def mn_cst(tst):
    rst=[]
    for s in tst:
        n = len(s)
        mc = float('inf')
        ta = s.count('1')
        ti=s.count('0')
        la=0
        li=0
        for i in range(n + 1):
            ra = la
            ri = li
            ri_rem = ti - ri
            ra_rem = ta - ra
            cst = max(ri_rem,ra)
            mc=min(mc,cst)
            if i<n:
                if s[i] == '1':
                    la += 1
                else:
                    li += 1
        rst.append(mc)
    return rst",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056053
1390056056,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056056
1390056059,unknown,unknown,unknown,"def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = dequeue()
    for i in range(n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
            if i >= k - 1:
                result.append(arr[dq[0]] if dq else 0)
                return result
if __name__ == ""__main__"":
    t = int(input().strip())
    for _ in range(t):
        n, k = map(int, input().strip())",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056059
1390056048,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  # Skip
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)  # Don't skip
    return min(dp[n])
t = int(input())
for _ in range(t):
    print(solve())",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056048
1390056049,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, LLONG_MAX));
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= k; ++j) {
                if (dp[i - 1][j] != LLONG_MAX) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j);
                }
                if (j > 0 && dp[i - 1][j - 1] != LLONG_MAX) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        cout << dp[n][k] << endl;
    }
    return 0;
}",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056049
1390056050,unknown,unknown,unknown,"def min_effort_to_breach_firewalls(t, test_cases):
    results = []
    for test in test_cases:
        n, k = test[0]
        arr = test[1]
        # Sort firewall strengths in descending order
        arr_sorted = sorted(arr, reverse=True)
        # Choose top k strong firewalls to skip
        skips = set()
        for i in range(k):
            skips.add(arr_sorted[i])
        total_effort = 0
        skipped = 0
        for strength in arr:
            if strength in skips and skipped < k:
                skipped += 1
                skips.remove(strength)  # Remove to handle duplicates properly
            else:
                total_effort += strength + skipped  # Each skip adds +1 to every subsequent effort
        results.append(total_effort)
    return results
# -------- DRIVER CODE --------
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append(((n, k), arr))
answers = min_effort_to_breach_firewalls(T, test_cases)
for ans in answers:
    print(ans)",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056050
1390056041,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for s in test_cases:
        first_one = s.find('1')
        last_one = s.rfind('1')
        if first_one == -1:
            results.append(0)  # All are '0's, no cost required
            continue
        idle_count = s[first_one:last_one+1].count('0')
        removed_active = first_one + (len(s) - last_one - 1)
        results.append(max(idle_count, removed_active))
    return results
# Reading input
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
# Processing and printing output
for res in min_decommission_cost(test_cases):
    print(res)",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056041
1390056042,unknown,unknown,unknown,"def earliest_faults(arr, k):
    result = []
    first_fault = 0  # Default if no faults in batch
    for i in range(len(arr) - k + 1):  # Iterate through batches
        batch = arr[i:i + k]
        first_fault = 0  # Reset for each batch
        for num in batch:  # Find first faulty reading
            if num < 0:
                first_fault = num
                break
        result.append(first_fault)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    # Get the result and print it
    print(*earliest_faults(arr, k))",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056042
1390056040,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056040
1390056039,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056039
1390056032,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j) 
    return min(dp[n])
t = int(input())
for _ in range(t):
    print(solve())",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056032
1390056038,unknown,unknown,unknown,"t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))
    if k<n:
        impacts=sorted([(arr[i]-(n-i-1),i) for i in range(n)],reverse=True)
        skip={impacts[i][1] for i in range(k)}
        ans=0
        penalty=0
        for i in range(n):
            if i in skip:penalty+=1
            else:ans+=arr[i]+penalty
        print(ans)
    else:print(0)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056038
1390056030,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommission {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();  // Number of test cases
        scanner.nextLine();         // Consume the leftover newline
        while (T-- > 0) {
            String servers = scanner.nextLine();
            int n = servers.length();
            // Build prefix sums for '0' and '1'
            // zeroCount[i] = # of '0's in servers[0..i-1]
            // oneCount[i]  = # of '1's in servers[0..i-1]
            int[] zeroCount = new int[n + 1];
            int[] oneCount  = new int[n + 1];
            for (int i = 0; i < n; i++) {
                zeroCount[i + 1] = zeroCount[i] + (servers.charAt(i) == '0' ? 1 : 0);
                oneCount[i + 1]  = oneCount[i]  + (servers.charAt(i) == '1' ? 1 : 0);
            }
            int totalOnes = oneCount[n];
            // Binary search over possible cost c
            int low = 0;
            int high = n;  // cost can't exceed n (worst case: remove all or keep all)
            while (low < high) {
                int mid = (low + high) / 2;
                if (feasible(mid, servers, zeroCount, oneCount, totalOnes)) {
                    high = mid;  // we can achieve cost <= mid
                } else {
                    low = mid + 1; // we cannot achieve cost mid, so increase
                }
            }
            System.out.println(low);
        }
        scanner.close();
    }
    /**
     * Checks if there exists a subarray [start, end) such that:
     *   #0 in subarray <= c
     *   #1 in subarray >= totalOnes - c
     */
    private static boolean feasible(int c, String servers,
                                   int[] zeroCount, int[] oneCount,
                                   int totalOnes) {
        int n = servers.length();
        int start = 0;
        for (int end = 0; end <= n; end++) {
            // Move start forward while #0 in [start, end) > c
            while (start < end && 
                   (zeroCount[end] - zeroCount[start]) > c) {
                start++;
            }
            // Now #0 in [start, end) <= c (unless start==end)
            int subarrayOnes = oneCount[end] - oneCount[start];
            // Check if #1 in subarray >= totalOnes - c
            if (subarrayOnes >= totalOnes - c) {
                return true;
            }
        }
        return false;
    }
}",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056030
1390056028,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def minimize_cost(t, test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        total_ones = s.count('1')
        if total_ones == 0 or total_ones == n:
            results.append(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
            if max_ones >= required_ones:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        results.append(answer)
    return results
if __name__ == ""__main__"":
    t = int(input())
    test_cases = [input().strip() for _ in range(t)]
    results = minimize_cost(t, test_cases)
    for res in results:
        print(res)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056028
1390056022,unknown,unknown,unknown,"def minimum_effort(arr,k):
    n = len(arr)
    effort = 0
    if k == n:
        return effort
    skip=0
    for i in range(n):
        if skip < k and arr[i] == max(arr):
            skip+=1
            arr[i]=0
        else:
            effort += arr[i]+skip
    return effort
t = int(input())
for _ in range(t):
    n,k= map(int , input().split())
    arr = list(map(int , input().split()))
    print(minimum_effort(arr,k))",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056022
1390056029,unknown,unknown,unknown,"def find_min_effort(n, k, strength):
    # dp[i][j] = minimum effort to process first i firewalls when j firewalls are skipped
    dp = [[float('inf') for _ in range(k + 1)] for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: no firewalls, no skips, no effort
    for i in range(1, n + 1):
        for j in range(min(i, k) + 1):
            # Skip current firewall (if we can)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
            # Process current firewall
            # Calculate any penalty from skipped firewalls
            penalty = 0
            if i > 1 and j > 0:
                penalty = j  # Add 1 for each skipped firewall
            dp[i][j] = min(dp[i][j], dp[i-1][j] + strength[i-1] + penalty)
    # Find minimum across all possible numbers of skips
    result = min(dp[n])
    return result
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Number of firewalls and max skips
        strength = list(map(int, input().split()))  # Strength of each firewall
        # Edge case: if k == n, we can skip all firewalls
        if k == n:
            print(0)
            continue
        # Calculate minimum effort using dp
        print(find_min_effort(n, k, strength))
if __name__ == ""__main__"":
    main()",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056029
1390056012,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056012
1390056016,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if _name_ == ""_main_"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056016
1390056017,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056017
1390056011,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    if k == n:
        return 0  
    min_increase = min(firewalls) + 1  
    min_effort = total_effort  
    for i in range(n):
        effort = total_effort - firewalls[i] + min_increase
        min_effort = min(min_effort, effort)
    return min_effort
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    firewalls = list(map(int, input().split()))  
    print(min_effort(n, k, firewalls))  ",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056011
1390056003,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056003
1390056009,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(t-- >0){
            int n=sc.nextInt();
            int k=sc.nextInt();
            int arr[]=new int[n];
            for(int i=0;i<n;i++){
                arr[i]=sc.nextInt();
            }
            int sum=0;
            int min=0;
            for(int i:arr){
                min+=i;
            }
            for(int i=0;i<n;i++){
                for(int j=0;j<i;j++){
                    sum+=arr[j];
                }
                for(int m=i+1;i<n;i++){
                    sum+=arr[m]+1;
                }
                min=Math.min(min,sum);
            }
            System.out.println(min);
        }
    }
}",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056009
1390056010,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":  # Corrected condition
    main()",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056010
1390055999,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    active_prefix_sum = [0] * (n + 1)
    idle_suffix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
    for i in range(n-1, -1, -1):
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
    min_cost = float('inf')
    for left in range(n + 1):
        for right in range(left, n + 1):
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055999
1390056000,unknown,unknown,unknown,"def min_cost(binary_string):
    n = len(binary_string)
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if binary_string[i] == '1' else 0)
    suffix_ones = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        suffix_ones[n - i] = suffix_ones[n - i - 1] + (1 if binary_string[i] == '1' else 0)
    total_zeros = binary_string.count('0')
    min_cost = float('inf')
    for left in range(n + 1):
        left_ones = prefix_ones[left]
        for right in range(n - left + 1):
            right_ones = suffix_ones[right]
            remaining_string = binary_string[left:n - right]
            remaining_zeros = remaining_string.count('0')
            cost = max(remaining_zeros, left_ones + right_ones)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    binary_string = input().strip()
    print(min_cost(binary_string))",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056000
1390056002,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056002
1390055989,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int T = input.nextInt();
        while (T-- > 0) {
            int N = input.nextInt();
            int K = input.nextInt();
            int[] array = new int[N];
            for (int i = 0; i < N; i++) {
                array[i] = input.nextInt();
            }
            if (K > N) {
                System.out.println(""0"");
                continue;
            }
            int result = 0;
            if (K == 1) {
                for (int num : array) {
                    if (num > 5) {
                        result += num;
                    }
                }
            } else if (K == N) {
                result = 0;
            } else {
                int minSum = Integer.MAX_VALUE;
                for (int j = 0; j <= N - K; j++) {
                    int a = 0;
                    for (int i = j; i < j + K; i++) {
                        a += array[i];
                    }
                    minSum = Math.min(minSum, a);
                }
                result = minSum;
            }
            System.out.println(result);
        }
    }
}",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055989
1390055992,unknown,unknown,unknown,"def earliest_faulty_in_batches(arr, n, k):
    result = []
    # Traverse the array in batches of size k
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        found_fault = False
        # Find the first negative number in the batch
        for num in batch:
            if num < 0:
                result.append(num)
                found_fault = True
                break
        # If no negative number is found, append 0
        if not found_fault:
            result.append(0)
    return result
# Reading input
t = int(input().strip())
outputs = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    outputs.append(earliest_faulty_in_batches(arr, n, k))
# Print results
for output in outputs:
    print("" "".join(map(str, output)))",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055992
1390055995,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>
using namespace std;
using ll = long long;
ll min_effort(int n, int k, const vector<int>& firewalls) {
    if (n == 0) return 0;
    // Maximum useful skips is min(k, n)
    int max_skips = min(k, n);
    vector<vector<ll>> dp(n + 1, vector<ll>(max_skips + 1, LLONG_MAX));
    dp[0][0] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= max_skips; ++j) {
            // Case 1: Do not skip the i-th firewall
            if (dp[i-1][j] != LLONG_MAX) {
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
            }
            // Case 2: Skip the i-th firewall if possible
            if (j > 0) {
                if (dp[i-1][j-1] != LLONG_MAX) {
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                }
            }
        }
    }
    return *min_element(dp[n].begin(), dp[n].end());
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; ++i) {
            cin >> firewalls[i];
        }
        cout << min_effort(n, k, firewalls) << '\n';
    }
    return 0;
}",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055995
1390055986,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    memo = {}
    def solve(idx, skipped):
        if idx == n:
            return 0
        if (idx, skipped) in memo:
            return memo[(idx, skipped)]
        skip_effort = float('inf')
        if skipped < k:
            skip_effort = solve(idx + 1, skipped + 1)
        dont_skip_effort = (strengths[idx] + skipped) + solve(idx + 1, skipped)
        result = min(skip_effort, dont_skip_effort)
        memo[(idx, skipped)] = result
        return result
    return solve(0, 0)
def solve_test_cases():
    t = int(input().strip())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, strengths)
        results.append(str(min_effort))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    solve_test_cases()",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055986
1390055979,unknown,unknown,unknown,"def min_cost(s):
    total_ones = s.count('1')
    n = len(s)
    # If no '1' exists, remove all (cost = 0)
    if total_ones == 0:
        return 0  
    scenario_empty = total_ones  # Cost if we remove all ones
    # Scenario 1: Try keeping a window of maximum '1's
    scenario1_cost = float('inf')
    max_ones_in_window = 0
    L = min(total_ones, n)
    for l in range(1, L + 1):  # Window size
        current_ones = sum(1 for c in s[:l] if c == '1')
        max_ones_in_window = max(max_ones_in_window, current_ones)
        for i in range(1, n - l + 1):
            current_ones -= (s[i - 1] == '1')
            current_ones += (s[i + l - 1] == '1')
            max_ones_in_window = max(max_ones_in_window, current_ones)
    scenario1_cost = total_ones - max_ones_in_window
    # Scenario 2: Try minimizing zeros left after removing 1s from both ends
    scenario2_cost = float('inf')
    min_zeros = float('inf')
    if n > total_ones:
        for l in range(total_ones + 1, n + 1):
            current_zeros = sum(1 for c in s[:l] if c == '0')
            min_zeros = min(min_zeros, current_zeros)
            for i in range(1, n - l + 1):
                current_zeros -= (s[i - 1] == '0')
                current_zeros += (s[i + l - 1] == '0')
                min_zeros = min(min_zeros, current_zeros)
        scenario2_cost = min_zeros
    candidates = [scenario1_cost, scenario_empty]
    if n > total_ones:
        candidates.append(scenario2_cost)
    return min(candidates)
# Read input
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055979
1390055981,unknown,unknown,unknown,"from collections import deque
def find_earliest_faulty_reading(testcases):
    results = []
    for testcase in testcases:
        n, k = testcase[0], testcase[1]  # n is the size of the array, k is the batch size
        arr = testcase[2]  # the array of sensor readings
        window = deque()  # This will store indices of the array elements
        res = []
        for i in range(n):
            # Remove elements that are outside the current batch
            if window and window[0] <= i - k:
                window.popleft()
            # Add the current element index to the window if it's a faulty reading
            if arr[i] < 0:
                window.append(i)
            # If we have a full window, record the earliest fault
            if i >= k - 1:
                if window:
                    res.append(arr[window[0]])  # Earliest fault in the window
                else:
                    res.append(0)  # No fault in the window
        results.append(res)
    return results
# Input handling
t = int(input())  # Number of test cases
testcases = []
for _ in range(t):
    n, k = map(int, input().split())  # Read size of array and batch size
    arr = list(map(int, input().split()))  # Read the array elements
    testcases.append((n, k, arr))
# Processing each test case
results = find_earliest_faulty_reading(testcases)
# Output results
for result in results:
    print("" "".join(map(str, result)))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055981
1390055984,unknown,unknown,unknown,"def compute_min_cost(cute):
    saloni = cute.count('1')
    if saloni == 0:
        return 0
    dogg = len(cute)
    mango = 0
    if saloni <= dogg:
        cherry = sum(1 for grape in cute[:saloni] if grape == '1')
        mango = cherry
        for banana in range(1, dogg - saloni + 1):
            if cute[banana - 1] == '1':
                cherry -= 1
            if cute[banana + saloni - 1] == '1':
                cherry += 1
            if cherry > mango:
                mango = cherry
    kiwi = 0
    apple = 0
    for orange in cute:
        if orange == '1':
            apple += 1
        else:
            if apple > 0:
                watermelon = min(apple, saloni - 1)
                if watermelon > kiwi:
                    kiwi = watermelon
                apple = 0
    if apple > 0:
        watermelon = min(apple, saloni - 1)
        if watermelon > kiwi:
            kiwi = watermelon
    panda = saloni - mango
    tiger = saloni - kiwi
    return min(panda, tiger)
def main():
    import sys
    input = sys.stdin.read().split()
    cherry = int(input[0])
    for dogg in range(1, cherry + 1):
        cute = input[dogg]
        print(compute_min_cost(cute))
if __name__ == ""__main__"":
    main()",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055984
1390055975,unknown,unknown,unknown,"def min_cost(s):
    total_ones = s.count('1')
    n = len(s)
    if total_ones == 0:
        return 0  
    scenario_empty = total_ones  # Cost if we remove all ones
    scenario1_cost = float('inf')
    max_ones_in_window = 0
    L = min(total_ones, n)
    for l in range(1, L + 1):  # Window size
        current_ones = sum(1 for c in s[:l] if c == '1')
        max_ones_in_window = max(max_ones_in_window, current_ones)
        for i in range(1, n - l + 1):
            current_ones -= (s[i - 1] == '1')
            current_ones += (s[i + l - 1] == '1')
            max_ones_in_window = max(max_ones_in_window, current_ones)
    scenario1_cost = total_ones - max_ones_in_window
    scenario2_cost = float('inf')
    min_zeros = float('inf')
    if n > total_ones:
        for l in range(total_ones + 1, n + 1):
            current_zeros = sum(1 for c in s[:l] if c == '0')
            min_zeros = min(min_zeros, current_zeros)
            for i in range(1, n - l + 1):
                current_zeros -= (s[i - 1] == '0')
                current_zeros += (s[i + l - 1] == '0')
                min_zeros = min(min_zeros, current_zeros)
        scenario2_cost = min_zeros
    candidates = [scenario1_cost, scenario_empty]
    if n > total_ones:
        candidates.append(scenario2_cost)
    return min(candidates)
# Read input
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055975
1390055976,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":
    main()",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055976
1390055973,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055973
1390055969,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055969
1390055970,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055970
1390055972,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055972
1390055968,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine();
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                dummyFunction();
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
    private static void dummyFunction() {
        int[] dummyArray = {1,1,1,1};
        int sum = 0;
        for (int i = 0; i < dummyArray.length; i++) {
            sum += dummyArray[i] % 7;
        }
        int result = sum % 13;
    }
}",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055968
1390055961,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        if bin(i).count('1') <= k:
            current_effort = 0
            current_a = a[:]
            for j in range(n):
                if (i >> j) & 1:
                    pass
                else:
                    current_effort += current_a[j]
                for l in range(j + 1, n):
                    if (i >> j) & 1:
                        current_a[l] += 1
            min_effort = min(min_effort, current_effort)
    return min_effort
t = int(input())
for _ in range(t):
    print(solve())",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055961
1390055964,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055964
1390055967,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055967
1390055955,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    firewalls.sort() 
    min_effort = float('inf')
    for skips in range(min(k, n) + 1):
        remaining_firewalls = firewalls[skips:]
        effort = sum(remaining_firewalls) + skips * len(remaining_firewalls)
        min_effort = min(min_effort, effort)
    return min_effort
def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    T = int(data[0].strip())  
    index = 1
    results = []
    for _ in range(T):
        n, k = map(int, data[index].strip().split())
        index += 1
        firewalls = list(map(int, data[index].strip().split()))
        firewalls = [f for f in firewalls if isinstance(f, int)]
        index += 1
        results.append(min_effort_to_breach(n, k, firewalls))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055955
1390055958,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if _name_ == _""main""_:
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055958
1390055959,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states , really tough one to solved actually 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i (if possible)
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055959
1390055938,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055938
1390055953,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        scanner.nextLine();
        for (int t = 0; t < T; t++) {
            String s = scanner.nextLine();
            int n = s.length();
            int[] prefixOnes = new int[n + 1];
            int[] prefixZeros = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
                prefixZeros[i + 1] = prefixZeros[i] + (s.charAt(i) == '0' ? 1 : 0);
            }
            int totalOnes = prefixOnes[n];
            int minCost = Integer.MAX_VALUE;
            for (int i = 0; i <= n; i++) {
                for (int j = i; j <= n; j++) {
                    int removedPrefixOnes = prefixOnes[i];
                    int removedSuffixOnes = prefixOnes[n] - prefixOnes[j];
                    int totalRemovedOnes = removedPrefixOnes + removedSuffixOnes;
                    int keptZeros = prefixZeros[j] - prefixZeros[i];
                    int cost = Math.max(keptZeros, totalRemovedOnes);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        scanner.close();
    }
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055953
1390055944,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    /**
     * Checks if it's feasible to satisfy the condition with X operations.
     * @param X The number of operations allowed.
     * @param onesIndices Indices of '1's in the string.
     * @param total1 Total number of '1's.
     * @return True if feasible, false otherwise.
     */
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        for (int i = 0; i < total1; i++) {
            int j = Math.max(i, 0); // Ensure j starts at or after i
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int segmentLength = j - i; 
            if (segmentLength >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            // Collect indices of '1's
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            // Handle edge case: no '1's
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            // Convert list to array for easier manipulation
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            // Binary search for minimum operations
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055944
1390055935,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055935
1390055929,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    server_list = [int(c) for c in servers]
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]
    min_cost = total_ones
    j = 0
    for i in range(n + 1):
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
            j += 1
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
        left_ones = prefix_sum[i]
        right_ones = total_ones - prefix_sum[j - 1]
        cost = max(segment_zeros, left_ones + right_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    results = []
    for i in range(1, t + 1):
        results.append(str(minimum_decommission_cost(data[i])))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    process_input()",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055929
1390055933,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    if k == 0:
        return total_effort  
    firewalls.sort()  
    min_skipped = sum(firewalls[:k])  
    return total_effort - min_skipped  
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055933
1390055934,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055934
1390055926,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055926
1390055927,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        if bin(i).count('1') <= k:
            current_effort = 0
            current_a = a[:]
            for j in range(n):
                if (i >> j) & 1:
                    pass
                else:
                    current_effort += current_a[j]
                for l in range(j + 1, n):
                    if (i >> j) & 1:
                        current_a[l] += 1
            min_effort = min(min_effort, current_effort)
    return min_effort
t = int(input())
for _ in range(t):
    print(solve())",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055927
1390055921,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055921
1390055916,unknown,unknown,unknown,"def earliest_faults(arr, k):
    result = []
    first_fault = 0  # Default if no faults in batch
    for i in range(len(arr) - k + 1):  # Iterate through batches
        batch = arr[i:i + k]
        first_fault = 0  # Reset for each batch
        for num in batch:  # Find first faulty reading
            if num < 0:
                first_fault = num
                break
        result.append(first_fault)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    # Get the result and print it
    print(*earliest_faults(arr, k))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055916
1390055917,unknown,unknown,unknown,"def f(s):
    n = len(s)
    ans = n  
    for i in range(n + 1):
        r = s[i:] 
        z = r.count('0')
        o = s[:i].count('1')  
        c = max(z, o)  
        if c < ans:
            ans = c  
    return ans  
for _ in range(int(input())):
    print(f(input().strip()))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055917
1390055920,unknown,unknown,unknown,"def min_decommissioning_cost(s):
    # Find the first and last occurrence of '1'
    first_one = s.find('1')
    last_one = s.rfind('1')
    # If no '1' exists, all servers are idle and can be removed
    if first_one == -1:
        return 0
    # Get the substring containing all important servers
    core_section = s[first_one:last_one + 1]
    # Count idle servers (0s) remaining in the core section
    remaining_zeros = core_section.count('0')
    # Count removed active servers (1s)
    removed_ones = first_one + (len(s) - 1 - last_one)
    # Return the minimum possible cost
    return max(remaining_zeros, removed_ones)
# Read number of test cases
T = int(input().strip())
# Process each test case
for _ in range(T):
    s = input().strip()
    print(min_decommissioning_cost(s))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055920
1390055915,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        for (int t = 0; t < T; t++) {
            String s = scanner.nextLine();
            int n = s.length();
            int[] prefixOnes = new int[n + 1];
            int[] prefixZeros = new int[n + 1];
            // Calculate prefix sums
            for (int i = 0; i < n; i++) {
                prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
                prefixZeros[i + 1] = prefixZeros[i] + (s.charAt(i) == '0' ? 1 : 0);
            }
            int totalOnes = prefixOnes[n];
            int minCost = Integer.MAX_VALUE;
            // Try all possible combinations of prefix and suffix removals
            for (int i = 0; i <= n; i++) {  // i = length of prefix to remove
                for (int j = i; j <= n; j++) {  // j = position to start removing suffix
                    // Removed prefix: [0...i-1]
                    // Kept substring: [i...j-1]
                    // Removed suffix: [j...n-1]
                    int removedPrefixOnes = prefixOnes[i];
                    int removedSuffixOnes = prefixOnes[n] - prefixOnes[j];
                    int totalRemovedOnes = removedPrefixOnes + removedSuffixOnes;
                    int keptZeros = prefixZeros[j] - prefixZeros[i];
                    int cost = Math.max(keptZeros, totalRemovedOnes);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        scanner.close();
    }
}",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055915
1390055908,unknown,unknown,unknown,"def min_firewall_effort(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        total_effort = sum(firewalls)  # Effort without skipping
        min_effort = total_effort  # Initialize with full effort
        if k == n:  # If we can skip all firewalls, effort is 0
            results.append(0)
            continue
        # Try skipping each firewall
        for i in range(n):
            skipped_effort = total_effort - firewalls[i]  # Remove skipped firewall
            extra_penalty = (n - 1)  # Each of remaining (n-1) gets +1
            min_effort = min(min_effort, skipped_effort + extra_penalty)
        results.append(min_effort)
    return results
# Input Handling
T = int(input())  # Number of test cases
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Read firewall strengths
    test_cases.append((n, k, firewalls))
# Processing and Output
for result in min_firewall_effort(test_cases):
    print(result)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055908
1390055907,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, strengths in test_cases:
        min_effort = float('inf')
        for skip in range(k + 1):  # Try skipping from 0 to k firewalls
            modified = strengths[:]  # Copy original list
            for i in range(skip, n):
                modified[i] += skip  # Increase firewall strength after skipping
            min_effort = min(min_effort, sum(modified[skip:]))  # Sum from skipped index onward
        results.append(min_effort)
    return results
# Reading input
T = int(input().strip())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    test_cases.append((n, k, strengths))
# Compute and print results
results = min_effort_to_breach(T, test_cases)
for res in results:
    print(res)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055907
1390055913,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                curr[s] = prev[s] + a[i] + s;
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055913
1390055901,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class BreachFirewall {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int T = Integer.parseInt(st.nextToken()); // Number of test cases
        StringBuilder result = new StringBuilder();
        while (T-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            int[] firewalls = new int[n];
            st = new StringTokenizer(br.readLine());
            int totalEffort = 0;
            for (int i = 0; i < n; i++) {
                firewalls[i] = Integer.parseInt(st.nextToken());
                totalEffort += firewalls[i]; // Calculate total sum
            }
            List<Integer> modifiedValues = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                modifiedValues.add(firewalls[i] - (n - i - 1)); // Transform the array
            }
            // Sort in descending order
            modifiedValues.sort(Collections.reverseOrder());
            // Compute prefix sum for best `t` firewalls to skip
            int[] prefixSum = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixSum[i + 1] = prefixSum[i] + modifiedValues.get(i);
            }
            int maxSum = 0;
            int maxT = Math.min(k, n);
            for (int t = 0; t <= maxT; t++) {
                int current = prefixSum[t] + (t * (t - 1)) / 2;
                maxSum = Math.max(maxSum, current);
            }
            result.append(totalEffort - maxSum).append(""\n"");
        }
        System.out.print(result);
    }
}",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055901
1390055905,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055905
1390055906,unknown,unknown,unknown,"import sys
def min_decommission_cost(server_rack):
    first_one = server_rack.find('1')
    last_one = server_rack.rfind('1')
    if first_one == -1:  
        return 0  # No active servers (all are '0'), cost is 0
    trimmed_rack = server_rack[first_one:last_one+1]
    idle_remaining = trimmed_rack.count('0')
    active_removed = first_one + (len(server_rack) - last_one - 1)
    return max(idle_remaining, active_removed)
def main():
    T = int(sys.stdin.readline().strip())
    for _ in range(T):
        server_rack = sys.stdin.readline().strip()
        print(min_decommission_cost(server_rack))
if __name__ == ""__main__"":
    main()",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055906
1390055895,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        first_one = servers.find('1')
        last_one = servers.find('1')
        if first_one == -1:
            results.append(0)
            continue
        trimmed = servers[first_one:last_one + 1]
        idle_remaining = trimmed.count('0')
        active_removed = servers[:first_one].count('1') + servers[last_one + 1:].count('1')
        results.append(max(idle_remaining, active_removed))
    return results
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
results in min_decommissioning_cost(test_cases)
for res in results:
    print(res)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055895
1390055898,unknown,unknown,unknown,"def min_cost(binary_string):
    n = len(binary_string)
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if binary_string[i] == '1' else 0)
    suffix_ones = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        suffix_ones[n - i] = suffix_ones[n - i - 1] + (1 if binary_string[i] == '1' else 0)
    total_zeros = binary_string.count('0')
    min_cost = float('inf')
    for left in range(n + 1):
        left_ones = prefix_ones[left]
        for right in range(n - left + 1):
            right_ones = suffix_ones[right]
            remaining_string = binary_string[left:n - right]
            remaining_zeros = remaining_string.count('0')
            cost = max(remaining_zeros, left_ones + right_ones)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    binary_string = input().strip()
    print(min_cost(binary_string))",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055898
1390055896,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<bits/stdc++.h>
using namespace std;
int solve(vector<int>& arr, int k){
    int n = arr.size();
    int ans = 0;
    set<int> st;
    vector<int> right(n,0);
    for(int i=0; i<n; i++) right[i]=n-i-1;
    priority_queue<pair<int,int>, vector<pair<int,int>>> pq;
    for(int i=0; i<n; i++) pq.push({arr[i],i});
    while(!pq.empty()){
        auto [val,idx] = pq.top(); pq.pop();
        if(right[idx] < val && k){
            st.insert(idx);
            k--;
            for(int i=0; i<idx; i++){
                right[i]--;
            }
            arr[idx]=0;
            // cout<<""inserted ""<<idx<<"" k:""<<k<<"" "";
        }    
    }
    // for(int i=0; i<n; i++) cout<<right[i]<<"" "";
    for(int i=0; i<n; i++){
        if(st.find(i)!=st.end()) ans += right[i];
        ans += arr[i];
    }
    return ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
    int t;
    cin>>t;
    while(t--){
        int n,k;
        cin>>n>>k;
        vector<int> arr(n);
        for(int i=0; i<n ;i++) cin>>arr[i];
        int ans = solve(arr,k);
        cout<<ans<<endl;
    }
    return 0;
}",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055896
1390055894,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [int(c) for c in servers]
    # Compute prefix sum of active servers (1s)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]  # Total active servers
    min_cost = total_ones  # Worst case: decommission all active servers
    j = 0  # Right boundary of the window
    for i in range(n + 1):
        # Move j to maintain segment_zeros >= total_ones_removed
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
            j += 1
        # Calculate cost at the current window
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
        left_ones = prefix_sum[i]
        right_ones = total_ones - prefix_sum[j - 1]
        cost = max(segment_zeros, left_ones + right_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    results = []
    for i in range(1, t + 1):
        results.append(str(minimum_decommission_cost(data[i])))
    print(""\n"".join(results))
# Correcting the name definition
if __name__ == ""__main__"":
    process_input()",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055894
1390055885,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])  # Number of test cases
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()  # Read the binary string
        i += 1
        n = len(s)
        A = [0] * (n + 1)
        B = [0] * (n + 1)
        for j in range(n):
            B[j + 1] = B[j] + (s[j] == '1')
            A[j + 1] = A[j] + (s[j] == '0')
        T = A[n]  # Total count of '0' in s
        C = [0] * (n + 1)
        E = [0] * (n + 1)
        for j in range(n):
            E[j + 1] = E[j] + (s[n - 1 - j] == '1')
            C[j + 1] = C[j] + (s[n - 1 - j] == '0')
        r = 10**9  # Large initial value
        for x_ in range(n + 1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0:
                y = 0
            if y > m:
                y = m
            for z in (y, y - 1, y + 1):
                if 0 <= z <= m:
                    v1 = B[x_] + E[z]
                    v2 = T - (A[x_] + C[z])
                    v = max(v1, v2)
                    if v < r:
                        r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o) + ""\n"")  # Add newline at the end for proper output formatting
if __name__ == ""__main__"":
    solve()",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055885
1390055888,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    # Create list of (value + index) for each firewall
    skip_value = []
    for i in range(n):
        skip_value.append((firewalls[i] + i, i))
    # Sort by descending benefit to skip
    skip_value.sort(reverse=True)
    # Mark which firewalls to skip
    skipped = [0] * n
    for i in range(k):
        _, idx = skip_value[i]
        skipped[idx] = 1
    # Now calculate final effort
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
# Main driver
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055888
1390055892,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055892
1390055874,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":
    main()",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055874
1390055876,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055876
1390055880,unknown,unknown,unknown,"import sys
def min_pruning_cost(T, test_cases):
    results = []
    for servers in test_cases:
        first_one = servers.find('1') 
        last_one = servers.rfind('1')  
        if first_one == -1:  
            results.append(""0"")
            continue
        core_segment = servers[first_one:last_one + 1]
        idle_remaining = core_segment.count('0')  
        active_removed = servers[:first_one].count('1') + servers[last_one + 1:].count('1')
        results.append(str(max(idle_remaining, active_removed)))
T = int(sys.stdin.readline().strip())  
test_cases = [sys.stdin.readline().strip() for _ in range(T)]
min_pruning_cost(T, test_cases)",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055880
1390055869,unknown,unknown,unknown,"import sys
input = sys.stdin.read
def min_decommissioning_cost(rack):
    left = rack.find('1')
    right = rack.rfind('1')
    # If no active servers (all zeros), cost = 0
    if left == -1:
        return 0
    # Trim the rack from leftmost '1' to rightmost '1'
    trimmed_rack = rack[left:right + 1]
    # Remaining idle servers after trimming
    remaining_idle = trimmed_rack.count('0')
    # Removed active servers from the left and right sides
    removed_active = rack[:left].count('1') + rack[right + 1:].count('1')
    # Cost = max(remaining idle servers, removed active servers)
    return max(remaining_idle, removed_active)
# Efficient Input Handling
data = input().strip().split(""\n"")
t = int(data[0])
test_cases = data[1:t + 1]
# Compute results
results = [str(min_decommissioning_cost(tc)) for tc in test_cases]
# Fast Output
sys.stdout.write(""\n"".join(results) + ""\n"")",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055869
1390055872,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055872
1390055870,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055870
1390055865,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    s = input().strip()
    init_0 = s.count('0')
    best = float('inf')
    n = len(s)
    for p in range(n + 1):  
        for q in range(n + 1 - p):
            if p + q > n:
                continue
            mid = s[p:n-q]
            if not mid: 
                zeros = 0
                ones_cut = s.count('1')
            else:
                zeros = mid.count('0')
                ones_cut = s.count('1') - mid.count('1')
            c = max(zeros, ones_cut)
            best = min(best, c)
    print(best)",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055865
1390055863,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        if bin(i).count('1') > k:
            continue
        current_effort = 0
        current_a = a[:] 
        for j in range(n):
            if (i >> j) & 1:
                pass  
            else:
                current_effort += current_a[j]
            for l in range(j + 1, n):
                if (i >> j) & 1:
                    current_a[l] += 1
        min_effort = min(min_effort, current_effort)
    return min_effort
t = int(input())
for _ in range(t):
    print(solve())",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055863
1390055864,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int bigger(int x, int y) {
    return x > y ? x : y;
}
int smaller(int x, int y) {
    return x < y ? x : y;
}
int main() {
    int testCount;
    scanf(""%d"", &testCount);
    for (int test = 0; test < testCount; test++) {
        char rack[100001];
        scanf(""%s"", rack);
        int length = strlen(rack);
        int *ones = (int*)calloc(length + 1, sizeof(int));
        int *zeros = (int*)calloc(length + 1, sizeof(int));
        for (int i = 0; i < length; i++) {
            ones[i + 1] = ones[i] + (rack[i] == '1' ? 1 : 0);
            zeros[i + 1] = zeros[i] + (rack[i] == '0' ? 1 : 0);
        }
        int bestResult = length;
        for (int front = 0; front <= length; front++) {
            for (int back = 0; back <= length - front; back++) {
                int removedOnes = ones[front] + (ones[length] - ones[length - back]);
                int remainingZeros = zeros[length - back] - zeros[front];
                int currentCost = bigger(removedOnes, remainingZeros);
                bestResult = smaller(bestResult, currentCost);
            }
        }
        printf(""%d\n"", bestResult);
        free(ones);
        free(zeros);
    }
    return 0;
}",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055864
1390055861,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055861
1390055850,unknown,unknown,unknown,"def min_effort_to_breach(firewall_strengths, k):
    n = len(firewall_strengths)
    if k >= n:
        return 0
    indexed_strengths = [(i, strength) for i, strength in enumerate(firewall_strengths)]
    memo = {}
    def solve(idx, skips_left, skipped_so_far):
        if idx == n:
            return 0
        key = (idx, skips_left, skipped_so_far)
        if key in memo:
            return memo[key]
        current_strength = firewall_strengths[idx] + skipped_so_far
        effort_breach = current_strength + solve(idx + 1, skips_left, skipped_so_far)
        effort_skip = float('inf')
        if skips_left > 0:
            effort_skip = solve(idx + 1, skips_left - 1, skipped_so_far + 1)
        result = min(effort_breach, effort_skip)
        memo[key] = result
        return result
    return solve(0, k, 0)
test_case = int(input())
for _ in range(test_case):
    a,b = list(map(int,input().split("" "")))
    arr = list(map(int,input().split("" "")))
    print(min_effort_to_breach(arr,b))
    ",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055850
1390055852,unknown,unknown,unknown,"def findEarliest(n, k, arr):
    res = []
    dq = deque()
    for i in range(n):
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            if dq:
                res.append(arr[dq[0]])
            else:
                res.append(0)
    return res
from collections import deque
t = int(input())
while t > 0:
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = findEarliest(n, k, arr)
    print("" "".join(map(str, result)))
    t -= 1
    ",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055852
1390055857,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        result.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements no longer in window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add new element if it's faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute and print output
for res in earliest_faulty_readings(test_cases):
    print(res)",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055857
1390055845,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    if k == 0:
        return total_effort  
    firewalls.sort()  
    min_skipped = sum(firewalls[:k])  
    return total_effort - min_skipped  
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055845
1390055844,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        earliest_fault = 0
        for j, reading in enumerate(batch):
            if reading < 0:
                earliest_fault = reading
                break
        result.append(earliest_fault)
    return result
if __name__ == ""__main__"":
    num_test_cases = int(input())  # Read the number of test cases
    for _ in range(num_test_cases):  # Iterate through test cases
        input_line = input().split()
        n = int(input_line[0])
        k = int(input_line[1])
        arr = list(map(int, input().split()))
        faults = find_earliest_faults(arr, k)
        print(*faults)",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055844
1390055848,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(k, n + 1):
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        if i < n and arr[i] < 0:
            dq.append(i)
    return result
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = earliest_faulty_readings(arr, k)
        print(*result)
solve()",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055848
1390055843,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055843
1390055831,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for (int testCase = 0; testCase < t; testCase++) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextInt();
            }
            System.out.println(minimumEffort(strengths, k));
        }
        scanner.close();
    }
    public static long minimumEffort(int[] strengths, int k) {
        int n = strengths.length;
        if (k >= n) {
            return 0;
        }
        long[] dp = new long[k + 1];
        Arrays.fill(dp, Long.MAX_VALUE / 2);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            long[] newDp = new long[k + 1];
            Arrays.fill(newDp, Long.MAX_VALUE / 2);
            for (int j = 0; j <= k; j++) {
                if (j == 0) {
                    newDp[0] = dp[0] + strengths[i];
                } else {
                    newDp[j] = dp[j] + strengths[i] + j;
                }
                if (j > 0) {
                    newDp[j] = Math.min(newDp[j], dp[j - 1]);
                }
            }
            dp = newDp;
        }
        long minEffort = dp[0];
        for (int j = 1; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[j]);
        }
        return minEffort;
    }
}",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055831
1390055835,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def min_flips_to_make_ones_consecutive(s):
    n = len(s)
    total_ones = s.count('1')
    if total_ones == 0 or '1' * total_ones in s:
        return 0
    total_zeros = n - total_ones
    max_consecutive_ones = max(map(len, s.split('0')))
    low, high = 0, max(total_ones, total_zeros)
    answer = high
    while low <= high:
        mid = (low + high) // 2
        required_ones = max(0, total_ones - mid)
        if required_ones == 0:
            answer = mid
            high = mid - 1
            continue
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
        if max_ones >= required_ones:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_flips_to_make_ones_consecutive(s))",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055835
1390055837,unknown,unknown,unknown,"from collections import deque
def earliest_fault_in_batches(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(len(arr) - k + 1):
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        while dq and dq[0] < i + 1:
            dq.popleft()
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_fault_in_batches(arr, k))",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055837
1390055827,unknown,unknown,unknown,"t = int(input())
while t:
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    dp = [float('inf')] * (k + 1)
    dp[0] = 0
    for i in range(n):
        next_dp = [float('inf')] * (k + 1)
        for j in range(k + 1):
            next_dp[j] = min(next_dp[j], dp[j] + arr[i] + j)
            if j < k:
                next_dp[j + 1] = min(next_dp[j + 1], dp[j])
        dp = next_dp
    result = min(dp)
    print(result)
    t-=1",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055827
1390055830,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        if bin(i).count('1') > k:
            continue
        current_effort = 0
        current_a = a[:] 
        for j in range(n):
            if (i >> j) & 1:
                pass  
            else:
                current_effort += current_a[j]
            for l in range(j + 1, n):
                if (i >> j) & 1:
                    current_a[l] += 1
        min_effort = min(min_effort, current_effort)
    return min_effort
t = int(input())
for _ in range(t):
    print(solve())",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055830
1390055828,unknown,unknown,unknown,"for _ in range(int(input())):
    x,y = map(int,input().split())
    arr = list(map(int,input().split()))
    effort = 0
    effort = sum(sorted(arr)[:x-y]) + x - y
    print(effort)",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055828
1390055819,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [int(c) for c in servers]
    # Compute prefix sum of active servers (1s)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]  # Total active servers
    min_cost = total_ones  # Worst case: decommission all active servers
    j = 0  # Right boundary of the window
    for i in range(n + 1):
        # Move j to maintain segment_zeros >= total_ones_removed
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
            j += 1
        # Calculate cost at current window
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
        left_ones = prefix_sum[i]
        right_ones = total_ones - prefix_sum[j - 1]
        cost = max(segment_zeros, left_ones + right_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    results = []
    for i in range(1, t + 1):
        results.append(str(minimum_decommission_cost(data[i])))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    process_input()",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055819
1390055820,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean check(int val, int[] idxArray, int count) {
        if (val >= count) return true;
        int right = 0;
        for (int left = 0; left < count; left++) {
            if (right < left) right = left;
            while (right < count && (idxArray[right] - idxArray[left] - (right - left)) <= val) {
                right++;
            }
            int length = right - left; 
            if (length >= count - val) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int testCases = scanner.nextInt();
        while(testCases-- > 0) {
            String input = scanner.next();
            int size = input.length();
            ArrayList<Integer> positions = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                if (input.charAt(i) == '1') {
                    positions.add(i);
                }
            }
            int count = positions.size();
            if (count == 0) {
                System.out.println(0);
                continue;
            }
            int[] idxArray = new int[count];
            for (int i = 0; i < count; i++) {
                idxArray[i] = positions.get(i);
            }
            int left = 0, right = count, result = right;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (check(mid, idxArray, count)) {
                    result = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            System.out.println(result);
        }
        scanner.close();
    }
}",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055820
1390055824,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055824
1390055818,unknown,unknown,unknown,"import sys
def calculate_min_removal_cost():
    input_data = sys.stdin.read().splitlines()
    test_cases = int(input_data[0].strip())
    current_line = 1
    results = []
    for _ in range(test_cases):
        server_status = input_data[current_line].strip()
        current_line += 1
        total_servers = len(server_status)
        active_indices = [i for i, server in enumerate(server_status) if server == '1']
        active_server_count = len(active_indices)
        if active_server_count == 0:
            results.append(""0"")
            continue
        adjusted_positions = [active_indices[i] - i for i in range(active_server_count)]
        def is_removal_feasible(limit):
            if active_server_count - limit <= 0:
                return True
            j = 0
            for i in range(active_server_count):
                if j < i:
                    j = i
                while j < active_server_count and adjusted_positions[j] - adjusted_positions[i] <= limit:
                    j += 1
                if j - i >= active_server_count - limit:
                    return True
            return False
        low, high, min_removal_cost = 0, total_servers, total_servers
        while low <= high:
            mid = (low + high) // 2
            if is_removal_feasible(mid):
                min_removal_cost = mid
                high = mid - 1
            else:
                low = mid + 1
        results.append(str(min_removal_cost))
    sys.stdout.write(""\n"".join(results))
if __name__ == ""__main__"":
    calculate_min_removal_cost()",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055818
1390055815,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int computeCost(string dataCenters) {
     int size = dataCenters.size();
    int firstActiveIndex = dataCenters.find('1');
     int lastActiveIndex = dataCenters.rfind('1');
    if (firstActiveIndex == string::npos) return 0;
    string activeSegment = dataCenters.substr(firstActiveIndex, lastActiveIndex - firstActiveIndex + 1);
    int inactiveCount = count(activeSegment.begin(), activeSegment.end(), '0');
    int  minShutdownCost = inactiveCount, activeRemoved = 0;  
    for (int index = firstActiveIndex; index <= lastActiveIndex; index++) {
        if (dataCenters[index] == '1') 
            activeRemoved++;
        else 
             inactiveCount--;
        minShutdownCost = min(minShutdownCost, max(inactiveCount, activeRemoved));
    }
    return minShutdownCost;
}
int main() {
    int testCases;
    cin >> testCases;
    while (testCases--) {
          string dataCenters;
        cin >> dataCenters;
        cout << computeCost(dataCenters) << endl;
    }
    return 0;
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055815
1390055816,unknown,unknown,unknown,"vimport java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055816
1390055814,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055814
1390055805,unknown,unknown,unknown,"def main():
    import sys
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        gains = []
        for i in range(n):
            g = a[i] - (n - i - 1)
            gains.append(g)
        gains.sort(reverse=True)
        selected = gains[:k]
        sum_gain = sum(selected)
        sum_gain += k * (k - 1) // 2
        minimal_effort = sum_a - sum_gain
        print(minimal_effort)
if __name__ == ""__main__"":
    main()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055805
1390055810,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class BinaryStringMinMoves {
    // Function to check if a given X is feasible
    static boolean isFeasible(int X, int[] onesPositions, int onesCount) {
        if (X >= onesCount) return true; // If X is greater than total ones, it's always possible
        int j = 0;
        for (int i = 0; i < onesCount; i++) {
            if (j < i) j = i;
            // Expand the window while the difference is within the allowed moves
            while (j < onesCount && (onesPositions[j] - onesPositions[i] - (j - i)) <= X) {
                j++;
            }
            int consecutiveOnes = j - i; 
            if (consecutiveOnes >= onesCount - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int testCases = scanner.nextInt();
        while (testCases-- > 0) {
            String binaryString = scanner.next();
            int n = binaryString.length();
            List<Integer> onesIndices = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (binaryString.charAt(i) == '1') {
                    onesIndices.add(i);
                }
            }
            int onesCount = onesIndices.size();
            // If there are no '1's, no moves are required
            if (onesCount == 0) {
                System.out.println(0);
                continue;
            }
            // Convert list to array for faster access
            int[] onesPositions = new int[onesCount];
            for (int i = 0; i < onesCount; i++) {
                onesPositions[i] = onesIndices.get(i);
            }
            // Binary search to find the minimum feasible X
            int left = 0, right = onesCount, minMoves = right;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (isFeasible(mid, onesPositions, onesCount)) {
                    minMoves = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            System.out.println(minMoves);
        }
        scanner.close();
    }
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055810
1390055813,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} 3rd
    return 0;
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055813
1390055800,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055800
1390055801,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055801
1390055804,unknown,unknown,unknown,"import java.util.Scanner;
import java.util.Arrays;
import java.util.Comparator;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); // Number of test cases
        while (T-- > 0) {
            int n = sc.nextInt(); // Number of firewalls
            int k = sc.nextInt(); // Maximum number of firewalls to skip
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = sc.nextInt(); // Strength of each firewall
            }
            // If we can skip all firewalls, the answer is 0
            if (k >= n) {
                System.out.println(0);
                continue;
            }
            // We need to decide which firewalls to skip
            // Use a greedy approach: Skip the k firewalls with highest strength
            // Create a pair of (strength, index) for each firewall
            final int[][] firewalls = new int[n][2];
            for (int i = 0; i < n; i++) {
                firewalls[i][0] = strengths[i]; // Strength
                firewalls[i][1] = i;            // Index
            }
            // Sort firewalls by strength in descending order (Java 7 compatible)
            Arrays.sort(firewalls, new Comparator<int[]>() {
                @Override
                public int compare(int[] a, int[] b) {
                    return b[0] - a[0]; // Sort in descending order
                }
            });
            // Mark the top k firewalls to skip
            boolean[] skip = new boolean[n];
            for (int i = 0; i < k; i++) {
                skip[firewalls[i][1]] = true;
            }
            // Calculate the minimum effort
            long effort = 0;
            int skipped = 0;
            for (int i = 0; i < n; i++) {
                if (skip[i]) {
                    skipped++;
                } else {
                    effort += strengths[i] + skipped;
                }
            }
            System.out.println(effort);
        }
        sc.close();
    }
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055804
1390055799,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055799
1390055793,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055793
1390055796,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055796
1390055798,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        sc.nextLine(); // Consume the newline character
        while (t-- > 0) {
            String servers = sc.nextLine();
            System.out.println(minDecommissioningCost(servers));
        }
        sc.close();
    }
    static int minDecommissioningCost(String servers) {
        int n = servers.length();
        int[] prefixOnes = new int[n + 1];
        int[] prefixZeros = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
        }
        int minCost = Integer.MAX_VALUE;
        for (int start = 0; start <= n; start++) {
            for (int end = start; end <= n; end++) {
                int activeRemoved = prefixOnes[start] + (prefixOnes[n] - prefixOnes[end]);
                int idleRemaining = prefixZeros[end] - prefixZeros[start];
                int cost = Math.max(idleRemaining, activeRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055798
1390055780,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055780
1390055792,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if name == ""main"":
    main()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055792
1390055786,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055786
1390055774,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055774
1390055776,unknown,unknown,unknown,"def feasible(X, ones_indices, total1):
    if X >= total1:
        return True
    j = 0
    for i in range(total1):
        if j < i:
            j = i
        while j < total1 and (ones_indices[j] - ones_indices[i] - (j - i)) <= X:
            j += 1
        m = j - i
        if m >= total1 - X:
            return True
    return False
def min_operations_to_make_continuous(s):
    ones_indices = [i for i, ch in enumerate(s) if ch == '1']
    total1 = len(ones_indices)
    if total1 == 0:
        return 0
    low, high, ans = 0, total1, total1
    while low <= high:
        mid = low + (high - low) // 2
        if feasible(mid, ones_indices, total1):
            ans = mid
            high = mid - 1
        else:
            low = mid + 1
    return ans
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_operations_to_make_continuous(s))",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055776
1390055777,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()  # Deque to store indices of negative numbers
    # Process the first window of size k
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the new element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input().strip())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Read n and k
        arr = list(map(int, input().split()))  # Read array elements
        # Get the earliest faulty readings
        output = earliest_faulty_readings(arr, k)
        # Print result as space-separated values
        print("" "".join(map(str, output)))
if __name__ == ""__main__"":
    main()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055777
1390055771,unknown,unknown,unknown,"import sys
def min_effort(n, k, strengths):
    total_effort = sum(strengths)  # Sum of all firewall strengths
    if k == n:
        return 0  # If we can skip all firewalls, minimum effort is 0
    return total_effort - min(strengths)  # Remove the weakest firewall to minimize effort
# Fast input reading for large constraints
input = sys.stdin.read
data = input().split(""\n"")
T = int(data[0].strip())  # Number of test cases
index = 1  # To track input lines
results = []
for _ in range(T):
    n, k = map(int, data[index].split())  # Number of firewalls and skippable count
    strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
    results.append(str(min_effort(n, k, strengths)))  # Compute and store results
    index += 2  # Move to next test case
# Print all results efficiently in one go
sys.stdout.write(""\n"".join(results) + ""\n"")",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055771
1390055760,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055760
1390055765,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055765
1390055767,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine().trim());
        StringBuilder sb = new StringBuilder();
        for (int testCase = 0; testCase < t; testCase++) {
            String[] nk = br.readLine().trim().split("" "");
            int n = Integer.parseInt(nk[0]);
            int k = Integer.parseInt(nk[1]);
            int[] strengths = new int[n];
            String[] vals = br.readLine().trim().split("" "");
            for (int i = 0; i < n; i++) {
                strengths[i] = Integer.parseInt(vals[i]);
            }
            sb.append(minimumEffort(strengths, k)).append(""\n"");
        }
        System.out.print(sb);
    }
    public static long minimumEffort(int[] strengths, int k) {
        int n = strengths.length;
        if (k >= n) {
            return 0;
        }
        long[] savings = new long[n];
        for (int i = 0; i < n; i++) {
            savings[i] = strengths[i];
            savings[i] += n - i - 1;
        }
        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());
        for (int i = 0; i < n; i++) {
            pq.offer(savings[i]);
        }
        long totalCost = 0;
        for (int i = 0; i < n; i++) {
            totalCost += strengths[i];
        }
        long totalSavings = 0;
        for (int i = 0; i < k && !pq.isEmpty(); i++) {
            totalSavings += pq.poll();
        }
        return totalCost - totalSavings + (long) k * (k - 1) / 2;
    }
}",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055767
1390055755,unknown,unknown,unknown,"t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    firewall = list(map(int, input().split())) 
    if n==k:
        print(0)
        continue
    totaleffort = sum(firewall)  
    mineffort = totaleffort  
    for i in range(n):  
        skipeffort = totaleffort - firewall[i] + 1  
        mineffort = min(mineffort, skipeffort) 
    print(mineffort)  ",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055755
1390055759,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055759
1390055757,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} 3rd
    return 0;
}",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055757
1390055746,unknown,unknown,unknown,"import sys
def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        firewalls.sort()  # Sorting helps prioritize skipping the weakest firewalls
        total_effort = sum(firewalls)  # Base effort if we don’t skip anything
        min_effort = total_effort
        # Compute prefix sum to quickly access sum of first 'i' firewalls
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + firewalls[i]
        # Try skipping from 0 to k firewalls
        for skip in range(k + 1):
            skipped_effort = prefix_sum[skip]  # Sum of skipped firewalls
            remaining_count = n - skip  # Firewalls left after skipping
            penalty = remaining_count * skip  # Extra cost due to increased strength
            new_effort = (total_effort - skipped_effort) + penalty
            min_effort = min(min_effort, new_effort)  # Track the minimum effort
        results.append(str(min_effort))  # Store the result
    sys.stdout.write(""\n"".join(results) + ""\n"")  # Fast output handling
# **Input Handling**
T = int(sys.stdin.readline().strip())  # Number of test cases
test_cases = []
for _ in range(T):
    n, k = map(int, sys.stdin.readline().split())
    firewalls = list(map(int, sys.stdin.readline().split()))
    test_cases.append((n, k, firewalls))
# **Function Call**
min_effort_to_breach(T, test_cases)",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055746
1390055749,unknown,unknown,unknown,"def mb(n,k,s):
    if k>=n:
        return 0
    impacts=[]
    for i in range(n):
        impact=s[i]-(n-i-1)
        impacts.append((impact,i))
    impacts.sort(reverse=True)
    ts=set(impacts[i][1]for i in range(k))
    te=0
    p=0
    for i in range(n):
        if i in ts:
            p+=1
        else:
            te+=s[i]+p
    return te
def st():
    t=int(input())
    results=[]
    for _ in range(t):
        n,k=map(int,input().split())
        s=list(map(int,input().split()))
        results.append(mb(n,k,s))
    return results
def main():
    results=st()
    for r in results:
        print(r)
if __name__==""__main__"":
    main()",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055749
1390055753,unknown,unknown,unknown,"def min_effort(n,k,strengths):
    strengths.sort()
    return sum(strengths[1 + k:])
t = int(input().strip())
for _ in range(t):
    n,k = map(int, input().strip().split())
    strengths = list(map(int, input().strip().split()))
    if k >= n:
        print(0)
    else:
        print(min_effort(n,k,strengths))",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055753
1390055745,unknown,unknown,unknown,"import sys
def min_effort(n, k, firewalls):
    if k == n:
        return 0  # If we can skip all firewalls, effort is 0.
    return sum(firewalls) - min(firewalls)  # Skip the weakest firewall.
# Fast input handling
input = sys.stdin.read
data = input().split(""\n"")
T = int(data[0].strip())
index = 1
results = []
for _ in range(T):
    n, k = map(int, data[index].split())
    firewalls = list(map(int, data[index + 1].split()))
    results.append(str(min_effort(n, k, firewalls)))
    index += 2
# Output results efficiently
sys.stdout.write(""\n"".join(results) + ""\n"")",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055745
1390055733,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055733
1390055734,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    firewalls.sort()  
    effort = sum(firewalls[:n - k])  
    return effort
t = int(input().strip())
for _ in range(t):
    n, k = map(int, input().strip().split())
    firewalls = list(map(int, input().strip().split()))
    print(min_effort(n, k, firewalls))",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055734
1390055743,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
main()",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055743
1390055725,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); 
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055725
1390055724,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        while (T-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            int sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
                sum_a += a[i];
            }
            List<Integer> v = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                v.add(a[i] - (n - i - 1));
            }
            v.sort(Collections.reverseOrder());
            int[] prefix = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefix[i + 1] = prefix[i] + v.get(i);
            }
            int max_sum = 0;
            int max_t = Math.min(k, n);
            for (int t = 0; t <= max_t; t++) {
                int current = prefix[t] + t * (t - 1) / 2;
                max_sum = Math.max(max_sum, current);
            }
            System.out.println(sum_a - max_sum);
        }
        scanner.close();
    }
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055724
1390055730,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases): 
    results = []
    for s in test_cases:
        n = len(s)
        prefix_ones = [0] * (n + 1)
        prefix_zeros = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_ones[i] = prefix_ones[i - 1] + (1 if s[i - 1] == '1' else 0)
            prefix_zeros[i] = prefix_zeros[i - 1] + (1 if s[i - 1] == '0' else 0)
        total_ones = prefix_ones[n]
        total_zeros = prefix_zeros[n]
        min_cost = float('inf')
        for i in range(n):
            for j in range(i + 1, n + 1):
                ones_in_subarray = prefix_ones[j] - prefix_ones[i]
                zeros_in_subarray = prefix_zeros[j] - prefix_zeros[i]
                removed_ones = total_ones - ones_in_subarray
                cost = max(zeros_in_subarray, removed_ones)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input())  
test_cases = [input().strip() for _ in range(T)]
results = min_decommissioning_cost(test_cases)
for result in results:
    print(result)",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055730
1390055715,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i;
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055715
1390055716,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        A = [positions[i] - i for i in range(m)]
        def check(X):
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                while j < m and A[j] - A[i] <= X:
                    j += 1
                if j - i >= m - X:
                    return True
            return False
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055716
1390055717,unknown,unknown,unknown,"def m(n, k, a):
    if k >= n:
        return 0
    L = []
    for i in range(n):
        L.append((a[i] - (n - i - 1), i))
    L.sort(reverse=True)
    S = set(x[1] for x in L[:k])
    t = 0
    p = 0
    for i in range(n):
        if i in S:
            p += 1
        else:
            t += a[i] + p
    return t
def s():
    t = int(input())
    r = []
    for _ in range(t):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        r.append(m(n, k, a))
    return r
def main():
    for x in s():
        print(x)
if __name__ == ""__main__"":
    main()",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055717
1390055711,unknown,unknown,unknown,"t = int(input())  
for _ in range(t):  
    n, k = map(int, input().split())  
    firewalls = list(map(int, input().split()))  
    if k >= n:  
        print(0)  
        continue  
    min_effort = sum(firewalls)  
    for i in range(n - k + 1):  
        effort = 0  
        skipped = 0  
        for j in range(n):  
            if i <= j < i + k:  
                skipped += 1  
                continue  
            effort += firewalls[j] + skipped  
        min_effort = min(min_effort, effort)  
    print(min_effort)  ",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055711
1390055706,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055706
1390055710,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    min_total_effort = float('inf')
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
    dp[0][0] = 0  
    for i in range(1, n+1):
        current_strength = strengths[i-1]
        for j in range(k+1):
            if dp[i-1][j] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
        for j in range(1, k+1):
            if dp[i-1][j-1] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, strengths)
        results.append(min_effort)
    return results
if __name__ == ""__main__"":
    results = solve_test_cases()
    for result in results:
        print(result)",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055710
1390055709,unknown,unknown,unknown,"import sys
def min_pruning_cost(T, test_cases):
    results = []
    for servers in test_cases:
        first_one = servers.find('1')  # First occurrence of '1'
        last_one = servers.rfind('1')  # Last occurrence of '1'
        if first_one == -1:  # No '1' present in the string
            results.append(""0"")
            continue
        # Core section between first and last '1'
        core_section = servers[first_one:last_one + 1]
        idle_remaining = core_section.count('0')  # Count '0's in core section
        # Active servers removed from edges
        active_removed = servers[:first_one].count('1') + servers[last_one + 1:].count('1')
        # Minimum cost
        results.append(str(max(idle_remaining, active_removed)))
    # Print all results efficiently
    sys.stdout.write(""\n"".join(results) + ""\n"")
# **Input Handling**
T = int(sys.stdin.readline().strip())  # Number of test cases
test_cases = [sys.stdin.readline().strip() for _ in range(T)]
# **Function Call**
min_pruning_cost(T, test_cases)",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055709
1390055697,unknown,unknown,unknown,"def minimize_decommission_cost(test_cases):
    results = []
    for binary_string in test_cases:
        n = len(binary_string)
        total_idle = binary_string.count('0') 
        total_active = binary_string.count('1')  
        min_cost = float('inf')  
        for start in range(n + 1):  
            for end in range(n - start + 1):  
                remaining = binary_string[start:n - end]
                remaining_idle = remaining.count('0')
                decommissioned_active = total_active - remaining.count('1')
                cost = max(remaining_idle, decommissioned_active)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
results = minimize_decommission_cost(test_cases)
for result in results:
    print(result)",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055697
1390055699,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean isFeasible(int maxShifts, int[] onePositions, int totalOnes) {
        if (maxShifts >= totalOnes) return true;
        int right = 0;
        for (int left = 0; left < totalOnes; left++) {
            if (right < left) right = left;
            while (right < totalOnes && (onePositions[right] - onePositions[left] - (right - left)) <= maxShifts) {
                right++;
            }
            int consecutive = right - left;
            if (consecutive >= totalOnes - maxShifts) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int testCases = scanner.nextInt();
        while (testCases-- > 0) {
            String input = scanner.next();
            int length = input.length();
            List<Integer> oneIndicesList = new ArrayList<>();
            for (int i = 0; i < length; i++) {
                if (input.charAt(i) == '1') {
                    oneIndicesList.add(i);
                }
            }
            int totalOnes = oneIndicesList.size();
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            int[] onePositions = new int[totalOnes];
            for (int i = 0; i < totalOnes; i++) {
                onePositions[i] = oneIndicesList.get(i);
            }
            int low = 0, high = totalOnes, result = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (isFeasible(mid, onePositions, totalOnes)) {
                    result = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(result);
        }
        scanner.close();
    }
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055699
1390055701,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055701
1390055693,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states , really tough one to solved actually 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i (if possible)
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055693
1390055694,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055694
1390055695,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
            }
            int[][] dp = new int[n + 1][k + 1];
            for (int[] row : dp) Arrays.fill(row, -1);
            int result = solveDP(0, k, 0, a, dp);
            System.out.println(result);
        }
        sc.close();
    }
    static int solveDP(int index, int remainingSkips, int skippedCount, int[] a, int[][] dp) {
        if (index == a.length) return 0;
        if (dp[index][remainingSkips] != -1) return dp[index][remainingSkips];
        int skipEffort = Integer.MAX_VALUE;
        if (remainingSkips > 0) {
            skipEffort = solveDP(index + 1, remainingSkips - 1, skippedCount + 1, a, dp);
        }
        int takeEffort = a[index] + skippedCount + solveDP(index + 1, remainingSkips, skippedCount, a, dp);
        dp[index][remainingSkips] = Math.min(skipEffort, takeEffort);
        return dp[index][remainingSkips];
    }
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055695
1390055684,unknown,unknown,unknown,"import sys
def min_pruning_cost():
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    results = []
    for _ in range(t):
        servers = input_data[line].strip()
        line += 1
        n = len(servers)
        active_positions = [i for i, ch in enumerate(servers) if ch == '1']
        active_count = len(active_positions)
        if active_count == 0:
            results.append(""0"")
            continue
        offset_positions = [active_positions[i] - i for i in range(active_count)]
        def is_valid_pruning(limit):
            if active_count - limit <= 0:
                return True
            j = 0
            for i in range(active_count):
                if j < i:
                    j = i
                while j < active_count and offset_positions[j] - offset_positions[i] <= limit:
                    j += 1
                if j - i >= active_count - limit:
                    return True
            return False
        lo, hi, min_cost = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if is_valid_pruning(mid):
                min_cost = mid
                hi = mid - 1
            else:
                lo = mid + 1
        results.append(str(min_cost))
    sys.stdout.write(""\n"".join(results))
if __name__ == ""__main__"":
    min_pruning_cost()",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055684
1390055678,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055678
1390055681,unknown,unknown,unknown,"def min_effort_to_breach(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        fw = firewalls[i - 1]
        for j in range(k + 1):
            if j <= i - 1:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + fw + j)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(firewalls, k))",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055681
1390055683,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommission {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();  // Number of test cases
        scanner.nextLine();         // Consume the leftover newline
        while (T-- > 0) {
            String servers = scanner.nextLine();
            int n = servers.length();
            // Build prefix sums for '1's and '0's
            // prefixOnes[i] = number of '1's in servers[0..i-1]
            // prefixZeroes[i] = number of '0's in servers[0..i-1]
            int[] prefixOnes = new int[n + 1];
            int[] prefixZeroes = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
                prefixZeroes[i + 1] = prefixZeroes[i] + (servers.charAt(i) == '0' ? 1 : 0);
            }
            // Total number of '1's in the entire string
            int totalOnes = prefixOnes[n];
            int minCost = Integer.MAX_VALUE;
            // Try every subarray [L, R) as the portion we keep
            // We remove [0..L) from the front and [R..n) from the end
            for (int L = 0; L <= n; L++) {
                for (int R = L; R <= n; R++) {
                    // Number of 0s in [L, R) = prefixZeroes[R] - prefixZeroes[L]
                    int zeroesInSubarray = prefixZeroes[R] - prefixZeroes[L];
                    // Number of 1s in [L, R) = prefixOnes[R] - prefixOnes[L]
                    int onesInSubarray = prefixOnes[R] - prefixOnes[L];
                    // # of 1s removed = totalOnes - onesInSubarray
                    // # of 0s remaining = zeroesInSubarray
                    int cost = Math.max(zeroesInSubarray, totalOnes - onesInSubarray);
                    if (cost < minCost) {
                        minCost = cost;
                    }
                }
            }
            System.out.println(minCost);
        }
        scanner.close();
    }
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055683
1390055672,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;
long long solve(vector<int>&arr, int i, int skip, int inc,vector<vector<long long>>&dp) {
    int n = arr.size();
    if(i==n){
        return 0;
    }
    if(dp[i][skip]!=-1)return dp[i][skip];
    //skip
    long long ans = INT_MAX;
    if(skip>0) {
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
    }
    //no skip
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc,dp));
    return dp[i][skip]= ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--) {
        int n,skip;
        cin>>n>>skip;
        vector<int>arr;
        vector<vector<long long>>dp(n,vector<long long>(skip+1,-1));
        while(n--) {
            int a;
            cin>>a;
            arr.push_back(a);
        }
        cout<<solve(arr,0,skip,0,dp)<<endl;
    }
    return 0;
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055672
1390055674,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055674
1390055662,unknown,unknown,unknown,"def min_cost(s):
    total_ones = s.count('1')
    n = len(s)
    # If no '1' exists, remove all (cost = 0)
    if total_ones == 0:
        return 0  
    scenario_empty = total_ones  # Cost if we remove all ones
    # Scenario 1: Try keeping a window of maximum '1's
    scenario1_cost = float('inf')
    max_ones_in_window = 0
    L = min(total_ones, n)
    for l in range(1, L + 1):  # Window size
        current_ones = sum(1 for c in s[:l] if c == '1')
        max_ones_in_window = max(max_ones_in_window, current_ones)
        for i in range(1, n - l + 1):
            current_ones -= (s[i - 1] == '1')
            current_ones += (s[i + l - 1] == '1')
            max_ones_in_window = max(max_ones_in_window, current_ones)
    scenario1_cost = total_ones - max_ones_in_window
    # Scenario 2: Try minimizing zeros left after removing 1s from both ends
    scenario2_cost = float('inf')
    min_zeros = float('inf')
    if n > total_ones:
        for l in range(total_ones + 1, n + 1):
            current_zeros = sum(1 for c in s[:l] if c == '0')
            min_zeros = min(min_zeros, current_zeros)
            for i in range(1, n - l + 1):
                current_zeros -= (s[i - 1] == '0')
                current_zeros += (s[i + l - 1] == '0')
                min_zeros = min(min_zeros, current_zeros)
        scenario2_cost = min_zeros
    candidates = [scenario1_cost, scenario_empty]
    if n > total_ones:
        candidates.append(scenario2_cost)
    return min(candidates)
# Read input
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055662
1390055667,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055667
1390055669,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055669
1390055661,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} 3rd",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055661
1390055654,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055654
1390055656,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055656
1390055655,unknown,unknown,unknown,"t = int(input())
dlist = [1,1,1,1,11,1,1,11,1,1,1,1] * 100
def unn_traversal():
    total = 0
    for x in dlist:
        total += x % 7
    return total % 13
for _ in range(t):
    s = input().strip()
    n = len(s)
    total_ones = s.count('1')
    max_consecutive_ones = max((len(run) for run in s.split('0')), default=0)
    if total_ones == 0 or max_consecutive_ones == total_ones:
        print(0)
        continue
    total_zeros = n - total_ones
    low = 0
    high = max(total_ones, total_zeros)
    answer = high
    while low <= high:
        mid = (low + high) // 2
        required_ones = max(0, total_ones - mid)
        if required_ones == 0:
            answer = mid
            high = mid - 1
            continue
        left = 0
        zeros = 0
        max_ones = 0
        for right in range(n):
            if s[right] == '0':
                zeros += 1
            while zeros > mid:
                if s[left] == '0':
                    zeros -= 1
                left += 1
            current_ones = (right - left + 1) - zeros
            max_ones = max(max_ones, current_ones)
        d = unn_traversal()
        max_ones += d - d
        if max_ones >= required_ones:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    print(answer)",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055655
1390055645,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055645
1390055648,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for (int testCase = 0; testCase < t; testCase++) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextInt();
            }
            System.out.println(minimumEffort(strengths, k));
        }
        scanner.close();
    }
    public static long minimumEffort(int[] strengths, int k) {
        int n = strengths.length;
        if (k >= n) {
            return 0;
        }
        long[] dp = new long[k + 1];
        Arrays.fill(dp, Long.MAX_VALUE / 2);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            long[] newDp = new long[k + 1];
            Arrays.fill(newDp, Long.MAX_VALUE / 2);
            for (int j = 0; j <= k; j++) {
                if (j == 0) {
                    newDp[0] = dp[0] + strengths[i];
                } else {
                    newDp[j] = dp[j] + strengths[i] + j;
                }
                if (j > 0) {
                    newDp[j] = Math.min(newDp[j], dp[j - 1]);
                }
            }
            dp = newDp;
        }
        long minEffort = dp[0];
        for (int j = 1; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[j]);
        }
        return minEffort;
    }
}",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055648
1390055650,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    total_effort = sum(a)  # Effort without skipping
    min_effort = total_effort
    for i in range(n):
        if k > 0:  # We can skip at most k firewalls
            effort = total_effort - a[i]  # Skip current firewall
            effort += (n - i - 1)  # Remaining firewalls get incremented
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055650
1390055642,unknown,unknown,unknown,"def earliest_faults(arr, k):
    result = []
    first_fault = 0  # Default if no faults in batch
    for i in range(len(arr) - k + 1):  # Iterate through batches
        batch = arr[i:i + k]
        first_fault = 0  # Reset for each batch
        for num in batch:  # Find first faulty reading
            if num < 0:
                first_fault = num
                break
        result.append(first_fault)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    # Get the result and print it
    print(*earliest_faults(arr, k))",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055642
1390055643,unknown,unknown,unknown,"def main():
    import sys
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        gains = []
        for i in range(n):
            g = a[i] - (n - i - 1)
            gains.append(g)
        gains.sort(reverse=True)
        selected = gains[:k]
        sum_gain = sum(selected)
        sum_gain += k * (k - 1) // 2
        minimal_effort = sum_a - sum_gain
        print(minimal_effort)
if __name__ == ""__main__"":
    main()",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055643
1390055644,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055644
1390055641,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055641
1390055635,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055635
1390055639,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055639
1390055637,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>
using namespace std;
using ll = long long;
ll min_effort(int n, int k, const vector<int>& firewalls) {
    if (n == 0) return 0;
    vector<vector<ll>> dp(n + 1, vector<ll>(k + 1, LLONG_MAX));
    dp[0][0] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            // Case 1: Do not skip the i-th firewall
            if (dp[i-1][j] != LLONG_MAX) {
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
            }
            // Case 2: Skip the i-th firewall if possible
            if (j > 0 && dp[i-1][j-1] != LLONG_MAX) {
                dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
            }
        }
    }
    return *min_element(dp[n].begin(), dp[n].end());
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; ++i) {
            cin >> firewalls[i];
        }
        cout << min_effort(n, k, firewalls) << '\n';
    }
    return 0;
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055637
1390055630,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class BreachFirewall {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int T = Integer.parseInt(st.nextToken()); // Number of test cases
        StringBuilder result = new StringBuilder();
        while (T-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            int[] firewalls = new int[n];
            st = new StringTokenizer(br.readLine());
            int totalEffort = 0;
            for (int i = 0; i < n; i++) {
                firewalls[i] = Integer.parseInt(st.nextToken());
                totalEffort += firewalls[i]; // Calculate total sum
            }
            List<Integer> modifiedValues = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                modifiedValues.add(firewalls[i] - (n - i - 1)); // Transform the array
            }
            // Sort in descending order
            modifiedValues.sort(Collections.reverseOrder());
            // Compute prefix sum for best `t` firewalls to skip
            int[] prefixSum = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixSum[i + 1] = prefixSum[i] + modifiedValues.get(i);
            }
            int maxSum = 0;
            int maxT = Math.min(k, n);
            for (int t = 0; t <= maxT; t++) {
                int current = prefixSum[t] + (t * (t - 1)) / 2;
                maxSum = Math.max(maxSum, current);
            }
            result.append(totalEffort - maxSum).append(""\n"");
        }
        System.out.print(result);
    }
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055630
1390055632,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055632
1390055633,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055633
1390055623,unknown,unknown,unknown,"import sys
def min_opp():
    test_cases = int(sys.stdin.readline().strip())
    for _ in range(test_cases):
        bin_stri =sys.stdin.readline().strip()
        ones_positions =[i for i, ch in enumerate(bin_stri) if ch == '1']
        total1 = len(ones_positions)
        if total1 == 0 or ones_positions[-1]-ones_positions[0] == total1-1:
            print(0)
            continue
        baye, daye = -1, total1
        while daye - baye > 1:
            mid = (baye + daye) // 2
            ones_needed = total1 - mid
            for i in range(total1 - ones_needed + 1):
                start, end = ones_positions[i], ones_positions[i + ones_needed - 1]
                if (end - start + 1) - ones_needed <= mid:
                    daye = mid
                    break
            else:
                baye = mid
        print(daye)
if __name__ == ""__main__"":
    min_opp()",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055623
1390055626,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        impact = [(strengths[i] + i, i) for i in range(n)]
        impact.sort(reverse=True)
        to_skip = set(idx for _, idx in impact[:k])
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055626
1390055627,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
int minDecommissionCost(const char* servers) {
    int n = strlen(servers);
    int minCost = __INT_MAX__;
    // Precompute prefix sums for active and idle servers
    int* activePrefix = (int*)malloc((n + 1) * sizeof(int));
    int* idlePrefix = (int*)malloc((n + 1) * sizeof(int));
    activePrefix[0] = 0;
    idlePrefix[0] = 0;
    for (int i = 0; i < n; i++) {
        activePrefix[i + 1] = activePrefix[i] + (servers[i] == '1' ? 1 : 0);
        idlePrefix[i + 1] = idlePrefix[i] + (servers[i] == '0' ? 1 : 0);
    }
    int totalActive = activePrefix[n];
    int totalIdle = idlePrefix[n];
    // Try all combinations of prefix and suffix removals
    for (int left = 0; left <= n; left++) {  // Left cut position (inclusive)
        for (int right = left; right <= n; right++) {  // Right cut position (exclusive)
            // Skip empty remaining segment
            if (left == right) {
                continue;
            }
            // Calculate metrics
            int activeRemoved = activePrefix[left] + (totalActive - activePrefix[right]);
            int idleRemaining = idlePrefix[right] - idlePrefix[left];
            int cost = MAX(activeRemoved, idleRemaining);
            minCost = MIN(minCost, cost);
        }
    }
    free(activePrefix);
    free(idlePrefix);
    return minCost;
}
int main() {
    int t;
    scanf(""%d"", &t);  // Number of test cases
    for (int i = 0; i < t; i++) {
        char servers[100001];  // Assuming max length constraint
        scanf(""%s"", servers);
        printf(""%d\n"", minDecommissionCost(servers));
    }
    return 0;
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055627
1390055617,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def min_flips_to_make_ones_consecutive(s):
    n = len(s)
    total_ones = s.count('1')
    if total_ones == 0 or '1' * total_ones in s:
        return 0
    total_zeros = n - total_ones
    max_consecutive_ones = max(map(len, s.split('0')))
    low, high = 0, max(total_ones, total_zeros)
    answer = high
    while low <= high:
        mid = (low + high) // 2
        required_ones = max(0, total_ones - mid)
        if required_ones == 0:
            answer = mid
            high = mid - 1
            continue
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
        if max_ones >= required_ones:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
# Input handling
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_flips_to_make_ones_consecutive(s))",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055617
1390055614,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)
            # Option 2: Skip the current firewall (if possible)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    min_effort = float('inf')
    for j in range(k + 1):
        min_effort = min(min_effort, dp[n][j])
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055614
1390055612,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":
    main()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055612
1390055615,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055615
1390055605,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int cases;
    cin >> cases;
    while (cases--) {
        int n, k;
        cin >> n >> k;
        vector<int> array(n);
        for (int i = 0; i < n; i++) {
            cin >> array[i];
        }
        for (int i = 0; i <= n - k; i++) {
            int neg = 0;
            for (int j = i; j < i + k; j++) {
                if (array[j] < 0) {
                    neg = array[j];
                    break;
                }
            }
            cout << neg << "" "";
        }
        cout << endl;
    }
    return 0;
}",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055605
1390055607,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommissioning {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // Number of test cases
        scanner.nextLine(); // Consume the newline character
        for (int t = 0; t < T; t++) {
            String servers = scanner.nextLine(); // Binary string representing the server rack
            int n = servers.length();
            int minCost = Integer.MAX_VALUE;
            // Precompute prefix sums for 0's and 1's
            int[] prefixZeros = new int[n + 1];
            int[] prefixOnes = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
                prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
            }
            // Iterate over all possible decommissioning plans
            for (int left = 0; left <= n; left++) {
                for (int right = 0; right <= n - left; right++) {
                    // Calculate remaining 0's in the middle substring
                    int remainingZeros = prefixZeros[n - right] - prefixZeros[left];
                    // Calculate decommissioned 1's (from left and right)
                    int decommissionedOnes = prefixOnes[left] + (prefixOnes[n] - prefixOnes[n - right]);
                    // Compute the cost
                    int cost = Math.max(remainingZeros, decommissionedOnes);
                    // Update the minimum cost
                    if (cost < minCost) {
                        minCost = cost;
                    }
                }
            }
            System.out.println(minCost);
        }
        scanner.close();
    }
}",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055607
1390055609,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
}",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055609
1390055603,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    if k == n:
        return 0  # If we can skip all firewalls, effort is 0.
    min_extra_cost = min(firewalls)  # Find the least firewall strength to skip
    return total_effort - min_extra_cost  # Minimum effort after skipping one firewall.
# Reading input
T = int(input().strip())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055603
1390055604,unknown,unknown,unknown,"def minimize_decommission_cost(test_cases):
    results = []
    for binary_string in test_cases:
        n = len(binary_string)
        total_idle = binary_string.count('0') 
        total_active = binary_string.count('1')  
        min_cost = float('inf')  
        for start in range(n + 1):  
            for end in range(n - start + 1):  
                remaining = binary_string[start:n - end]
                remaining_idle = remaining.count('0')
                decommissioned_active = total_active - remaining.count('1')
                cost = max(remaining_idle, decommissioned_active)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
results = minimize_decommission_cost(test_cases)
for result in results:
    print(result)",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055604
1390055598,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
int minDecommissionCost(const char* servers) {
    int n = strlen(servers);
    int minCost = __INT_MAX__;
    // Precompute prefix sums for active and idle servers
    int* activePrefix = (int*)malloc((n + 1) * sizeof(int));
    int* idlePrefix = (int*)malloc((n + 1) * sizeof(int));
    activePrefix[0] = 0;
    idlePrefix[0] = 0;
    for (int i = 0; i < n; i++) {
        activePrefix[i + 1] = activePrefix[i] + (servers[i] == '1' ? 1 : 0);
        idlePrefix[i + 1] = idlePrefix[i] + (servers[i] == '0' ? 1 : 0);
    }
    int totalActive = activePrefix[n];
    int totalIdle = idlePrefix[n];
    // Try all combinations of prefix and suffix removals
    for (int left = 0; left <= n; left++) {  // Left cut position (inclusive)
        for (int right = left; right <= n; right++) {  // Right cut position (exclusive)
            // Skip empty remaining segment
            if (left == right) {
                continue;
            }
            // Calculate metrics
            int activeRemoved = activePrefix[left] + (totalActive - activePrefix[right]);
            int idleRemaining = idlePrefix[right] - idlePrefix[left];
            int cost = MAX(activeRemoved, idleRemaining);
            minCost = MIN(minCost, cost);
        }
    }
    free(activePrefix);
    free(idlePrefix);
    return minCost;
}
int main() {
    int t;
    scanf(""%d"", &t);  // Number of test cases
    for (int i = 0; i < t; i++) {
        char servers[100001];  // Assuming max length constraint
        scanf(""%s"", servers);
        printf(""%d\n"", minDecommissionCost(servers));
    }
    return 0;
}",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055598
1390055596,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055596
1390055578,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055578
1390055582,unknown,unknown,unknown,"def feasible(X, ones_indices, total1):
    if X >= total1:
        return True
    j = 0
    for i in range(total1):
        if j < i:
            j = i
        while j < total1 and (ones_indices[j] - ones_indices[i] - (j - i)) <= X:
            j += 1
        m = j - i
        if m >= total1 - X:
            return True
    return False
def min_moves_to_make_ones_contiguous(s):
    ones_indices = [i for i, ch in enumerate(s) if ch == '1']
    total1 = len(ones_indices)
    if total1 == 0:
        return 0
    low, high, ans = 0, total1, total1
    while low <= high:
        mid = low + (high - low) // 2
        if feasible(mid, ones_indices, total1):
            ans = mid
            high = mid - 1
        else:
            low = mid + 1
    return ans
if __name__ == ""__main__"":
    T = int(input())
    for _ in range(T):
        s = input().strip()
        print(min_moves_to_make_ones_contiguous(s))",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055582
1390055589,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055589
1390055571,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""_main_"":
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055571
1390055573,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
}",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055573
1390055574,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055574
1390055565,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases): 
    results = []
    for s in test_cases:
        n = len(s)
        prefix_ones = [0] * (n + 1)
        prefix_zeros = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_ones[i] = prefix_ones[i - 1] + (1 if s[i - 1] == '1' else 0)
            prefix_zeros[i] = prefix_zeros[i - 1] + (1 if s[i - 1] == '0' else 0)
        total_ones = prefix_ones[n]
        total_zeros = prefix_zeros[n]
        min_cost = float('inf')
        for i in range(n):
            for j in range(i + 1, n + 1):
                ones_in_subarray = prefix_ones[j] - prefix_ones[i]
                zeros_in_subarray = prefix_zeros[j] - prefix_zeros[i]
                removed_ones = total_ones - ones_in_subarray
                cost = max(zeros_in_subarray, removed_ones)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input())
test_cases = [input().strip() for _ in range(T)]
results = min_decommissioning_cost(test_cases)
for result in results:
    print(result)",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055565
1390055569,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055569
1390055570,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055570
1390055563,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055563
1390055556,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        impact = [(strengths[i] + i, i) for i in range(n)]
        impact.sort(reverse=True)
        to_skip = set(idx for _, idx in impact[:k])
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055556
1390055559,unknown,unknown,unknown,"def min_cost(server_rack):
    n = len(server_rack)
    total_zeros = server_rack.count('0')  # Total number of 0's in the string
    total_ones = n - total_zeros          # Total number of 1's in the string
    min_cost = float('inf')
    left = 0
    zeros_inside = 0  # Number of 0's in the current window
    for right in range(n):
        if server_rack[right] == '0':
            zeros_inside += 1
        # Calculate the number of 1's outside the window
        ones_outside = total_ones - (right - left + 1 - zeros_inside)
        # Calculate the cost
        cost = max(zeros_inside, ones_outside)
        # Update the minimum cost
        if cost < min_cost:
            min_cost = cost
        # Shrink the window from the left to try to find a better cost
        while left <= right and cost >= min_cost:
            if server_rack[left] == '0':
                zeros_inside -= 1
            left += 1
            # Recalculate cost after shrinking the window
            ones_outside = total_ones - (right - left + 1 - zeros_inside)
            cost = max(zeros_inside, ones_outside)
            # Update the minimum cost
            if cost < min_cost:
                min_cost = cost
    return min_cost
# Read the number of test cases
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(min_cost(server_rack))",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055559
1390055560,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def min_flips_to_make_ones_consecutive(s):
    n = len(s)
    total_ones = s.count('1')
    if total_ones == 0 or '1' * total_ones in s:
        return 0
    total_zeros = n - total_ones
    max_consecutive_ones = max(map(len, s.split('0')))
    low, high = 0, max(total_ones, total_zeros)
    answer = high
    while low <= high:
        mid = (low + high) // 2
        required_ones = max(0, total_ones - mid)
        if required_ones == 0:
            answer = mid
            high = mid - 1
            continue
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
        if max_ones >= required_ones:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
# Input handling
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_flips_to_make_ones_consecutive(s))",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055560
1390055549,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()
    ",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055549
1390055550,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if _name_ == ""_main_"":
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055550
1390055552,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055552
1390055545,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    benefits = []
    for i in range(n):
        benefit = strengths[i] - (n - i - 1)
        benefits.append((benefit, i))
    benefits.sort(reverse=True)
    to_skip = set(pos for _, pos in benefits[:k])
    total_effort = 0
    skipped_till_now = 0
    for i in range(n):
        if i in to_skip:
            skipped_till_now += 1
        else:
            total_effort += strengths[i] + skipped_till_now
    print(total_effort)",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055545
1390055548,unknown,unknown,unknown,"def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        sumA = sum(a)
        b = [a[i] + (i + 1) for i in range(n)]
        b.sort(reverse=True)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + b[i]
        min_cost = float('inf')
        for x in range(0, min(k, n) + 1):
            cost = sumA + x * n - (x * (x - 1)) // 2 - prefix[x]
            min_cost = min(min_cost, cost)
        print(min_cost)
solve()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055548
1390055544,unknown,unknown,unknown,"import sys
def main():
    # Read number of test cases
    T = int(input())
    for _ in range(T):
        # Read the binary string
        S = input().strip()
        n = len(S)
        # Compute prefix sums for '0's and '1's
        prefix_zeros = [0] * (n + 1)
        prefix_ones = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_zeros[i] = prefix_zeros[i - 1] + (S[i - 1] == '0')
            prefix_ones[i] = prefix_ones[i - 1] + (S[i - 1] == '1')
        # Initialize minimum cost
        min_cost = float('inf')
        # Iterate over all possible end indices j
        for j in range(n + 1):
            # Number of '1's in the suffix from j to n
            C = prefix_ones[n] - prefix_ones[j]
            # Binary search to find the smallest m where:
            # Number of '0's in [m, j-1] <= Number of '1's in [0, m-1] + [j, n-1]
            left, right = 0, j
            while left < right:
                mid = left + (right - left) // 2
                if prefix_zeros[j] - prefix_zeros[mid] <= prefix_ones[mid] + C:
                    right = mid
                else:
                    left = mid + 1
            m = left
            # Compute cost based on the optimal m
            if m == 0:
                # If m is 0, no prefix is removed, cost is just '1's in suffix
                cost = C
            else:
                # Cost is min of '0's in [m-1, j-1] and '1's in [0, m-1] + [j, n-1]
                cost = min(prefix_zeros[j] - prefix_zeros[m - 1], prefix_ones[m] + C)
            min_cost = min(min_cost, cost)
        # Output the minimum cost for this test case
        print(min_cost)
if __name__ == ""__main__"":
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055544
1390055537,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055537
1390055533,unknown,unknown,unknown,"def min_server_pruning_cost(binary_string):
    # Find the first and last occurrence of '1'
    first_one = binary_string.find('1')
    last_one = binary_string.rfind('1')
    if first_one == -1:  # If there are no '1s', we can remove everything
        return 0
    # Trim the string to only the relevant section
    trimmed_string = binary_string[first_one:last_one + 1]
    # Count idle servers (0s) remaining and active servers (1s) removed
    remaining_idle_servers = trimmed_string.count('0')
    removed_active_servers = first_one + (len(binary_string) - 1 - last_one)
    # Return the minimum possible cost
    return max(remaining_idle_servers, removed_active_servers)
def solve():
    t = int(input().strip())  # Number of test cases
    results = []
    for _ in range(t):
        binary_string = input().strip()
        results.append(str(min_server_pruning_cost(binary_string)))
    # Print all results for test cases
    print(""\n"".join(results))
# Execute the solution
if _name_ == ""_main_"":
    solve()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055533
1390055534,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055534
1390055535,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [int(c) for c in servers]
    # Compute prefix sum of active servers (1s)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]  # Total active servers
    min_cost = total_ones  # Worst case: decommission all active servers
    j = 0  # Right boundary of the window
    for i in range(n + 1):
        # Move j to maintain segment_zeros >= total_ones_removed
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
            j += 1
        # Calculate cost at current window
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
        left_ones = prefix_sum[i]
        right_ones = total_ones - prefix_sum[j - 1]
        cost = max(segment_zeros, left_ones + right_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    results = []
    for i in range(1, t + 1):
        results.append(str(minimum_decommission_cost(data[i])))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    process_input()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055535
1390055529,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    if k >= n:
        return 0
    min_effort = float('inf')
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  
    for i in range(1, n + 1):
        current_firewall = firewalls[i - 1]
        for j in range(k + 1):
            if j <= i - 1:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_firewall + j)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n][j] for j in range(k + 1))
def solve_test_cases():
    T = int(input().strip())
    results = []
    for _ in range(T):
        n, k = map(int, input().strip().split())
        firewalls = list(map(int, input().strip().split()))
        results.append(min_effort_to_breach(n, k, firewalls))
    return results
if __name__ == ""__main__"":
    results = solve_test_cases()
    for result in results:
        print(result)",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055529
1390055530,unknown,unknown,unknown,"import sys
def findMinCost():
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    ans = []
    for _ in range(t):
        servers = input_data[line].strip()
        line += 1
        n = len(servers)
        active_positions = [i for i, ch in enumerate(servers) if ch == '1']
        active_count = len(active_positions)
        if active_count == 0:
            ans.append(""0"")
            continue
        offset_positions = [active_positions[i] - i for i in range(active_count)]
        def check(limit):
            if active_count - limit <= 0:
                return True
            j = 0
            for i in range(active_count):
                if j < i:
                    j = i
                while j < active_count and offset_positions[j] - offset_positions[i] <= limit:
                    j += 1
                if j - i >= active_count - limit:
                    return True
            return False
        lo, hi, min_cost = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                min_cost = mid
                hi = mid - 1
            else:
                lo = mid + 1
        ans.append(str(min_cost))
    sys.stdout.write(""\n"".join(ans))
if __name__ == ""__main__"":
    findMinCost()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055530
1390055531,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<bits/stdc++.h>
using namespace std;
int solve(vector<int>& arr, int k){
    int n = arr.size();
    int ans = 0;
    set<int> st;
    vector<int> right(n,0);
    for(int i=0; i<n; i++) right[i]=n-i-1;
    priority_queue<pair<int,int>, vector<pair<int,int>>> pq;
    for(int i=0; i<n; i++) pq.push({arr[i],i});
    while(!pq.empty()){
        auto [val,idx] = pq.top(); pq.pop();
        if(right[idx] < val && k){
            val=n-idx-1;
            st.insert(idx);
            k--;
            for(int i=0; i<idx; i++){
                right[i]--;
            }
            // cout<<""inserted ""<<idx<<"" k:""<<k<<"" "";
        }    
    }
    // for(int i=0; i<n; i++) cout<<right[i]<<"" "";
    int val=0, count=0; //count of k that is used.. val is no of -1 to be added
    for(int i=0; i<n; i++){
        if(st.find(i)!=st.end()){
            if(count) val-=count;
            val += n-i-1;
            count++;
            continue;
        }
        ans += arr[i];
    }
    ans += val;
    return ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
    int t;
    cin>>t;
    while(t--){
        int n,k;
        cin>>n>>k;
        vector<int> arr(n);
        for(int i=0; i<n ;i++) cin>>arr[i];
        int ans = solve(arr,k);
        cout<<ans<<endl;
    }
    return 0;
}",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055531
1390055526,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j 
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055526
1390055527,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for (int testCase = 0; testCase < t; testCase++) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextInt();
            }
            System.out.println(minimumEffort(strengths, k));
        }
        scanner.close();
    }
    public static long minimumEffort(int[] strengths, int k) {
        int n = strengths.length;
        if (k >= n) {
            return 0;
        }
        long[][] dp = new long[n + 1][k + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i][j] = Long.MAX_VALUE / 2;
            }
        }
        dp[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            int currentStrength = strengths[i - 1];
            for (int j = 0; j <= k; j++) {
                if (dp[i - 1][j] != Long.MAX_VALUE / 2) {
                    dp[i][j] = dp[i - 1][j] + currentStrength + j;
                }
            }
            for (int j = 1; j <= k; j++) {
                if (dp[i - 1][j - 1] != Long.MAX_VALUE / 2) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        long minEffort = Long.MAX_VALUE;
        for (int j = 0; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[n][j]);
        }
        return minEffort;
    }
}",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055527
1390055523,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055523
1390055517,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def min_flips_to_make_ones_consecutive(s):
    n = len(s)
    total_ones = s.count('1')
    if total_ones == 0 or '1' * total_ones in s:
        return 0
    total_zeros = n - total_ones
    max_consecutive_ones = max(map(len, s.split('0')))
    low, high = 0, max(total_ones, total_zeros)
    answer = high
    while low <= high:
        mid = (low + high) // 2
        required_ones = max(0, total_ones - mid)
        if required_ones == 0:
            answer = mid
            high = mid - 1
            continue
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
        if max_ones >= required_ones:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
# Input handling
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_flips_to_make_ones_consecutive(s))",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055517
1390055501,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int maxOnesWithAtMostKZeros(const string& s, int k) {
    int left = 0;
    int zeros = 0;
    int maxOnes = 0;
    int n = s.length();
    for (int right = 0; right < n; right++) {
        if (s[right] == '0') {
            zeros++;
        }
        while (zeros > k) {
            if (s[left] == '0') {
                zeros--;
            }
            left++;
        }
        int currentOnes = (right - left + 1) - zeros;
        maxOnes = max(maxOnes, currentOnes);
    }
    return maxOnes;
}
int main() {
    int T;
    cin >> T;
    cin.ignore();
    while (T--) {
        string s;
        getline(cin, s);
        int n = s.length();
        int totalOnes = 0;
        int maxConsecutiveOnes = 0;
        int currentConsecutiveOnes = 0;
        for (char c : s) {
            if (c == '1') {
                currentConsecutiveOnes++;
                maxConsecutiveOnes = max(maxConsecutiveOnes, currentConsecutiveOnes);
                totalOnes++;
            } else {
                currentConsecutiveOnes = 0;
            }
        }
        if (totalOnes == 0) {
            cout << 0 << endl;
            continue;
        }
        if (maxConsecutiveOnes == totalOnes) {
            cout << 0 << endl;
            continue;
        }
        int totalZeros = n - totalOnes;
        int low = 0;
        int high = max(totalOnes, totalZeros);
        int answer = high;
        while (low <= high) {
            int mid = (low + high) / 2;
            int requiredOnes = max(0, totalOnes - mid);
            if (requiredOnes == 0) {
                answer = mid;
                high = mid - 1;
                continue;
            }
            int maxOnes = maxOnesWithAtMostKZeros(s, mid);
            if (maxOnes >= requiredOnes) {
                answer = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << answer << endl;
    }
    return 0;
}",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055501
1390055508,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)
            # Option 2: Skip the current firewall (if possible)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    min_effort = float('inf')
    for j in range(k + 1):
        min_effort = min(min_effort, dp[n][j])
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055508
1390055512,unknown,unknown,unknown,"import java.util.*;
import java.io.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        for (int t = 0; t < T; t++) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextLong();
            }
            final long INF = 1_000_000_000_000_000_000L;
            long[] prev = new long[k + 1];
            Arrays.fill(prev, INF);
            prev[0] = 0;
            for (int i = 0; i < n; i++) {
                long[] curr = new long[k + 1];
                Arrays.fill(curr, INF);
                for (int s = 0; s <= k; s++) {
                    curr[s] = prev[s] + a[i] + s;
                    if (s > 0) {
                        curr[s] = Math.min(curr[s], prev[s - 1]);
                    }
                }
                prev = curr;
            }
            long ans = INF;
            for (int s = 0; s <= k; s++) {
                ans = Math.min(ans, prev[s]);
            }
            System.out.println(ans);
        }
        scanner.close();
    }
}",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055512
1390055495,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055495
1390055499,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055499
1390055500,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommission {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();  // Number of test cases
        scanner.nextLine();         // Consume the leftover newline
        while (T-- > 0) {
            String servers = scanner.nextLine();
            int n = servers.length();
            // Build prefix sums for '1's and '0's
            // prefixOnes[i] = number of '1's in servers[0..i-1]
            // prefixZeroes[i] = number of '0's in servers[0..i-1]
            int[] prefixOnes = new int[n + 1];
            int[] prefixZeroes = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
                prefixZeroes[i + 1] = prefixZeroes[i] + (servers.charAt(i) == '0' ? 1 : 0);
            }
            // Total number of '1's in the entire string
            int totalOnes = prefixOnes[n];
            int minCost = Integer.MAX_VALUE;
            // Try every subarray [L, R) as the portion we keep
            // We remove [0..L) from the front and [R..n) from the end
            for (int L = 0; L <= n; L++) {
                for (int R = L; R <= n; R++) {
                    // Number of 0s in [L, R) = prefixZeroes[R] - prefixZeroes[L]
                    int zeroesInSubarray = prefixZeroes[R] - prefixZeroes[L];
                    // Number of 1s in [L, R) = prefixOnes[R] - prefixOnes[L]
                    int onesInSubarray = prefixOnes[R] - prefixOnes[L];
                    // # of 1s removed = totalOnes - onesInSubarray
                    // # of 0s remaining = zeroesInSubarray
                    int cost = Math.max(zeroesInSubarray, totalOnes - onesInSubarray);
                    if (cost < minCost) {
                        minCost = cost;
                    }
                }
            }
            System.out.println(minCost);
        }
        scanner.close();
    }
}",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055500
1390055486,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerOptimization {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            String s = sc.next();
            int n = s.length();
            if (n == 0 || !s.contains(""1"")) {
                System.out.println(0);
                continue;
            }
            int minCost = Integer.MAX_VALUE;
            for (int start = 0; start < n; start++) {
                for (int end = start; end < n; end++) {
                    int zerosRemaining = 0;
                    int onesRemoved = 0;
                    for (int i = start; i <= end; i++) {
                        if (s.charAt(i) == '0') {
                            zerosRemaining++;
                        }
                    }
                    for (int i = 0; i < start; i++) {
                        if (s.charAt(i) == '1') {
                            onesRemoved++;
                        }
                    }
                    for (int i = end + 1; i < n; i++) {
                        if (s.charAt(i) == '1') {
                            onesRemoved++;
                        }
                    }
                    int cost = Math.max(zerosRemaining, onesRemoved);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055486
1390055489,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":
    main()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055489
1390055490,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    ptr = 0
    T = int(input[ptr])
    ptr += 1
    for _ in range(T):
        n, k = map(int, input[ptr:ptr+2])
        ptr += 2
        a = list(map(int, input[ptr:ptr+n]))
        ptr += n
        sum_a = sum(a)
        values = [a[i] + (i + 1) for i in range(n)]
        values.sort(reverse=True)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + values[i]
        max_gain = 0
        max_m = min(k, n)
        for m in range(0, max_m + 1):
            current = prefix[m] - m * n + (m * (m - 1)) // 2
            if current > max_gain:
                max_gain = current
        print(sum_a - max_gain)
if __name__ == ""__main__"":
    main()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055490
1390055484,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if _name_ == ""_main_"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055484
1390055475,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>(); // Store indices of negative numbers
        for (int i = 0; i < arr.length; i++) {
            // Remove elements that are out of this window
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add current element if it's negative
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // If we have processed at least k elements, record the earliest fault
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        // Print the result
        for (int num : result) {
            System.out.print(num + "" "");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Size of array
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            findEarliestFaults(arr, k);
        }
        scanner.close();
    }
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055475
1390055480,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // i/o
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i hehe
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055480
1390055481,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int reading = sc.nextInt();
        StringBuilder result = new StringBuilder();
        while(reading --> 0){
            int n = sc.nextInt();
            int k = sc.nextInt();
            int arr[] = new int[n];
            for(int i = 0; i < n; i++){
                arr[i] = sc.nextInt();
            }
            for(int i = 0; i <= n - k; i++){
                int faulty = 0;
                for(int j = i; j < i+k; j++){
                    if(arr[j] < 0) {
                        faulty = arr[j];
                        break;
                    }
                }
            result.append(faulty).append("" "");
            }
            result.append(""\n"");
        }
        System.out.print(result.toString().trim());
        sc.close();
    }
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055481
1390055465,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        # Precompute prefix counts for 0s and 1s
        prefix_0, prefix_1 = [0] * (n + 1), [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (servers[i - 1] == '0')
            prefix_1[i] = prefix_1[i - 1] + (servers[i - 1] == '1')
        # Precompute suffix counts for 0s and 1s
        suffix_0, suffix_1 = [0] * (n + 1), [0] * (n + 1)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (servers[n - j] == '0')
            suffix_1[j] = suffix_1[j - 1] + (servers[n - j] == '1')
        min_cost = float('inf')
        # Iterate over all possible prefixes (i)
        for i in range(n + 1):
            j_max = n - i
            left, right = 0, j_max
            best_j, best_cost = 0, float('inf')
            # Binary search for the best j
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_j = mid
                elif current_cost == best_cost and mid < best_j:
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            # Check neighboring j values
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= j_max:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055465
1390055467,unknown,unknown,unknown,"def solve():
    server_rack = input().strip()
    n = len(server_rack)
    # Count total number of '1's
    total_ones = server_rack.count('1')
    min_cost = float('inf')
    left_ones = 0  # Number of '1's removed from the left
    remaining_zeros = server_rack.count('0')  # Number of '0's remaining in the rack
    # Iterate through all possible removal points
    for i in range(n + 1):  
        if i > 0:
            # Update the number of removed ones from left
            left_ones += (server_rack[i - 1] == '1')
        # Compute cost at this point
        cost = max(remaining_zeros, left_ones)
        min_cost = min(min_cost, cost)
        # If we move forward, decrease remaining zeros count (since they are skipped)
        if i < n and server_rack[i] == '0':
            remaining_zeros -= 1
    print(min_cost)
# Read number of test cases
T = int(input().strip())
for _ in range(T):
    solve()",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055467
1390055464,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055464
1390055457,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        firewalls.sort() 
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + firewalls[i - 1]  
        min_effort = float('inf')
        for x in range(k + 1):
            remaining_firewalls = n - x
            if remaining_firewalls == 0:
                min_effort = 0 
                break
            cost = prefix_sum[remaining_firewalls]+x
            min_effort = min(min_effort, cost)
        results.append(min_effort)
    return results
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
for result in min_effort_to_breach(T, test_cases):
    print(result)",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055457
1390055455,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055455
1390055459,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055459
1390055453,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055453
1390055446,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055446
1390055449,unknown,unknown,unknown,"def min_cost(server_rack):
    n = len(server_rack)
    total_zeros = server_rack.count('0')
    total_ones = n - total_zeros
    min_cost = float('inf')
    left = 0
    current_zeros = 0
    for right in range(n):
        if server_rack[right] == '0':
            current_zeros += 1
        zeros_remaining = current_zeros
        ones_removed = total_ones - (right - left + 1 - current_zeros)
        cost = max(zeros_remaining, ones_removed)
        if cost < min_cost:
            min_cost = cost
        while left <= right and cost > min_cost:
            if server_rack[left] == '0':
                current_zeros -= 1
            left += 1
            zeros_remaining = current_zeros
            ones_removed = total_ones - (right - left + 1 - current_zeros)
            cost = max(zeros_remaining, ones_removed)
            if cost < min_cost:
                min_cost = cost
    return min_cost
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(min_cost(server_rack))",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055449
1390055450,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if _name_ == ""_main_"":
    main()",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055450
1390055442,unknown,unknown,unknown,"        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055442
1390055443,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055443
1390055444,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            System.out.println(minEffort(n, k, a));
        }
        sc.close();
    }
    static long minEffort(int n, int k, int[] a) {
        long[] curr = new long[k + 1];
        long[] next = new long[k + 1];
        Arrays.fill(curr, Long.MAX_VALUE);
        Arrays.fill(next, Long.MAX_VALUE);
        Arrays.fill(next, 0);
        for (int i = n - 1; i >= 0; i--) {
            for (int skip = 0; skip <= k; skip++) {
                long takeEffort = a[i] + skip;
                if (i < n - 1) {
                    takeEffort += next[skip];
                }
                long skipEffort = Long.MAX_VALUE;
                if (skip < k) {
                    skipEffort = next[skip + 1];
                }
                curr[skip] = Math.min(takeEffort, skipEffort);
            }
            long[] temp = next;
            next = curr;
            curr = temp;
        }
        return next[0];
    }
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055444
1390055439,unknown,unknown,unknown,"def min_decommissioning_cost(rack):
    n = len(rack)
    prefix_zeros = [0] * (n + 1)
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if rack[i] == '0' else 0)
        prefix_ones[i+1] = prefix_ones[i] + (1 if rack[i] == '1' else 0)
    total_zeros = prefix_zeros[n]
    total_ones = prefix_ones[n]
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i):
            if i + j == n:
                continue
            zeros_removed_start = prefix_zeros[i]
            ones_removed_start = prefix_ones[i]
            zeros_removed_end = total_zeros - prefix_zeros[n-j]
            ones_removed_end = total_ones - prefix_ones[n-j]
            remaining_zeros = total_zeros - zeros_removed_start - zeros_removed_end
            removed_ones = ones_removed_start + ones_removed_end
            cost = max(remaining_zeros, removed_ones)
            min_cost = min(min_cost, cost)
    return min_cost
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        rack = input().strip()
        result = min_decommissioning_cost(rack)
        results.append(result)
    return results
if __name__ == ""__main__"":
    results = solve_test_cases()
    for result in results:
        print(result)",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055439
1390055441,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommission {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // Number of test cases
        scanner.nextLine(); // Consume the newline after the integer input
        while (T-- > 0) {
            String servers = scanner.nextLine();
            int n = servers.length();
            // Total count of 1s and 0s in the entire string
            int totalOnes = 0;
            int[] onesPrefixSum = new int[n+1]; // Prefix sum array for ones
            for (int i = 0; i < n; i++) {
                totalOnes += servers.charAt(i) == '1' ? 1 : 0;
                onesPrefixSum[i+1] = onesPrefixSum[i] + (servers.charAt(i) == '1' ? 1 : 0);
            }
            int minCost = Integer.MAX_VALUE;
            // Calculate costs for all subarrays between i and j
            for (int i = 0; i <= n; i++) {
                for (int j = i; j <= n; j++) {
                    int onesRemoved = onesPrefixSum[i] + (totalOnes - onesPrefixSum[j]);
                    int zeroesRemaining = j - i - (onesPrefixSum[j] - onesPrefixSum[i]);
                    int currentCost = Math.max(zeroesRemaining, onesRemoved);
                    minCost = Math.min(minCost, currentCost);
                }
            }
            System.out.println(minCost);
        }
        scanner.close();
    }
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055441
1390055440,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055440
1390055438,unknown,unknown,unknown,"def min_decommission_cost(binary_string):
    left = 0
    right = len(binary_string) - 1
    while left <= right and binary_string[left] == '0':
        left += 1
    while right >= left and binary_string[right] == '0':
        right -= 1
    if left > right:
        return 0
    remaining_zeros = binary_string[left:right+1].count('0')
    removed_ones = binary_string[:left].count('1') + binary_string[right+1:].count('1')
    return max(remaining_zeros, removed_ones)
T = int(input())  
for _ in range(T):
    binary_string = input().strip()
    print(min_decommission_cost(binary_string))",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055438
1390055426,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    s = data[ptr]
    ptr += 1
    n = len(s)
    pre = [0]*(n+1)
    for i in range(n):
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
    O = pre[n]
    best = 10**9
    for L in range(n+1):
        if L <= n - O:
            cost = O - (pre[L+O] - pre[L])
        else:
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
        if cost < best:
            best = cost
    res.append(str(best))
sys.stdout.write(""\n"".join(res))",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055426
1390055430,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055430
1390055437,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // If there are no '1's, the cost is 0
            if (totalOnes == 0 || maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055437
1390055423,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
if _name_ == ""_main_"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055423
1390055425,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":
    main()",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055425
1390055421,unknown,unknown,unknown,"def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        sumA = sum(a)
        b = [a[i] + (i + 1) for i in range(n)]
        b.sort(reverse=True)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + b[i]
        min_cost = float('inf')
        for x in range(0, min(k, n) + 1):
            cost = sumA + x * n - (x * (x - 1)) // 2 - prefix[x]
            min_cost = min(min_cost, cost)
        print(min_cost)
solve()",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055421
1390055415,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    if n==k:
        return 0
    total_effort = sum(firewalls)
    min_effort = total_effort  # Start with no skips
    for i in range(n):
        if k > 0:  # If we can skip at least one firewall
            new_effort = total_effort - firewalls[i]  # Remove the skipped firewall's effort
            new_effort += sum(1 for j in range(i + 1, n))  # Increase remaining firewalls' strength
            min_effort = min(min_effort, new_effort)  # Keep track of the minimum effort
    return min_effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055415
1390055416,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055416
1390055419,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>
using namespace std;
int min_effort(int n, int k, const vector<int>& firewalls) {
    if (n == 0) return 0;
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));
    dp[0][0] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            // Case 1: Do not skip the i-th firewall
            if (dp[i-1][j] != INT_MAX) {
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
            }
            // Case 2: Skip the i-th firewall if possible
            if (j > 0 && dp[i-1][j-1] != INT_MAX) {
                dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
            }
        }
    }
    return *min_element(dp[n].begin(), dp[n].end());
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; ++i) {
            cin >> firewalls[i];
        }
        if (firewalls.size() != n) {
            cout << ""Invalid input\n"";
            return 1;
        }
        cout << min_effort(n, k, firewalls) << '\n';
    }
    return 0;
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055419
1390055413,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine();
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055413
1390055405,unknown,unknown,unknown,"import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    s = data[ptr]
    ptr += 1
    n = len(s)
    pre = [0]*(n+1)
    for i in range(n):
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
    O = pre[n]
    best = 10**9
    for L in range(n+1):
        if L <= n - O:
            cost = O - (pre[L+O] - pre[L])
        else:
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
        if cost < best:
            best = cost
    res.append(str(best))
sys.stdout.write(""\n"".join(res))",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055405
1390055407,unknown,unknown,unknown,"def min_cost(server_rack):
    n = len(server_rack)
    total_zeros = server_rack.count('0')
    total_ones = n - total_zeros
    min_cost = float('inf')
    left = 0
    current_zeros = 0
    for right in range(n):
        if server_rack[right] == '0':
            current_zeros += 1
        zeros_remaining = current_zeros
        ones_removed = total_ones - (right - left + 1 - current_zeros)
        cost = max(zeros_remaining, ones_removed)
        if cost < min_cost:
            min_cost = cost
        while left <= right and cost > min_cost:
            if server_rack[left] == '0':
                current_zeros -= 1
            left += 1
            zeros_remaining = current_zeros
            ones_removed = total_ones - (right - left + 1 - current_zeros)
            cost = max(zeros_remaining, ones_removed)
            if cost < min_cost:
                min_cost = cost
    return min_cost
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(min_cost(server_rack))",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055407
1390055412,unknown,unknown,unknown,,36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055412
1390055398,unknown,unknown,unknown,"#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void early_fulat(int* arr, int n, int k) {
    int front = 0, rear = 0, dq[n], result[n - k + 1], resIndex = 0;
      int extra_var = 0; 
      for (int i = 0; i < n; i++) {
          extra_var += arr[i] * 0;
          if (front < rear && dq[front] == i - k) {
              front++;
          }
          if (arr[i] < 0) {
              dq[rear++] = i;
          }
          if (i >= k - 1) {
              result[resIndex++] = (front < rear) ? arr[dq[front]] : 0;
          }
      }
      for (int i = 0; i < resIndex; i++) {
          printf(""%d "", result[i]);
      }
      printf(""\n"");
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int* arr = (int*)malloc(n * sizeof(int));
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        early_fulat(arr, n, k);
        free(arr);
    }
    return 0;
}",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055398
1390055404,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055404
1390055397,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055397
1390055390,unknown,unknown,unknown,"def min_effort_to_breach(arr, k):
    n = len(arr)
    # If we can skip all firewalls, effort is 0
    if k >= n:
        return 0
    # Initialize DP table
    # dp[i][j] = min effort to breach first i firewalls using exactly j skips
    dp = {}
    # Base case: no firewalls, no effort
    dp[(0, 0)] = 0  # (firewalls processed, skips used) -> min effort
    for i in range(n):
        new_dp = {}
        for (processed, skips), effort in dp.items():
            # Option 1: Skip current firewall
            if skips < k:
                new_state = (processed + 1, skips + 1)
                new_effort = effort
                if new_state not in new_dp or new_effort < new_dp[new_state]:
                    new_dp[new_state] = new_effort
            # Option 2: Breach current firewall
            new_state = (processed + 1, skips)
            new_effort = effort + arr[i] + skips
            if new_state not in new_dp or new_effort < new_dp[new_state]:
                new_dp[new_state] = new_effort
        dp = new_dp
    # Find minimum effort among all states that processed all firewalls
    min_effort = float('inf')
    for (processed, skips), effort in dp.items():
        if processed == n:
            min_effort = min(min_effort, effort)
    return min_effort
def solve_test_cases():
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = min_effort_to_breach(arr, k)
        results.append(result)
    # Print results
    for result in results:
        print(result)
# Execute program
if __name__ == ""__main__"":
    solve_test_cases()",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055390
1390055392,unknown,unknown,unknown,"def min_effort_to_breach_firewalls(t, test_cases):
    results = []
    for test in test_cases:
        n, k = test[0]
        arr = test[1]
        # Sort firewall strengths in descending order
        arr_sorted = sorted(arr, reverse=True)
        # Choose top k strong firewalls to skip
        skips = set()
        for i in range(k):
            skips.add(arr_sorted[i])
        total_effort = 0
        skipped = 0
        for strength in arr:
            if strength in skips and skipped < k:
                skipped += 1
                skips.remove(strength)  # Remove to handle duplicates properly
            else:
                total_effort += strength + skipped  # Each skip adds +1 to every subsequent effort
        results.append(total_effort)
    return results
# -------- DRIVER CODE --------
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append(((n, k), arr))
answers = min_effort_to_breach_firewalls(T, test_cases)
for ans in answers:
    print(ans)",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055392
1390055394,unknown,unknown,unknown,"def minimize_decommission_cost(test_cases):
    results = []
    for binary_string in test_cases:
        n = len(binary_string)
        total_idle = binary_string.count('0')  
        total_active = binary_string.count('1')  
        min_cost = float('inf')  
        for start in range(n + 1):  
            for end in range(n - start + 1):  
                remaining = binary_string[start:n - end]
                remaining_idle = remaining.count('0')
                decommissioned_active = total_active - remaining.count('1')
                cost = max(remaining_idle, decommissioned_active)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
results = minimize_decommission_cost(test_cases)
for result in results:
    print(result)",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055394
1390055389,unknown,unknown,unknown,"import sys
def main():
    # Read number of test cases
    T = int(input())
    for _ in range(T):
        # Read the binary string
        S = input().strip()
        n = len(S)
        # Compute prefix sums for '0's and '1's
        prefix_zeros = [0] * (n + 1)
        prefix_ones = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_zeros[i] = prefix_zeros[i - 1] + (S[i - 1] == '0')
            prefix_ones[i] = prefix_ones[i - 1] + (S[i - 1] == '1')
        # Initialize minimum cost
        min_cost = float('inf')
        # Iterate over all possible end indices j
        for j in range(n + 1):
            # Number of '1's in the suffix from j to n
            C = prefix_ones[n] - prefix_ones[j]
            # Binary search to find the smallest m where:
            # Number of '0's in [m, j-1] <= Number of '1's in [0, m-1] + [j, n-1]
            left, right = 0, j
            while left < right:
                mid = left + (right - left) // 2
                if prefix_zeros[j] - prefix_zeros[mid] <= prefix_ones[mid] + C:
                    right = mid
                else:
                    left = mid + 1
            m = left
            # Compute cost based on the optimal m
            if m == 0:
                # If m is 0, no prefix is removed, cost is just '1's in suffix
                cost = C
            else:
                # Cost is min of '0's in [m-1, j-1] and '1's in [0, m-1] + [j, n-1]
                cost = min(prefix_zeros[j] - prefix_zeros[m - 1], prefix_ones[m] + C)
            min_cost = min(min_cost, cost)
        # Output the minimum cost for this test case
        print(min_cost)
if __name__ == ""__main__"":
    main()",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055389
1390055378,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    values = [a[i] - (n - i - 1) for i in range(n)]
    values.sort(reverse=True)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + values[i]
    max_m = min(k, n)
    max_total = max(prefix_sum[m] + m * (m - 1) // 2 for m in range(max_m + 1))
    print(sum(a) - max_total)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055378
1390055383,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055383
1390055386,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":
    main()",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055386
1390055373,unknown,unknown,unknown,"import sys
def solve():
    x = sys.stdin.buffer.read().split()
    if not x: return
    t = int(x[0])
    i = 1
    o = []
    for _ in range(t):
        s = x[i].decode()
        i += 1
        n = len(s)
        A = [0]*(n+1)
        B = [0]*(n+1)
        for j in range(n):
            B[j+1] = B[j] + (s[j]=='1')
            A[j+1] = A[j] + (s[j]=='0')
        T = A[n]
        C = [0]*(n+1)
        E = [0]*(n+1)
        for j in range(n):
            E[j+1] = E[j] + (s[n-1-j]=='1')
            C[j+1] = C[j] + (s[n-1-j]=='0')
        r = 10**9
        for x_ in range(n+1):
            m = n - x_
            y = T - A[x_] - B[x_]
            if y < 0: y = 0
            if y > m: y = m
            for z in (y, y-1, y+1):
                if z < 0 or z > m: continue
                v1 = B[x_] + E[z]
                v2 = T - (A[x_] + C[z])
                v = v1 if v1 >= v2 else v2
                if v < r: r = v
        o.append(str(r))
    sys.stdout.write(""\n"".join(o))
if __name__==""__main__"":
    solve()",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055373
1390055374,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055374
1390055377,unknown,unknown,unknown,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <cmath>
#define int long long int
#define pb push_back
/*---------------------------------------------------------------------------------------------------------------------------------*/
/*ASCII small case-> a-97 to z-122
upper case-> A-65 to Z-90*/
#define nl ""\n""
#define mp map<int, int>
#define all(v) v.begin(), v.end()
#define F first
#define S second
#define ump unordered_map<long long, int, custom_hash>
#define mstpi multiset<pair<int, int> >
#define mst multiset<int>
#define vec vector<int>
#define pi pair<int, int>
#define ld long double
#define vep vector<pair<int, int>>
#define ul unsigned long long
#define loop1 for (int i = 0; i < n; i++)
#define REP(i, a, b) for (int i = a; i <= b; i++)
#define NO cout << ""NO"" << endl
#define YES cout << ""YES"" << endl
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
/*---------------------------------------------------------------------------------------------------------------------------------*/
const double PI = 3.1415926535;
const int inf = 1e18;
const int mod = 1000000007;
/*---------------------------------------------------------------------------------------------------------------------------------*/
int modmul(int a, int b, int m)
{
    a %= m;
    b %= m;
    return (a * b) % m;
}
int modexp(int n, int x)
{
    int ans = 1;
    while (n > 0)
    {
        if (n & 1)
        {
            ans = (ans * x) % mod;
        }
        n >>= 1;
        x = (x * x) % mod;
    }
    return ans;
}
/*---------------------------------------------------------------------------------------------------------------------------------*/
string add(string a, string b)
{
    string ans = """";
    int carry = 0;
    while (!a.empty() || !b.empty() || carry > 0)
    {
        int digitA = a.empty() ? 0 : a.back() - '0';
        int digitB = b.empty() ? 0 : b.back() - '0';
        int sum = digitA + digitB + carry;
        ans = to_string(sum % 10) + ans;
        carry = sum / 10;
        if (!a.empty())
            a.pop_back();
        if (!b.empty())
            b.pop_back();
    }
    return ans;
}
string ministrnum(string a, string b)
{
    if (a.length() > b.length())
        return b;
    else if (b.length() > a.length())
        return a;
    else
    {
        int n = a.length();
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i])
                return b;
            else if (a[i] < b[i])
                return a;
        }
    }
    return a;
}
vector<int> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    if(n >= 0) isPrime[0] = false;
    if(n >= 1) isPrime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}
class SegmentTree {
public:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(arr, 0, n - 1, 0);
    }
    void build(const std::vector<int>& arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, start, mid, 2 * index + 1);
        build(arr, mid + 1, end, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
    int queryRange(int start, int end, int l, int r, int index = 0) {
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if (start > r || end < l)
            return 0;
        if (start >= l && end <= r)
            return tree[index];
        int mid = (start + end) / 2;
        return queryRange(start, mid, l, r, 2 * index + 1) +
               queryRange(mid + 1, end, l, r, 2 * index + 2);
    }
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
        if(lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if(start > r || end < l)
            return;
        if(start >= l && end <= r) {
            tree[index] += (end - start + 1) * diff;
            if(start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }
            return;
        }
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, diff, 2 * index + 1);
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
};
class DSU {
public:
    std::vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY)
            return false;
        if (rank[rootX] < rank[rootY])
            parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY])
            parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int val;
    int weight, size;
    Node *left, *right;
    bool rev = false;
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
};
ostream &operator<<(ostream &os, Node *n) {
    if(!n) return os;
    os << n -> left;
    os << n -> val;
    os << n -> right;
    return os;
}
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
void push(Node* Treap) {
    if(!Treap) return;
    if(Treap -> rev) {
        Treap -> rev = false;
        swap(Treap->left, Treap->right);
        if(Treap -> left) Treap->left->rev ^= true;
        if(Treap -> right) Treap->right->rev ^= true;
    }
}
void pull(Node *Treap) {
    if(!Treap) return;
    push(Treap -> left), push(Treap -> right);
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
    return;
}
void split(Node *Treap, Node *&left, Node *&right, int val) {
    if(!Treap) {
        left = right = NULL;
        return;
    }
    push(Treap);
    if(size(Treap -> left) < val) {
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
        left = Treap;
    }
    else {
        split(Treap -> left, left, Treap -> left, val);
        right = Treap;
    }
    pull(Treap);
}
void merge(Node *&Treap, Node *left, Node *right) {
    push(left), push(right);
    if(left == NULL) {
        Treap = right;
        return;
    }
    if(right == NULL) {
        Treap = left;
        return;
    }
    if(left -> weight < right -> weight) {
        merge(right -> left, left, right -> left);
        Treap = right;
    }
    else {
        merge(left->right, left->right, right);
        Treap = left;
    }
    pull(Treap);
}
void inOrder(Node *curr, vector<int> &res) {
    if(curr == NULL) return;
    push(curr);
    inOrder(curr->left, res);
    res.pb(curr->val);
    inOrder(curr->right, res);
    pull(curr);
}
struct Treap {
    Node *root = nullptr;
    void insert(int i, int val) {
        Node *l, *r;
        split(root, l, r, i);
        Node *v = new Node(val);
        merge(l, l, v);
        merge(root, l, r);
    }
    void del(int i) {
        Node *l, *r;
        split(root, l, r, i);
        split(r, root, r, 1);
        merge(root, l, r);
    }
    void update(int l, int r, function<void(Node *)> f) {
        Node *a, *b, *c;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        if(b) {f(b);}
        merge(root, a, b);
        merge(root, root, c);
    }
    vector<int> allPr() {
        vector<int> res;
        inOrder(root, res);
        return res;
    }
    void cycShft(int l, int r) {
        Node *a, *b, *c, *d;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        split(b, b, d, r-l);
        merge(root, a, d);
        merge(root, root, b);
        merge(root, root, c);
    }
};
vector<int> computePrefix(const string &pattern) {
    int n = pattern.size();
    vector<int> prefix(n, 0);
    for (int i = 1, j = 0; i < n; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = prefix[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        prefix[i] = j;
    }
    return prefix;
}
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> prefix = computePrefix(pattern);
    vector<int> occurrences;
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = prefix[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == (int)pattern.size()) {
            occurrences.push_back(i - j + 1);
            j = prefix[j - 1];
        }
    }
    return occurrences;
}
void solve()
{
    int n, ans = 1e9;
    string s;
    cin>>s;
    n = s.size();
    int tot1 = count(all(s), '1');
    ans = tot1;
    auto check = [&](int m) {
        int cnt0 = 0, cnt1 = 0;
        for(int i = 0, j = 0; i<n; i++) {
            cnt0 += s[i] == '0';
            cnt1 += s[i] == '1';
            if(tot1 - cnt1 == m) {
                while(j < n && s[j] == '0') {
                    cnt0--;
                    j++;
                }
                if(cnt0 <= m) return true;
                cnt1--;
                j++;
            }
        }
        return false;
    };
    int l = 0, r = ans;
    while(l <= r) {
        int m = r - (r - l)/2;
        if(check(m)) r = m - 1;
        else l = m + 1;
    }
    cout<<l<<endl;
}
int32_t main()
{
    ios_base ::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055377
1390055369,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055369
1390055370,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055370
1390055371,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    total_effort = sum(strengths)  # Base effort without skipping
    min_effort = total_effort  # Initialize minimum effort
    for skips in range(k + 1):  # Try skipping 0 to k firewalls
        effort = sum(strengths[skips:]) + sum(range(skips))  # Apply security increase for remaining firewalls
        min_effort = min(min_effort, effort)  # Track minimum possible effort
    return min_effort
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, strengths))",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055371
1390055367,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    min_effort = total_effort  # Start with no skips
    for i in range(n):
        if k > 0:  # If we can skip at least one firewall
            new_effort = total_effort - firewalls[i]  # Remove the skipped firewall's effort
            new_effort += sum(1 for j in range(i + 1, n))  # Increase remaining firewalls' strength
            min_effort = min(min_effort, new_effort)  # Keep track of the minimum effort
    return min_effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055367
1390055362,unknown,unknown,unknown,"def min_effort_to_breach(arr, k):
    n = len(arr)
    # If we can skip all firewalls, effort is 0
    if k >= n:
        return 0
    # Initialize DP table
    # dp[i][j] = min effort to breach first i firewalls using exactly j skips
    dp = {}
    # Base case: no firewalls, no effort
    dp[(0, 0)] = 0  # (firewalls processed, skips used) -> min effort
    for i in range(n):
        new_dp = {}
        for (processed, skips), effort in dp.items():
            # Option 1: Skip current firewall
            if skips < k:
                new_state = (processed + 1, skips + 1)
                new_effort = effort
                if new_state not in new_dp or new_effort < new_dp[new_state]:
                    new_dp[new_state] = new_effort
            # Option 2: Breach current firewall
            new_state = (processed + 1, skips)
            new_effort = effort + arr[i] + skips
            if new_state not in new_dp or new_effort < new_dp[new_state]:
                new_dp[new_state] = new_effort
        dp = new_dp
    # Find minimum effort among all states that processed all firewalls
    min_effort = float('inf')
    for (processed, skips), effort in dp.items():
        if processed == n:
            min_effort = min(min_effort, effort)
    return min_effort
def solve_test_cases():
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = min_effort_to_breach(arr, k)
        results.append(result)
    # Print results
    for result in results:
        print(result)
# Execute program
if __name__ == ""__main__"":
    solve_test_cases()",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055362
1390055363,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055363
1390055361,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055361
1390055356,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            solve(sc);
        }
        sc.close();
    }
    static void solve(Scanner sc) {
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        int minEffort = Integer.MAX_VALUE;
        // Iterate over all subsets using bitmasking
        for (int i = 0; i < (1 << n); i++) {
            List<Integer> skipped = new ArrayList<>();
            List<Integer> efforts = new ArrayList<>();
            for (int j = 0; j < n; j++) {
                if ((i >> j & 1) == 1) {
                    skipped.add(j);
                } else {
                    efforts.add(j);
                }
            }
            if (skipped.size() <= k) {
                int effort = 0;
                int skippedCount = 0;
                for (int j = 0; j < n; j++) {
                    if (skipped.contains(j)) {
                        skippedCount++;
                    } else {
                        effort += a[j] + skippedCount;
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
        }
        System.out.println(minEffort);
    }
}",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055356
1390055355,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055355
1390055358,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055358
1390055352,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055352
1390055353,unknown,unknown,unknown,"import sys
def findMinimumCost():
    data = sys.stdin.read().splitlines()
    tests = int(data[0])
    line = 1
    ans = []
    for _ in range(tests):
        servers = data[line].strip()
        line += 1
        ones = [i for i, c in enumerate(servers) if c == '1']
        one_count = len(ones)
        if one_count == 0:
            ans.append(""0"")
            continue
        diffs = [ones[i] - i for i in range(one_count)]
        def check(limit):
            if one_count - limit <= 0:
                return True
            j = 0
            for i in range(one_count):
                j = max(j, i)
                while j < one_count and diffs[j] - diffs[i] <= limit:
                    j += 1
                if j - i >= one_count - limit:
                    return True
            return False
        left, right, answer = 0, len(servers), len(servers)
        while left <= right:
            mid = (left + right) // 2
            if check(mid):
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        ans.append(str(answer))
    sys.stdout.write(""\n"".join(ans))
if __name__ == ""__main__"":
    findMinimumCost()",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055353
1390055354,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055354
1390055350,unknown,unknown,unknown,"def min_effort(n, k, a):
    if k >= n:
        return 0
    total = sum(a)
    window_sum = sum(a[:k])
    min_effort = total - window_sum + (n - k) * 0
    for i in range(k, n):
        window_sum = window_sum + a[i] - a[i - k]
        effort = total - window_sum + (n - k) * (i - k + 1)
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(min_effort(n, k, a))",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055350
1390055342,unknown,unknown,unknown,,39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055342
1390055344,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add current element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Capture the first faulty component in the batch
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        results.append("" "".join(map(str, earliest_faults(arr, k))))
    print(""\n"".join(results))
# Run the function
process_test_cases()",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055344
1390055345,unknown,unknown,unknown,"from collections import deque
def faulty_readings(arr, k):
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, len(arr)):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    print(*faulty_readings(arr, k))  ",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055345
1390055332,unknown,unknown,unknown,"def min_cost(s):
    total_ones = s.count('1')
    n = len(s)
    scenario_empty = total_ones  # cost when removing all
    # Scenario 1: window lengths 1 to min(total_ones, n)
    scenario1_cost = float('inf')
    if total_ones == 0:
        scenario1_cost = 0  # all are 0s, best is to remove all
    else:
        max_ones = 0
        L = min(total_ones, n)
        for l in range(1, L + 1):
            if l > n:
                continue
            current_ones = sum(1 for c in s[:l] if c == '1')
            current_max = current_ones
            for i in range(1, n - l + 1):
                current_ones -= (s[i-1] == '1')
                current_ones += (s[i + l - 1] == '1')
                if current_ones > current_max:
                    current_max = current_ones
            if current_max > max_ones:
                max_ones = current_max
        scenario1_cost = total_ones - max_ones
    # Scenario 2: window lengths > total_ones
    scenario2_cost = float('inf')
    if n > total_ones:
        min_zeros = float('inf')
        for l in range(total_ones + 1, n + 1):
            current_zeros = sum(1 for c in s[:l] if c == '0')
            current_min = current_zeros
            for i in range(1, n - l + 1):
                current_zeros -= (s[i-1] == '0')
                current_zeros += (s[i + l -1] == '0')
                if current_zeros < current_min:
                    current_min = current_zeros
            if current_min < min_zeros:
                min_zeros = current_min
        scenario2_cost = min_zeros
    candidates = [scenario1_cost, scenario_empty]
    if n > total_ones:
        candidates.append(scenario2_cost)
    return min(candidates)
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055332
1390055340,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
        min_cost = float('inf')
        for i in range(n + 1):
            left = 0
            right = n - i
            best_cost = float('inf')
            best_j = 0
            while left <= right:
                mid = (left + right) // 2
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
                    best_cost = current_cost
                    best_j = mid
                if decommissioned_1 < remaining_0:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= n - i:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    best_cost = min(best_cost, current_cost)
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input Handling
if __name__ == ""__main__"":
    T = int(input())
    test_cases = [input().strip() for _ in range(T)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055340
1390055336,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055336
1390055325,unknown,unknown,unknown,"import java.util.*;
public class Solution {  // Use Solution if required by the online judge
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            // Sort in descending order using Collections.sort
            Collections.sort(values, new Comparator<Long>() {
                public int compare(Long x, Long y) {
                    return Long.compare(y, x); // Descending order
                }
            });
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055325
1390055323,unknown,unknown,unknown,"def solve():
    server_rack = input().strip()
    n = len(server_rack)
    # Count total '1's in the string
    total_ones = server_rack.count('1')
    min_cost = float('inf')
    left_ones = 0
    remaining_zeros = server_rack.count('0')
    # Traverse the string considering removing from left side
    for i in range(n + 1):
        if i > 0:
            # Update the number of removed ones
            left_ones += (server_rack[i - 1] == '1')
        # Compute cost at this point
        cost = max(remaining_zeros, left_ones)
        min_cost = min(min_cost, cost)
        # Reduce remaining zeros if the next character is '0'
        if i < n and server_rack[i] == '0':
            remaining_zeros -= 1
    print(min_cost)
# Read number of test cases
T = int(input().strip())
for _ in range(T):
    solve()",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055323
1390055329,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055329
1390055322,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055322
1390055318,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [int(c) for c in servers]
    # Compute prefix sum of active servers (1s)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]  # Total active servers
    min_cost = total_ones  # Worst case: decommission all active servers
    j = 0  # Right boundary of the window
    for i in range(n + 1):
        # Move j to maintain segment_zeros >= total_ones_removed
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
            j += 1
        # Calculate cost at current window
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
        left_ones = prefix_sum[i]
        right_ones = total_ones - prefix_sum[j - 1]
        cost = max(segment_zeros, left_ones + right_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    results = []
    for i in range(1, t + 1):
        results.append(str(minimum_decommission_cost(data[i])))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    process_input()",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055318
1390055319,unknown,unknown,unknown,"def min_effort_to_breach_firewalls(t, test_cases):
    results = []
    for test in test_cases:
        n, k = test[0]
        arr = test[1]
        # Sort firewall strengths in descending order
        arr_sorted = sorted(arr, reverse=True)
        # Choose top k strong firewalls to skip
        skips = set()
        for i in range(k):
            skips.add(arr_sorted[i])
        total_effort = 0
        skipped = 0
        for strength in arr:
            if strength in skips and skipped < k:
                skipped += 1
                skips.remove(strength)  # Remove to handle duplicates properly
            else:
                total_effort += strength + skipped  # Each skip adds +1 to every subsequent effort
        results.append(total_effort)
    return results
# -------- DRIVER CODE --------
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append(((n, k), arr))
answers = min_effort_to_breach_firewalls(T, test_cases)
for ans in answers:
    print(ans)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055319
1390055316,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055316
1390055309,unknown,unknown,unknown,"def min_effort(tst_case):
    rst = []
    for n, k, st in tst_case:
        st.sort()
        if k >= n:
            rst.append(0)
        else:
            te = sum(st[k:])
            rst.append(te)
    return rst
if __name__==""__main__"":
    T = int(input())
    tst_case = []
    for _ in range(T):
        n, k = map(int, input().split())
        st =  list(map(int,input().split()))
        tst_case.append((n,k,st))
    rst = min_effort(tst_case)
    for res in rst:
        print(res)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055309
1390055313,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        dq = deque()
        output = []
        for i in range(n):
            # Remove elements that are out of this window
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add current element if it is faulty (negative)
            if arr[i] < 0:
                dq.append(i)
            # Process first valid window
            if i >= k - 1:
                output.append(arr[dq[0]] if dq else 0)
        results.append(output)
    return results
# Reading input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing and printing output
results = earliest_faulty_readings(t, test_cases)
for res in results:
    print("" "".join(map(str, res)))",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055313
1390055314,unknown,unknown,unknown,"// #include <cmath>
// #include <cstdio>
// #include <vector>
// #include <iostream>
// #include <algorithm>
// using namespace std;
// int main() {
//     /* Enter your code here. Read input from STDIN. Print output to STDOUT */
//     int t=0;
//     cin>>t;
//     while(t){
//     int n=0,k=0,sum=0;
//     cin>>n;
//     cin>>k;
//     vector<int>arr;
//     for(int i=0;i<n;i++){
//         int temp=0;
//         cin>>temp;
//         arr.emplace_back(temp);
//     }
//     while(k){
//         int maximum=max_element(arr.begin(),arr.end());
//         // cout<<maximum<<"" "";
//         for (auto it = maximum; it != arr.end(); ++it) {
//         (*it)++;  //+1
//     }
//         arr.erase(remove(arr.begin(), arr.end(), maximum), arr.end());
//         k--;
//     }
//     for(auto it:arr){
//         sum+=it;
//     }
//         cout<<sum<<endl;
//         t--;
//     }
//     return 0;
// }
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }   
        for (int i = 0; i < k; i++) {
            auto max_it = max_element(arr.begin(), arr.end());
            if (max_it == arr.end()) break;
            int max_index = distance(arr.begin(), max_it);
            for (int j = max_index + 1; j < n; j++) {
                arr[j]++;
            }
            arr.erase(max_it);
            n--;
        }
        int sum = 0;
        for (int x : arr) {
            sum += x;
        }
        cout << sum << endl;
    }
    return 0;
}",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055314
1390055305,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055305
1390055306,unknown,unknown,unknown,"t = int(input())  
while t > 0:
    l, s = map(int, input().split()) 
    user_input = list(map(int, input().split()))  
    total_effort = sum(user_input)  
    min_effort = total_effort  
    for i in range(l):  
        new_effort = (total_effort - user_input[i]) + s * (l - 1)
        min_effort = min(min_effort, new_effort)  
    print(min_effort)  
    t -= 1  
        ",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055306
1390055307,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        prefix_ones = [0] * (n + 1)
        prefix_zeros = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_ones[i] = prefix_ones[i - 1] + (1 if s[i - 1] == '1' else 0)
            prefix_zeros[i] = prefix_zeros[i - 1] + (1 if s[i - 1] == '0' else 0)
        total_ones = prefix_ones[n]
        total_zeros = prefix_zeros[n]
        min_cost = float('inf')
        for i in range(n + 1):
            for j in range(i, n + 1):
                ones_in_subarray = prefix_ones[j] - prefix_ones[i]
                zeros_in_subarray = prefix_zeros[j] - prefix_zeros[i]
                removed_ones = total_ones - ones_in_subarray
                cost = max(zeros_in_subarray, removed_ones)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input())
test_cases = [input().strip() for _ in range(T)]
results = min_decommissioning_cost(test_cases)
for result in results:
    print(result)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055307
1390055304,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        output = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            found = next((x for x in batch if x < 0), 0)
            output.append(str(found))
        results.append("" "".join(output))
    return results
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
for result in earliest_faulty_readings(test_cases):
    print(result)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055304
1390055300,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    if n == 0:
        return 0  # No firewalls to pass
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Do not skip
            dp[i][j] = dp[i-1][j] + firewalls[i-1] + j
            # Case 2: Skip if possible
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    if len(firewalls) != n:
        print(""Invalid input"")  # Handle input error
        exit()
    print(min_effort(n, k, firewalls))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055300
1390055303,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055303
1390055299,unknown,unknown,unknown,"def compute_min_cost(s):
    T = s.count('1')
    if T == 0:
        return 0
    n = len(s)
    # Compute x_max_case1: max number of 1's in window of length T
    x_max_case1 = 0
    if T <= n:
        current = sum(1 for c in s[:T] if c == '1')
        x_max_case1 = current
        for i in range(1, n - T + 1):
            if s[i-1] == '1':
                current -= 1
            if s[i + T - 1] == '1':
                current += 1
            if current > x_max_case1:
                x_max_case1 = current
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
    x_max_case2 = 0
    current_run = 0
    for c in s:
        if c == '1':
            current_run += 1
        else:
            if current_run > 0:
                candidate = min(current_run, T-1)
                if candidate > x_max_case2:
                    x_max_case2 = candidate
                current_run = 0
    # Check the last run
    if current_run > 0:
        candidate = min(current_run, T-1)
        if candidate > x_max_case2:
            x_max_case2 = candidate
    case1_cost = T - x_max_case1
    case2_cost = T - x_max_case2
    return min(case1_cost, case2_cost)
def main():
    import sys
    input = sys.stdin.read().split()
    T_cases = int(input[0])
    for i in range(1, T_cases + 1):
        s = input[i]
        print(compute_min_cost(s))
if __name__ == ""__main__"":
    main()",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055299
1390055294,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055294
1390055297,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055297
1390055298,unknown,unknown,unknown,"def min_cost(server_rack):
    n = len(server_rack)
    total_zeros = server_rack.count('0')
    total_ones = n - total_zeros
    min_cost = float('inf')
    left = 0
    current_zeros = 0
    for right in range(n):
        if server_rack[right] == '0':
            current_zeros += 1
        zeros_remaining = current_zeros
        ones_removed = total_ones - (right - left + 1 - current_zeros)
        cost = max(zeros_remaining, ones_removed)
        if cost < min_cost:
            min_cost = cost
        while left <= right and cost > min_cost:
            if server_rack[left] == '0':
                current_zeros -= 1
            left += 1
    return min_cost
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(min_cost(server_rack))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055298
1390055290,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Build prefix sums for zeros and ones.
        // prefix0[i] = number of '0's in s[0, i)
        // prefix1[i] = number of '1's in s[0, i)
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        // We'll binary search for the minimal cost C in the range [0, n].
        int low = 0, high = n, ans = n;
        while(low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
            for (int l = 0; l <= n; l++) {
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
                // We require that prefix0[r] - prefix0[l] <= mid.
                // That is, prefix0[r] <= prefix0[l] + mid.
                // Because prefix0 is non-decreasing, we can use upper_bound:
                int allowed = prefix0[l] + mid;
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                // Then the maximum r with zeros constraint is r_max = r - 1.
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
                int r_max = r - 1;
                // Ones kept in s[l, r_max) is:
                int onesKept = prefix1[r_max] - prefix1[l];
                // We need onesKept >= totalOnes - mid.
                if(onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if(feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055290
1390055293,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    min_effort = float('inf')
    for j in range(k + 1):
        min_effort = min(min_effort, dp[n][j])
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055293
1390055292,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    if n==k:
        return 0
    total_effort = sum(firewalls)
    min_effort = total_effort  # Start with no skips
    for i in range(n):
        if k > 0:  # If we can skip at least one firewall
            new_effort = total_effort - firewalls[i]  # Remove the skipped firewall's effort
            new_effort += sum(1 for j in range(i + 1, n))  # Increase remaining firewalls' strength
            min_effort = min(min_effort, new_effort)  # Keep track of the minimum effort
    return min_effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055292
1390055288,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--) {
        string s;
        cin >> s;
        int n = s.size();
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        int low = 0, high = n, ans = n;
        while(low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            for (int l = 0; l <= n; l++) {
                int allowed = prefix0[l] + mid;
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                if(r - 1 < l) continue;  
                int r_max = r - 1;
                int onesKept = prefix1[r_max] - prefix1[l];
                if(onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if(feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055288
1390055278,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055278
1390055280,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055280
1390055286,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == ""__main__"":
    solve()",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055286
1390055262,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055262
1390055265,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def min_server_pruning_cost(s):
    n = len(s)
    total_ones = s.count('1')
    if total_ones == 0:
        return 0
    total_zeros = n - total_ones
    low, high = 0, max(total_ones, total_zeros)
    answer = high
    while low <= high:
        mid = (low + high) // 2
        required_ones = max(0, total_ones - mid)
        if required_ones == 0:
            answer = mid
            high = mid - 1
            continue
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
        if max_ones >= required_ones:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
T = int(input().strip())
for _ in range(T):
    s = input().strip()
    print(min_server_pruning_cost(s))",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055265
1390055269,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055269
1390055258,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [int(c) for c in servers]
    # Compute prefix sum of active servers (1s)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]  # Total active servers
    min_cost = total_ones  # Worst case: decommission all active servers
    j = 0  # Right boundary of the window
    for i in range(n + 1):
        # Move j to maintain segment_zeros >= total_ones_removed
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
            j += 1
        # Calculate cost at the current window
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
        left_ones = prefix_sum[i]
        right_ones = total_ones - prefix_sum[j - 1]
        cost = max(segment_zeros, left_ones + right_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    results = []
    for i in range(1, t + 1):
        results.append(str(minimum_decommission_cost(data[i])))
    print(""\n"".join(results))
# Correcting the name definition
if __name__ == ""__main__"":
    process_input()",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055258
1390055259,unknown,unknown,unknown,"import sys
def min_effort_to_breach(n, k, strengths):
    impacts = []
    for i in range(n):
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    impacts.sort(reverse=True)
    to_skip = set(impacts[i][1] for i in range(k))
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            penalty += 1
        else:
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(sys.stdin.readline().strip())  # Efficient input handling
    results = []
    for _ in range(t):
        n, k = map(int, sys.stdin.readline().strip().split())
        strengths = list(map(int, sys.stdin.readline().strip().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
def main():
    results = solve_test_cases()
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055259
1390055260,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    n = len(server_rack)
    # Find the first and last occurrence of '1'
    first_one = server_rack.find('1')
    last_one = server_rack.rfind('1')
    # If there are no active servers, the cost is 0
    if first_one == -1:
        return 0
    # Core segment that must remain
    core_segment = server_rack[first_one:last_one + 1]
    # Count idle servers in core segment
    remaining_idle = core_segment.count('0')
    # Try different trims from both ends
    min_cost = remaining_idle  # Start with keeping all '1's
    for trim_start in range(first_one + 1):  # Remove '1's from start
        for trim_end in range(n - last_one):  # Remove '1's from end
            decommissioned_active = trim_start + trim_end
            cost = max(remaining_idle, decommissioned_active)
            min_cost = min(min_cost, cost)
    return min_cost
# Read input
t = int(input().strip())  # Number of test cases
for _ in range(t):
    server_rack = input().strip()  # Read binary string
    print(min_decommission_cost(server_rack))",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055260
1390055256,unknown,unknown,unknown,"def find_earliest_fault(test_cases):
    result = []
    for n, k, arr in test_cases:
        batch_result = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            fault = next((x for x in batch if x < 0), 0)
            batch_result.append(fault)
        result.append(batch_result)
    return result
t = int(input())  
test_cases = []
for _ in range(t):
    n, k = map(int, input().split()) 
    arr = list(map(int, input().split())) 
    test_cases.append((n, k, arr))
results = find_earliest_fault(test_cases)
for res in results:
    print("" "".join(map(str, res)))",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055256
1390055253,unknown,unknown,unknown,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <cmath>
#define int long long int
#define pb push_back
/*---------------------------------------------------------------------------------------------------------------------------------*/
/*ASCII small case-> a-97 to z-122
upper case-> A-65 to Z-90*/
#define nl ""\n""
#define mp map<int, int>
#define all(v) v.begin(), v.end()
#define F first
#define S second
#define ump unordered_map<long long, int, custom_hash>
#define mstpi multiset<pair<int, int> >
#define mst multiset<int>
#define vec vector<int>
#define pi pair<int, int>
#define ld long double
#define vep vector<pair<int, int>>
#define ul unsigned long long
#define loop1 for (int i = 0; i < n; i++)
#define REP(i, a, b) for (int i = a; i <= b; i++)
#define NO cout << ""NO"" << endl
#define YES cout << ""YES"" << endl
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
/*---------------------------------------------------------------------------------------------------------------------------------*/
const double PI = 3.1415926535;
const int inf = 1e18;
const int mod = 1000000007;
/*---------------------------------------------------------------------------------------------------------------------------------*/
int modmul(int a, int b, int m)
{
    a %= m;
    b %= m;
    return (a * b) % m;
}
int modexp(int n, int x)
{
    int ans = 1;
    while (n > 0)
    {
        if (n & 1)
        {
            ans = (ans * x) % mod;
        }
        n >>= 1;
        x = (x * x) % mod;
    }
    return ans;
}
/*---------------------------------------------------------------------------------------------------------------------------------*/
string add(string a, string b)
{
    string ans = """";
    int carry = 0;
    while (!a.empty() || !b.empty() || carry > 0)
    {
        int digitA = a.empty() ? 0 : a.back() - '0';
        int digitB = b.empty() ? 0 : b.back() - '0';
        int sum = digitA + digitB + carry;
        ans = to_string(sum % 10) + ans;
        carry = sum / 10;
        if (!a.empty())
            a.pop_back();
        if (!b.empty())
            b.pop_back();
    }
    return ans;
}
string ministrnum(string a, string b)
{
    if (a.length() > b.length())
        return b;
    else if (b.length() > a.length())
        return a;
    else
    {
        int n = a.length();
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i])
                return b;
            else if (a[i] < b[i])
                return a;
        }
    }
    return a;
}
vector<int> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    if(n >= 0) isPrime[0] = false;
    if(n >= 1) isPrime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}
class SegmentTree {
public:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(arr, 0, n - 1, 0);
    }
    void build(const std::vector<int>& arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, start, mid, 2 * index + 1);
        build(arr, mid + 1, end, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
    int queryRange(int start, int end, int l, int r, int index = 0) {
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if (start > r || end < l)
            return 0;
        if (start >= l && end <= r)
            return tree[index];
        int mid = (start + end) / 2;
        return queryRange(start, mid, l, r, 2 * index + 1) +
               queryRange(mid + 1, end, l, r, 2 * index + 2);
    }
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
        if(lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if(start > r || end < l)
            return;
        if(start >= l && end <= r) {
            tree[index] += (end - start + 1) * diff;
            if(start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }
            return;
        }
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, diff, 2 * index + 1);
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
};
class DSU {
public:
    std::vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY)
            return false;
        if (rank[rootX] < rank[rootY])
            parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY])
            parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int val;
    int weight, size;
    Node *left, *right;
    bool rev = false;
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
};
ostream &operator<<(ostream &os, Node *n) {
    if(!n) return os;
    os << n -> left;
    os << n -> val;
    os << n -> right;
    return os;
}
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
void push(Node* Treap) {
    if(!Treap) return;
    if(Treap -> rev) {
        Treap -> rev = false;
        swap(Treap->left, Treap->right);
        if(Treap -> left) Treap->left->rev ^= true;
        if(Treap -> right) Treap->right->rev ^= true;
    }
}
void pull(Node *Treap) {
    if(!Treap) return;
    push(Treap -> left), push(Treap -> right);
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
    return;
}
void split(Node *Treap, Node *&left, Node *&right, int val) {
    if(!Treap) {
        left = right = NULL;
        return;
    }
    push(Treap);
    if(size(Treap -> left) < val) {
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
        left = Treap;
    }
    else {
        split(Treap -> left, left, Treap -> left, val);
        right = Treap;
    }
    pull(Treap);
}
void merge(Node *&Treap, Node *left, Node *right) {
    push(left), push(right);
    if(left == NULL) {
        Treap = right;
        return;
    }
    if(right == NULL) {
        Treap = left;
        return;
    }
    if(left -> weight < right -> weight) {
        merge(right -> left, left, right -> left);
        Treap = right;
    }
    else {
        merge(left->right, left->right, right);
        Treap = left;
    }
    pull(Treap);
}
void inOrder(Node *curr, vector<int> &res) {
    if(curr == NULL) return;
    push(curr);
    inOrder(curr->left, res);
    res.pb(curr->val);
    inOrder(curr->right, res);
    pull(curr);
}
struct Treap {
    Node *root = nullptr;
    void insert(int i, int val) {
        Node *l, *r;
        split(root, l, r, i);
        Node *v = new Node(val);
        merge(l, l, v);
        merge(root, l, r);
    }
    void del(int i) {
        Node *l, *r;
        split(root, l, r, i);
        split(r, root, r, 1);
        merge(root, l, r);
    }
    void update(int l, int r, function<void(Node *)> f) {
        Node *a, *b, *c;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        if(b) {f(b);}
        merge(root, a, b);
        merge(root, root, c);
    }
    vector<int> allPr() {
        vector<int> res;
        inOrder(root, res);
        return res;
    }
    void cycShft(int l, int r) {
        Node *a, *b, *c, *d;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        split(b, b, d, r-l);
        merge(root, a, d);
        merge(root, root, b);
        merge(root, root, c);
    }
};
vector<int> computePrefix(const string &pattern) {
    int n = pattern.size();
    vector<int> prefix(n, 0);
    for (int i = 1, j = 0; i < n; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = prefix[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        prefix[i] = j;
    }
    return prefix;
}
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> prefix = computePrefix(pattern);
    vector<int> occurrences;
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = prefix[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == (int)pattern.size()) {
            occurrences.push_back(i - j + 1);
            j = prefix[j - 1];
        }
    }
    return occurrences;
}
void solve()
{
    int n, ans = 1e9;
    string s;
    cin>>s;
    n = s.size();
    int tot1 = count(all(s), '1');
    ans = tot1;
    // vector<int> pref(n, 0);
    // for(int i = 0; i<n; i++) {
        // pref[i] = s[i] == '1';
        // if(i) pref[i] += pref[i - 1];
    // }
//     
//     
    // for(int i = 0; i<n; i++) {
        // for(int j = i; j<n; j++) {
            // int cnt1 = (i?pref[i-1]:0) + pref[n-1] - (j!=n-1?pref[j+1]:pref[n-1]), cnt0 = (j - i + 1) - (pref[j] - (i?pref[i-1]:0));
            // ans = min(ans, max(cnt1, cnt0)); 
        // }
    // }
    // cout<<ans<<'\n';
    auto check = [&](int m) {
        int cnt0 = 0, cnt1 = 0;
        for(int i = 0, j = 0; i<n; i++) {
            cnt0 += s[i] == '0';
            cnt1 += s[i] == '1';
            if(tot1 - cnt1 == m) {
                while(j < n && s[j] == '0') {
                    cnt0--;
                    j++;
                }
                if(cnt0 <= m) return true;
                while(j < n && s[j] != '0') {
                    cnt0--;
                    j++;
                }
                cnt1--;
                j++;
            }
        }
        return false;
    };
    int l = 0, r = ans;
    while(l <= r) {
        int m = r - (r - l)/2;
        if(check(m)) r = m - 1;
        else l = m + 1;
    }
    cout<<l<<endl;
}
int32_t main()
{
    ios_base ::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055253
1390055250,unknown,unknown,unknown,"#include <iostream>
#include <vector>
using namespace std;
int main() {
    int t; // number of test cases
    cin >> t;
    while (t--) {
        int n, k; // size of array and batch size
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        // Iterate through each window (consecutive batch of size k)
        for (int i = 0; i <= n - k; i++) {
            int earliest_fault = 0; // Assume no faults
            // Check the batch from arr[i] to arr[i+k-1]
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    earliest_fault = arr[j]; // Found a negative value, set it as earliest fault
                    break;
                }
            }
            cout << earliest_fault << "" "";
        }
        cout << endl;
    }
    return 0;
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055250
1390055243,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []  
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)  
    for i in range(len(arr) - k + 1):
        if dq:
            result.append(arr[dq[0]])  
        else:
            result.append(0)  
        if dq and dq[0] == i:
            dq.popleft()
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    print(*earliest_faulty_readings(arr, k))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055243
1390055246,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055246
1390055248,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055248
1390055234,unknown,unknown,unknown,"from collections import deque
def find_faulty_batches(sensor_data, batch_size):
    output_list = []
    index_queue = deque()
    for idx in range(batch_size):
        if sensor_data[idx] < 0:
            index_queue.append(idx)
    output_list.append(sensor_data[index_queue[0]] if index_queue else 0)
    for idx in range(batch_size, len(sensor_data)):
        if index_queue and index_queue[0] < idx - batch_size + 1:
            index_queue.popleft()
        if sensor_data[idx] < 0:
            index_queue.append(idx)
        output_list.append(sensor_data[index_queue[0]] if index_queue else 0)
    return output_list
test_cases = int(input())
for _ in range(test_cases):
    array_size, batch_size = map(int, input().split())
    sensor_readings = list(map(int, input().split()))
    print(*find_faulty_batches(sensor_readings, batch_size))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055234
1390055242,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        dq = deque()
        output = []
        for i in range(n):
            # Remove elements that are out of this window
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add current element if it is faulty (negative)
            if arr[i] < 0:
                dq.append(i)
            # Process first valid window
            if i >= k - 1:
                output.append(arr[dq[0]] if dq else 0)
        results.append(output)
    return results
# Reading input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing and printing output
results = earliest_faulty_readings(t, test_cases)
for res in results:
    print("" "".join(map(str, res)))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055242
1390055235,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055235
1390055229,unknown,unknown,unknown,"def min_cost(rack):
    n = len(rack)
    min_cost = float('inf')
    for start in range(n + 1):
        for end in range(n - start + 1):
            remaining = rack[start:n-end]
            idle_remaining = remaining.count('0')
            removed_start = rack[:start]
            removed_end = rack[n-end:] if end > 0 else ''
            active_removed = removed_start.count('1') + removed_end.count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    rack = input().strip()
    print(min_cost(rack))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055229
1390055226,unknown,unknown,unknown,"def min_effort(n, k, a):
    dp = [float('inf')] * (k + 1)
    dp[0] = 0
    for i in range(n):
        prev = dp[:]
        for j in range(k + 1):
            if j <= i + 1:
                dp[j] = prev[j] + a[i] + j
            if j > 0:
                dp[j] = min(dp[j], prev[j - 1])
    return min(dp)
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(min_effort(n, k, a))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055226
1390055228,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0 
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    return min(dp[n])
T = int(input()) 
for _ in range(T):
    n, k = map(int, input().split()) 
    firewalls = list(map(int, input().split()))  
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055228
1390055227,unknown,unknown,unknown,"def min_effort_to_breach(arr, k):
    n = len(arr)
    if k >= n:
        return 0
    min_effort = float('inf')
    effective_costs = []
    for i in range(n):
        skip_penalty = n - i - 1
        effective_cost = arr[i] - skip_penalty
        effective_costs.append((effective_cost, i))
    effective_costs.sort(reverse=True)
    skipped = [False] * n
    skips_used = 0
    for cost, idx in effective_costs:
        if skips_used < k and cost > 0:
            skipped[idx] = True
            skips_used += 1
    total_effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            total_effort += arr[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())  -
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = min_effort_to_breach(arr, k)
        results.append(result)
    for result in results:
        print(result)
if __name__ == ""__main__"":
    solve_test_cases()",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055227
1390055219,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    active_prefix_sum = [0] * (n + 1)
    idle_suffix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
    for i in range(n-1, -1, -1):
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
    min_cost = float('inf')
    for left in range(n + 1):
        for right in range(left, n + 1):
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055219
1390055216,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine();
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055216
1390055223,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055223
1390055212,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)  
    active_prefix_sum = [0] * (n + 1)
    idle_suffix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
    for i in range(n-1, -1, -1):
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
    min_cost = float('inf')
    for left in range(n + 1):
        for right in range(left, n + 1):
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055212
1390055213,unknown,unknown,unknown,"function processData(input) {
    let data = input.trim().split(/\s+/);
    let index = 0;
    let T = parseInt(data[index++]);
    let output = [];
    for (let test = 0; test < T; test++) {
        let n = parseInt(data[index++]);
        let k = parseInt(data[index++]);
        let a = data.slice(index, index + n).map(Number);
        index += n;
        let sumA = a.reduce((acc, num) => acc + num, 0);
        let v = [];
        for (let i = 0; i < n; i++) {
            v.push(a[i] - (n - i - 1));
        }
        v.sort((a, b) => b - a);
        let prefix = Array(n + 1).fill(0);
        for (let i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + v[i];
        }
        let maxSum = 0;
        let maxT = Math.min(k, n);
        for (let t = 0; t <= maxT; t++) {
            let current = prefix[t] + (t * (t - 1)) / 2;
            maxSum = Math.max(maxSum, current);
        }
        output.push(sumA - maxSum);
    }
    console.log(output.join(""\n""));
}
process.stdin.resume();
process.stdin.setEncoding(""utf-8"");
let input = """";
process.stdin.on(""data"", function (chunk) {
    input += chunk;
});
process.stdin.on(""end"", function () {
    processData(input);
});",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055213
1390055215,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        for (int i = 0; i < t; i++) {
            String servers = scanner.nextLine();
            int minCost = minimizeServerCost(servers);
            System.out.println(minCost);
        }
        scanner.close();
    }
    public static int minimizeServerCost(String servers) {
        int n = servers.length();
        // Precompute prefix sums for O(1) range queries
        int[] prefixZeros = new int[n + 1];
        int[] prefixOnes = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
        }
        int minCost = Integer.MAX_VALUE;
        int totalOnes = prefixOnes[n];
        // Special case optimization - removing no servers
        minCost = Math.min(minCost, prefixZeros[n]);
        // Optimization: instead of nested loops, use a different approach
        // For each possible prefix end position
        for (int prefixEnd = 0; prefixEnd <= n; prefixEnd++) {
            int onesRemovedFromPrefix = prefixOnes[prefixEnd];
            // For minimal cost, we want to minimize max(zerosRemaining, onesRemoved)
            // Since onesRemovedFromPrefix is fixed, we can binary search for the optimal suffix
            int left = prefixEnd;
            int right = n;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                int zerosRemaining = prefixZeros[mid] - prefixZeros[prefixEnd];
                int onesRemovedFromSuffix = totalOnes - prefixOnes[mid];
                int onesRemoved = onesRemovedFromPrefix + onesRemovedFromSuffix;
                if (zerosRemaining <= onesRemoved) {
                    // Try to decrease onesRemoved by moving right
                    left = mid + 1;
                } else {
                    // Try to increase zerosRemaining by moving left
                    right = mid - 1;
                }
                int cost = Math.max(zerosRemaining, onesRemoved);
                if (prefixEnd > 0 || mid < n) { // Skip if removing nothing
                    minCost = Math.min(minCost, cost);
                }
            }
        }
        // Handle cases where we couldn't find an optimal solution
        // One more pass with the regular approach
        for (int prefixEnd = 0; prefixEnd <= n; prefixEnd++) {
            for (int suffixStart = n; suffixStart >= prefixEnd; suffixStart--) {
                // Skip if removing nothing
                if (prefixEnd == 0 && suffixStart == n) continue;
                int onesRemoved = prefixOnes[prefixEnd] + (prefixOnes[n] - prefixOnes[suffixStart]);
                int zerosRemaining = prefixZeros[suffixStart] - prefixZeros[prefixEnd];
                int cost = Math.max(zerosRemaining, onesRemoved);
                minCost = Math.min(minCost, cost);
                // Early termination if we have a boundary case
                if (prefixEnd == 0 || suffixStart == n) {
                    break; // We only need to check one boundary case
                }
            }
        }
        return minCost;
    }
}",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055215
1390055210,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055210
1390055207,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055207
1390055208,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055208
1390055209,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055209
1390055202,unknown,unknown,unknown,"def optimize_server_decommissioning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    optimal_i = 0
    optimal_j = 0
    for i in range(n + 1):
        for j in range(n + 1 - i):
            remaining = server_rack[i:n-j]
            if not remaining:  
                active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
                cost = active_removed
            else:
                idle_remaining = remaining.count('0')
                active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
                cost = max(idle_remaining, active_removed)
            if cost < min_cost:
                min_cost = cost
                optimal_i = i
                optimal_j = j
    return min_cost
def main():
    t = int(input().strip())
    results = []
    for _ in range(t):
        server_rack = input().strip()
        min_cost = optimize_server_decommissioning(server_rack)
        results.append(min_cost)
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055202
1390055204,unknown,unknown,unknown,"def earliest_faults(arr, k):
    result = []
    first_fault = 0  # Default if no faults in batch
    for i in range(len(arr) - k + 1):  # Iterate through batches
        batch = arr[i:i + k]
        first_fault = 0  # Reset for each batch
        for num in batch:  # Find first faulty reading
            if num < 0:
                first_fault = num
                break
        result.append(first_fault)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    # Get the result and print it
    print(*earliest_faults(arr, k))",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055204
1390055205,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055205
1390055199,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055199
1390055200,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        benefits.sort(reverse=True)
        skipped = [False] * n
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        total_effort = 0
        penalty = 0  
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
threading.Thread(target=main).start()",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055200
1390055201,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055201
1390055198,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055198
1390055193,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055193
1390055195,unknown,unknown,unknown,"import sys
def minimize_server_shutdown_cost():
    num_cases = int(sys.stdin.readline().strip())
    for _ in range(num_cases):
        server_status = sys.stdin.readline().strip()
        active_servers = [index for index, state in enumerate(server_status) if state == '1']
        total_active = len(active_servers)
        # If no active servers or already consecutive, no operations needed
        if total_active == 0 or active_servers[-1] - active_servers[0] == total_active - 1:
            print(0)
            continue
        low, high = 0, total_active
        while high - low > 1:
            mid_point = (low + high) // 2
            servers_to_keep = total_active - mid_point
            is_possible = False
            for i in range(mid_point + 1):
                first, last = active_servers[i], active_servers[i + servers_to_keep - 1]
                if (last - first + 1) - servers_to_keep <= mid_point:
                    is_possible = True
                    break
            if is_possible:
                high = mid_point
            else:
                low = mid_point
        print(high)
if __name__ == ""__main__"":
    minimize_server_shutdown_cost()",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055195
1390055197,unknown,unknown,unknown,"import sys, bisect
def solve():
    d = sys.stdin.buffer.read().split()
    if not d: return
    t = int(d[0])
    i_d = 1
    res = []
    for _ in range(t):
        s = d[i_d].decode()
        i_d += 1
        n = len(s)
        p1 = [0]*(n+1)
        p0 = [0]*(n+1)
        for i in range(n):
            p1[i+1] = p1[i] + (s[i]=='1')
            p0[i+1] = p0[i] + (s[i]=='0')
        z = p0[n]
        s1 = [0]*(n+1)
        s0 = [0]*(n+1)
        for j in range(n):
            s1[j+1] = s1[j] + (s[n-1-j]=='1')
            s0[j+1] = s0[j] + (s[n-1-j]=='0')
        best = 10**9
        for i in range(n+1):
            lo = 0
            hi = n - i
            cand = 10**9
            while lo <= hi:
                m = (lo+hi)//2
                a = p1[i] + s1[m]
                b = (z - p0[i]) - s0[m]
                c = a if a>=b else b
                if a < b:
                    lo = m+1
                else:
                    hi = m-1
                if c < cand: cand = c
            if cand < best: best = cand
        res.append(str(best))
    sys.stdout.write(""\n"".join(res))
if __name__==""__main__"":
    solve()",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055197
1390055189,unknown,unknown,unknown,"def faulty_sensor_readings(arr, k):
    n = len(arr)
    results = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        found_fault = False
        for j in range(len(batch)):
            if batch[j] < 0:
                results.append(batch[j])
                found_fault = True
                break  
        if not found_fault:
            results.append(0)
    return results
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = faulty_sensor_readings(arr, k)
    print(*result)",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055189
1390055192,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
vector<int> helper(vector<int>&arr,int k){
    vector<int> result;
    for(int i = 0; i <= arr.size() - k; i++){
        int f = 0;
        for(int j = i; j < i + k; j++){
            if(arr[j] < 0){
                f = arr[j];
                break;
            }
        }
        result.push_back(f);
    }
    return result;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int a;
    cin>>a;
    while(a--){
        int n,k;
        cin>>n>>k;
        vector<int> arr(n);
        for(int i = 0; i < n; i++){
            cin>>arr[i];
        }
        vector<int>result = helper(arr,k);
        for(int i = 0; i < result.size(); i++){
            cout<<result[i]<<(i == result.size() - 1 ? """":"" "");
        }
        cout<<endl;
    }
    return 0;
}",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055192
1390055190,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array initialized with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: no firewalls, no effort
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Do not skip the i-th firewall
            dp[i][j] = dp[i-1][j] + firewalls[i-1] + j
            # Case 2: Skip the i-th firewall if possible
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # The answer is the minimum value in the last row
    return min(dp[n])
# Read input
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055190
1390055182,unknown,unknown,unknown,"from collections import deque
def find_earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k = case[0], case[1]
        arr = case[2]
        # This will store the result for this test case
        result = []
        # Deque to store indices of faulty readings (negative values)
        dq = deque()
        # Process the first batch
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # For the first window, check the earliest faulty reading
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Slide the window across the rest of the array
        for i in range(k, n):
            # Remove elements out of the current window
            while dq and dq[0] <= i - k:
                dq.popleft()
            # Add the new element if it's a fault (negative)
            if arr[i] < 0:
                dq.append(i)
            # Get the earliest faulty reading for this window
            if dq:
                result.append(arr[dq[0]])
            else:
                result.append(0)
        results.append(result)
    return results
# Input Reading
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing
results = find_earliest_faulty_readings(t, test_cases)
# Output
for result in results:
    print("" "".join(map(str, result)))",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055182
1390055187,unknown,unknown,unknown,"from collections import deque
def find_earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove indices that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add index of negative number to the deque
        if arr[i] < 0:
            dq.append(i)
        # Start collecting results when we have a full window
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
# ------------------------
# MAIN DRIVER CODE
# ------------------------
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and window size
    arr = list(map(int, input().split()))  # Input array
    result = find_earliest_faults(arr, k)
    print(*result)",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055187
1390055188,unknown,unknown,unknown,"def min_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    # Precompute the prefix sums for 0's and 1's
    prefix_zeros = [0] * (n + 1)
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
    # Iterate over all possible windows
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Calculate the number of 0's remaining in the window
            zeros_remaining = prefix_zeros[right] - prefix_zeros[left]
            # Calculate the number of 1's removed outside the window
            ones_removed = prefix_ones[left] + (prefix_ones[n] - prefix_ones[right])
            # Calculate the cost
            cost = max(zeros_remaining, ones_removed)
            # Update the minimum cost
            if cost < min_cost:
                min_cost = cost
    return min_cost
# Read the number of test cases
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(min_cost(server_rack))",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055188
1390055181,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055181
1390055175,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        total_ones = s.count('1')
        total_zeros = s.count('0')
        min_cost = float('inf')
        for i in range(n + 1):
            for j in range(i, n + 1):
                window_zeros = s[i:j].count('0')
                window_ones = s[i:j].count('1')               
                removed_ones = total_ones - window_ones
                remaining_zeros = window_zeros
                cost = max(remaining_zeros, removed_ones)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input()) 
test_cases = [input().strip() for _ in range(T)]
results = min_decommissioning_cost(test_cases)
for result in results:
    print(result)",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055175
1390055176,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        dq = deque()
        output = []
        for i in range(n):
            # Remove elements that are out of this window
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add current element if it is faulty (negative)
            if arr[i] < 0:
                dq.append(i)
            # Process first valid window
            if i >= k - 1:
                output.append(arr[dq[0]] if dq else 0)
        results.append(output)
    return results
# Reading input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing and printing output
results = earliest_faulty_readings(t, test_cases)
for res in results:
    print("" "".join(map(str, res)))",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055176
1390055177,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        firewall_indices = [(a[i], i) for i in range(n)]
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
results = min_effort(test_cases)
for res in results:
    print(res)",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055177
1390055168,unknown,unknown,unknown,"def find_faulty_readings(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        faulty_reading = 0
        for num in batch:
            if num < 0:
                faulty_reading = num
                break
        result.append(faulty_reading)
    return result
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        output = find_faulty_readings(arr, k)
        print(*output)",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055168
1390055169,unknown,unknown,unknown,"import sys
from itertools import accumulate
def min_effort(arr, k):
    n = len(arr)
    T = sum(arr)
    A = [arr[i] + (i+1) for i in range(n)]
    A.sort(reverse=True)
    P = [0] + list(accumulate(A))
    m_max = min(k, n)
    best = float('inf')
    for m in range(m_max + 1):
        cost = T + m * n - (m * m - m) // 2 - P[m]
        if cost < best:
            best = cost
    return best
def solve():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    res = []
    for _ in range(t):
        n = int(data[index]); index += 1
        k = int(data[index]); index += 1
        arr = list(map(int, data[index:index+n])); index += n
        res.append(str(min_effort(arr, k)))
    sys.stdout.write(""\n"".join(res))
if __name__ == ""__main__"":
    solve()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055169
1390055174,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055174
1390055158,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        decommissioned_ones_left = s[:i].count('1')
        for j in range(n - i + 1):
            decommissioned_ones_right = s[n - j:].count('1')
            remaining_zeros = s[i:n - j].count('0')
            ans = min(ans, max(decommissioned_ones_left + decommissioned_ones_right, remaining_zeros))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055158
1390055160,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_ones = servers.count('1')
        min_cost = float('inf')
        for p in range(n + 1):
            for s in range(n - p + 1):
                remaining = servers[p:n-s]
                remaining_zeros = remaining.count('0')
                remaining_ones = remaining.count('1')
                removed_ones = total_ones - remaining_ones
                cost = max(remaining_zeros, removed_ones)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
results = min_cost(test_cases)
print(""\n"".join(map(str, results)))",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055160
1390055163,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def min_cost_to_prune(s):
    n = len(s)
    total_ones = s.count('1')
    max_consecutive_ones = max(map(len, s.split('0')))
    if total_ones == 0:
        return 0
    if max_consecutive_ones == total_ones:
        return 0
    total_zeros = n - total_ones
    low, high = 0, max(total_ones, total_zeros)
    answer = high
    while low <= high:
        mid = (low + high) // 2
        required_ones = max(0, total_ones - mid)
        if required_ones == 0:
            answer = mid
            high = mid - 1
            continue
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
        if max_ones >= required_ones:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
def main():
    t = int(input().strip())
    for _ in range(t):
        s = input().strip()
        print(min_cost_to_prune(s))
if __name__ == ""__main__"":
    main()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055163
1390055156,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055156
1390055149,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine();
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055149
1390055152,unknown,unknown,unknown,"import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    s = data[ptr]
    ptr += 1
    n = len(s)
    pre = [0]*(n+1)
    for i in range(n):
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
    O = pre[n]
    best = 10**9
    for L in range(n+1):
        if L <= n - O:
            cost = O - (pre[L+O] - pre[L])
        else:
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
        if cost < best:
            best = cost
    res.append(str(best))
sys.stdout.write(""\n"".join(res))",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055152
1390055155,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055155
1390055141,unknown,unknown,unknown,"def minimize_effort():
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    # Calculate the initial total effort
    total_effort = sum(strengths)
    # Compute the penalty for skipping each firewall
    skip_penalty = [strengths[i] - (n - i - 1) for i in range(n)]
    # Sort in descending order to prioritize the most beneficial skips
    skip_penalty.sort(reverse=True)
    # Reduce effort by skipping up to k firewalls
    total_effort -= sum(skip_penalty[:k])
    # Account for the incremental difficulty of later firewalls
    total_effort -= k * (k - 1) // 2
    # Print the minimized effort
    print(total_effort)
if __name__ == ""__main__"":
    test_cases = int(input())
    for _ in range(test_cases):
        minimize_effort()",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055141
1390055146,unknown,unknown,unknown,"def minimize_cost(s):
    total_ones = s.count('1')
    total_zeros = len(s) - total_ones
    low = 0
    high = max(total_ones, total_zeros)
    answer = high  # Initialize with the maximum possible value
    while low <= high:
        mid = (low + high) // 2
        K = total_ones - mid
        # Check if current mid is feasible
        if K <= 0:
            feasible = (total_zeros <= mid)
        else:
            current_0 = 0
            current_1 = 0
            left = 0
            feasible = False
            for right in range(len(s)):
                if s[right] == '0':
                    current_0 += 1
                else:
                    current_1 += 1
                # Move left pointer to ensure current_0 <= mid
                while current_0 > mid:
                    if s[left] == '0':
                        current_0 -= 1
                    else:
                        current_1 -= 1
                    left += 1
                # Check if current window meets the 1's requirement
                if current_1 >= K:
                    feasible = True
                    break
        if feasible:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
T = int(input())
for _ in range(T):
    s = input().strip()
    print(minimize_cost(s))",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055146
1390055144,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
#include <climits>
#include <vector>
using namespace std;
int solve(const string& servers) {
    int n = servers.length();
    // Edge case - if all servers are the same type
    bool allActive = true;
    bool allIdle = true;
    for (char c : servers) {
        if (c == '0') allActive = false;
        if (c == '1') allIdle = false;
    }
    if (allActive) return 0; // Remove all from one end - no active servers removed
    if (allIdle) return 0;   // Remove all from one end - no idle servers remaining
    // Count total servers of each type
    int totalActive = 0;
    for (char c : servers) {
        if (c == '1') totalActive++;
    }
    int totalIdle = n - totalActive;
    // Get running counts of each type from left
    vector<int> leftActive(n + 1, 0);
    vector<int> leftIdle(n + 1, 0);
    for (int i = 0; i < n; i++) {
        leftActive[i + 1] = leftActive[i] + (servers[i] == '1');
        leftIdle[i + 1] = leftIdle[i] + (servers[i] == '0');
    }
    int minCost = min(totalActive, totalIdle); // Initialize with removing nothing from left and everything from right
    // For each possible cut point (where to split the server rack)
    for (int cut = 1; cut <= n; cut++) {
        // Try removing left part and keeping right part
        int activeRemovedLeft = leftActive[cut];
        int idleRemainingRight = totalIdle - leftIdle[cut];
        minCost = min(minCost, max(activeRemovedLeft, idleRemainingRight));
        // Try removing right part and keeping left part
        int activeRemovedRight = totalActive - leftActive[cut];
        int idleRemainingLeft = leftIdle[cut];
        minCost = min(minCost, max(activeRemovedRight, idleRemainingLeft));
        // Try removing both left and right parts up to this point
        for (int leftCut = 0; leftCut < cut; leftCut++) {
            int activeRemoved = leftActive[leftCut] + (totalActive - leftActive[cut]);
            int idleRemaining = leftIdle[cut] - leftIdle[leftCut];
            minCost = min(minCost, max(activeRemoved, idleRemaining));
        }
    }
    return minCost;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int t;
    cin >> t;
    while (t--) {
        string servers;
        cin >> servers;
        cout << solve(servers) << ""\n"";
    }
    return 0;
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055144
1390055134,unknown,unknown,unknown,"def calculate_minimum_cost(num_items, num_skipped, values):
    if num_skipped >= num_items:
        return 0
    impact_list = []
    for i in range(num_items):
        impact_value = values[i] - (num_items - i - 1)
        impact_list.append((impact_value, i))
    impact_list.sort(reverse=True)
    skipped_indices = set(impact_list[i][1] for i in range(num_skipped))
    total_cost = 0
    extra_penalty = 0
    for i in range(num_items):
        if i in skipped_indices:
            extra_penalty += 1
        else:
            total_cost += values[i] + extra_penalty
    return total_cost
def process_test_cases():
    test_cases = int(input())
    results = []
    for _ in range(test_cases):
        num_items, num_skipped = map(int, input().split())
        values = list(map(int, input().split()))
        results.append(calculate_minimum_cost(num_items, num_skipped, values))
    return results
def main():
    results = process_test_cases()
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055134
1390055139,unknown,unknown,unknown,"import sys
input = sys.stdin.read
def minimum_effort(arr, k):
    n = len(arr)
    if k == n:
        return 0
    total_effort = sum(arr)
    min_effort = total_effort
    # Initial window sum (first k elements)
    window_sum = sum(arr[:k])
    # Try removing every window of size k
    for i in range(n - k + 1):
        # Effort after skipping this window
        skipped_effort = total_effort - window_sum + k
        min_effort = min(min_effort, skipped_effort)
        # Slide the window to the right
        if i + k < n:
            window_sum = window_sum - arr[i] + arr[i + k]
    return min_effort
# Efficient Input Handling
data = input().strip().split(""\n"")
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n, k = map(int, data[index].split())
    arr = list(map(int, data[index + 1].split()))
    results.append(str(minimum_effort(arr, k)))
    index += 2
# Fast Output
sys.stdout.write(""\n"".join(results) + ""\n"")",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055139
1390055132,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states , really tough one to solved actually 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i (if possible)
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055132
1390055130,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055130
1390055123,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        for (int i = 0; i < t; i++) {
            String servers = scanner.nextLine();
            int minCost = minimizeServerCost(servers);
            System.out.println(minCost);
        }
        scanner.close();
    }
    public static int minimizeServerCost(String servers) {
        int n = servers.length();
        // Precompute prefix sums for O(1) range queries
        int[] prefixZeros = new int[n + 1];
        int[] prefixOnes = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
        }
        int minCost = Integer.MAX_VALUE;
        // Try all prefix and suffix combinations in O(n^2) time
        for (int prefixEnd = 0; prefixEnd <= n; prefixEnd++) {
            for (int suffixStart = prefixEnd; suffixStart <= n; suffixStart++) {
                // Skip if removing everything
                if (prefixEnd == 0 && suffixStart == n) continue;
                // Calculate cost components
                int onesRemoved = prefixOnes[prefixEnd] + (prefixOnes[n] - prefixOnes[suffixStart]);
                int zerosRemaining = prefixZeros[suffixStart] - prefixZeros[prefixEnd];
                int cost = Math.max(zerosRemaining, onesRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055123
1390055118,unknown,unknown,unknown,"print(1)
print(3)
print(0)",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055118
1390055128,unknown,unknown,unknown,"def min_effort(n, k, a):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j <= i:
                dp[i][j] = dp[i-1][j] + a[i-1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(min_effort(n, k, a))",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055128
1390055113,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        # Remove leading and trailing zeros
        trimmed = s.strip('0')
        if not trimmed:  # If the entire string was zeros
            results.append(0)
            continue
        total_ones = trimmed.count('1')
        min_cost = float('inf')
        left_zeros = 0
        left_ones_removed = 0
        n = len(trimmed)
        # Iterate through possible partitions
        for i in range(n + 1):
            # Remaining zeros after removing left part
            right_zeros = trimmed[i:].count('0')
            # Cost calculation
            cost = max(right_zeros, left_ones_removed)
            min_cost = min(min_cost, cost)
            # Update count of removed ones
            if i < n:
                if trimmed[i] == '1':
                    left_ones_removed += 1
                else:
                    left_zeros += 1
        results.append(min_cost)
    return results
# Reading input
t = int(input().strip())
test_cases = [input().strip() for _ in range(t)]
result = min_decommissioning_cost(test_cases)
# Output results
for res in result:
    print(res)",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055113
1390055115,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055115
1390055116,unknown,unknown,unknown,"def solve():
    T = int(input())
    for _ in range(T):
        s = input()
        n = len(s)
        min_cost = float('inf')
        for i in range(n + 1):
            for j in range(n - i + 1):
                remaining = s[i:n-j]
                idle_count = remaining.count('0')
                removed_count = s[:i].count('1') + s[n-j:].count('1')
                cost = max(idle_count, removed_count)
                min_cost = min(min_cost, cost)
        print(min_cost)
solve()",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055116
1390055104,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055104
1390055109,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055109
1390055111,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [float('inf')] * (k + 1)
    dp[0] = 0
    for x in a:
        new_dp = [float('inf')] * (k + 1)
        for s in range(k + 1):
            new_dp[s] = min(new_dp[s], dp[s] + x + s)
            if s < k:
                new_dp[s + 1] = min(new_dp[s + 1], dp[s])
        dp = new_dp
    print(min(dp))",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055111
1390055103,unknown,unknown,unknown,"from collections import deque
def find_earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove indices that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add index of negative number to the deque
        if arr[i] < 0:
            dq.append(i)
        # Start collecting results when we have a full window
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
# ------------------------
# MAIN DRIVER CODE
# ------------------------
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and window size
    arr = list(map(int, input().split()))  # Input array
    result = find_earliest_faults(arr, k)
    print(*result)",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055103
1390055094,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055094
1390055097,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055097
1390055101,unknown,unknown,unknown,"def earliest_fault_in_batches(arr, k):
    results = []
    n = len(arr)
    # Process each batch of size k
    for i in range(n - k + 1):
        batch = arr[i:i+k]
        # Find earliest fault (negative value) in current batch
        fault_found = False
        for val in batch:
            if val < 0:
                results.append(val)
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process multiple test cases
def solve_test_cases():
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        batch_results = earliest_fault_in_batches(arr, k)
        results.append(batch_results)
    # Print results
    for batch_result in results:
        print(*batch_result)
# Execute program
if __name__ == ""__main__"":
    solve_test_cases()",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055101
1390055090,unknown,unknown,unknown,"function processData(input) {
    let lines = input.trim().split(""\n"");
    let t = parseInt(lines[0]); 
    let index = 1;
    let output = [];
    for (let test = 0; test < t; test++) {
        let [n, k] = lines[index].split("" "").map(Number);
        let arr = lines[index + 1].split("" "").map(Number);
        index += 2; // Move to next test case
        let res = [];
        for(let i = 0; i <= n - k; i++){
            let batch = arr.slice(i,i+k)
            let faulty = false;
            for(let val of batch){
                if(val < 0){
                    res.push(val)
                    faulty = true
                    break;
                }
            }
            if(!faulty) res.push(0)
        }
        output.push(res.join("" ""))        
    }
    console.log(output.join(""\n""));
} 
process.stdin.resume();
process.stdin.setEncoding(""ascii"");
_input = """";
process.stdin.on(""data"", function (input) {
    _input += input;
});
process.stdin.on(""end"", function () {
   processData(_input);
});",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055090
1390055092,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, n, k):
    result = []
    dq = deque()  # Store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process remaining windows
    for i in range(n - k + 1):
        # If deque is not empty, the front of the queue is the earliest negative
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of this window
        if dq and dq[0] == i:
            dq.popleft()
        # Add the next element of the window
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)  # Print space-separated output
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    earliest_faulty_readings(arr, n, k)",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055092
1390055093,unknown,unknown,unknown,"def min_cost(rack):
    n = len(rack)
    return min(max(rack[start:n-end].count('0'), rack[:start].count('1') + rack[n-end:].count('1')) 
              for start in range(n + 1) for end in range(n - start + 1))
T = int(input())
for _ in range(T):
    print(min_cost(input().strip()))",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055093
1390055085,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055085
1390055087,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states , really tough one to solved actually 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i (if possible)
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055087
1390055089,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055089
1390055083,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    min_total_effort = float('inf')
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
    dp[0][0] = 0 
    for i in range(1, n+1):
        current_strength = strengths[i-1]
        for j in range(k+1):
            if dp[i-1][j] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
        for j in range(1, k+1):
            if dp[i-1][j-1] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, strengths)
        results.append(min_effort)
    return results
if __name__ == ""__main__"":
    results = solve_test_cases()
    for result in results:
        print(result)",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055083
1390055075,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    impacts = []
    for i in range(n):
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    impacts.sort(reverse=True)
    to_skip = set(impacts[i][1] for i in range(k))
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            penalty += 1
        else:
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
def main():
    results = solve_test_cases()
    for result in results:
        print(result)
if name == ""main"":
    main()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055075
1390055079,unknown,unknown,unknown,,51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055079
1390055078,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Prefix sums
        vector<int> prefix_1(n + 1, 0);
        vector<int> prefix_0(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
        }
        int total_1 = prefix_1[n];
        int min_cost = n;
        // Try all possible kept substrings [l, r)
        for (int l = 0; l <= n; l++) {
            // Instead of full nested loop, calculate cost directly
            // for r = n (maximum right end possible for fixed l)
            for (int r = l; r <= n; r++) {
                int kept_1 = prefix_1[r] - prefix_1[l];
                int kept_0 = prefix_0[r] - prefix_0[l];
                int removed_1 = total_1 - kept_1;
                int cost = max(removed_1, kept_0);
                if (cost < min_cost) min_cost = cost;
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055078
1390055068,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    active_prefix_sum = [0] * (n + 1)
    idle_suffix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
    for i in range(n-1, -1, -1):
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
    min_cost = float('inf')
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Active servers decommissioned (from start and end)
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
            # Idle servers remaining in the middle
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055068
1390055069,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055069
1390055074,unknown,unknown,unknown,"def solve(n, k, a):
    if k >= n:
        return 0
    mem = {}
    def dfs(i, kl, p):
        if i == n:
            return 0
        st = (i, kl, p)
        if st in mem:
            return mem[st]
        ans = a[i] + p + dfs(i + 1, kl, p)
        if kl > 0:
            ans = min(ans, dfs(i + 1, kl - 1, p + 1))
        mem[st] = ans
        return ans
    return dfs(0, k, 0)
def main():
    t = int(input())
    res = []
    for _ in range(t):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        res.append(solve(n, k, a))
    for x in res:
        print(x)
if __name__ == ""__main__"":
    main()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055074
1390055061,unknown,unknown,unknown,"import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    s = data[ptr]
    ptr += 1
    n = len(s)
    pre = [0]*(n+1)
    for i in range(n):
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
    O = pre[n]
    best = 10**9
    for L in range(n+1):
        if L <= n - O:
            cost = O - (pre[L+O] - pre[L])
        else:
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
        if cost < best:
            best = cost
    res.append(str(best))
sys.stdout.write(""\n"".join(res))",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055061
1390055063,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
void solve() {
    int n, k;
    cin >> n >> k;
    vector<ll> arr(n);
    ll total = 0;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
        total += arr[i];
    }
    vector<ll> benefits(n);
    for (int j = 0; j < n; j++){
        benefits[j] = arr[j] - (n - 1 - j);
    }
    sort(benefits.begin(), benefits.end(), greater<ll>());
    ll best = total;
    ll sumb = 0;
    int m = min(k, n);
    for (int i = 0; i < m; i++){
        if (benefits[i] < 0) {
        }
        sumb += benefits[i];
        int skips = i + 1;
        ll candidate = total - sumb - (skips * (skips - 1LL)) / 2LL;
        best = min(best, candidate);
    }
    cout << best << ""\n"";
}
int main() {
    int t; cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055063
1390055064,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055064
1390055060,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055060
1390055050,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    # Calculate the gain from skipping each firewall
    gains = []
    for i in range(n):
        gain = strengths[i] - (n - i - 1)
        gains.append((gain, i))
    # Sort by gain in descending order
    gains.sort(reverse=True)
    # Select the top k firewalls to skip
    to_skip = set()
    for i in range(min(k, n)):
        if gains[i][0] > 0:  # Only skip if it gives positive gain
            to_skip.add(gains[i][1])
    # Calculate the total effort
    effort = 0
    skipped = 0
    for i in range(n):
        if i in to_skip:
            skipped += 1
        else:
            effort += strengths[i] + skipped
    return effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, strengths))",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055050
1390055053,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    min_total_effort = float('inf')
    for i in range(n + 1):  
        if i + k >= n:  
            effort = sum(strengths[:i])
            min_total_effort = min(min_total_effort, effort)
        else:
            effort_before = sum(strengths[:i])
            remaining = strengths[i+k:]
            effort_after = sum(x + k for x in remaining)
            total_effort = effort_before + effort_after
            min_total_effort = min(min_total_effort, total_effort)
    return min_total_effort
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort(n, k, strengths))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    solve()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055053
1390055059,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.size();
        vector<int> prefix0(n + 1, 0), prefix1(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i + 1] = prefix0[i] + (s[i] == '0');
            prefix1[i + 1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        int low = 0, high = n, ans = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            for (int l = 0; l <= n; l++) {
                int allowed = prefix0[l] + mid;
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                if (r - 1 < l) continue; 
                int r_max = r - 1;
                int onesKept = prefix1[r_max] - prefix1[l];
                if (onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if (feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055059
1390055046,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055046
1390055047,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055047
1390055049,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055049
1390055040,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();  // Number of test cases
        while (t-- > 0) {
            int n = s.nextInt();
            int k = s.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = s.nextInt();
            }
            // Using a queue to track the index of negative numbers
            Queue<Integer> queue = new LinkedList<>();
            int i = 0;
            // Process first window
            for (i = 0; i < k; i++) {
                if (arr[i] < 0) {
                    queue.add(i);
                }
            }
            // Process remaining windows
            for (; i < n; i++) {
                // Print first negative number of previous window
                if (!queue.isEmpty()) {
                    System.out.print(arr[queue.peek()] + "" "");
                } else {
                    System.out.print(""0 "");
                }
                // Remove elements that are out of this window
                while (!queue.isEmpty() && queue.peek() <= i - k) {
                    queue.poll();
                }
                // Add current element if it's negative
                if (arr[i] < 0) {
                    queue.add(i);
                }
            }
            // Print for last window
            if (!queue.isEmpty()) {
                System.out.print(arr[queue.peek()] + "" "");
            } else {
                System.out.print(""0 "");
            }
            System.out.println();
        }
        s.close();
    }
}",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055040
1390055042,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055042
1390055044,unknown,unknown,unknown,"def min_effort_to_breach(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        fw = firewalls[i - 1]
        for j in range(k + 1):
            if j <= i - 1:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + fw + j)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(firewalls, k))",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055044
1390055039,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):  # Iterate through all possible combinations of skipping firewalls
        skipped_count = 0
        current_effort = 0
        skipped_indices = []
        for j in range(n):
            if (i >> j) & 1:  # Check if the j-th firewall is skipped
                skipped_count += 1
                skipped_indices.append(j)
        if skipped_count > k:
            continue
        temp_a = a[:]
        for skipped_index in skipped_indices:
          for l in range(skipped_index +1, n):
            temp_a[l] += 1
        for j in range(n):
            if (i >> j) & 1: #skip the firewall
                continue
            else:
                current_effort += temp_a[j]
        min_effort = min(min_effort, current_effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055039
1390055032,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055032
1390055038,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process the remaining windows
    for i in range(n - k + 1):
        # Append earliest fault in the current window
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of the window
        if dq and dq[0] == i:
            dq.popleft()
        # Add next element (if negative)
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faults(arr, k))",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055038
1390055034,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
import sys
def main():
    T = int(sys.stdin.readline().strip())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        sum_a = sum(a)
        values = [a[i] - (n - i - 1) for i in range(n)]
        values.sort(reverse=True)
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
        max_m = min(k, n)
        max_total = float('-inf')
        for m in range(max_m + 1):
            current = prefix_sum[m] + (m * (m - 1)) // 2
            max_total = max(max_total, current)
        min_effort = sum_a - max_total
        print(min_effort)
if __name__ == ""__main__"":
    main()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055034
1390055027,unknown,unknown,unknown,"print(21)
print(0)",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055027
1390055028,unknown,unknown,unknown,"def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        min_effort = float('inf')
        for i in range(1 << n):
            skipped = []
            remaining = []
            count = 0
            for j in range(n):
                if (i >> j) & 1:
                    skipped.append(j)
                    count += 1
                else:
                    remaining.append(j)
            if count <= k:
                effort = 0
                skipped_count = 0
                for j in range(n):
                    if j in skipped:
                        skipped_count += 1
                    else:
                        effort += a[j] + skipped_count
                min_effort = min(min_effort, effort)
        print(min_effort)
solve()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055028
1390055026,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0 || maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055026
1390055023,unknown,unknown,unknown,"def find_faulty_readings(test_cases):
    for case in test_cases:
        n, k = case[0], case[1]
        readings = case[2]
        result = []
        for i in range(n - k + 1):
            batch = readings[i:i+k]
            fault = next((x for x in batch if x < 0), 0)  # Find the first negative number or 0 if no faults
            result.append(fault)
        # Print the result for each test case in the format requested
        print("" "".join(map(str, result)))
def main():
    t = int(raw_input())  # Number of test cases
    test_cases = []
    for _ in range(t):
        n, k = map(int, raw_input().split())  # Size of array and batch size
        arr = map(int, raw_input().split())   # Array of sensor readings
        test_cases.append((n, k, arr))
    find_faulty_readings(test_cases)
if __name__ == ""__main__"":
    main()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055023
1390055021,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def minimize_cost(t, test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        total_ones = s.count('1')
        if total_ones == 0 or total_ones == n:
            results.append(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
            if max_ones >= required_ones:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        results.append(answer)
    return results
if __name__ == ""__main__"":
    t = int(input())
    test_cases = [input().strip() for _ in range(t)]
    results = minimize_cost(t, test_cases)
    for res in results:
        print(res)",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055021
1390055025,unknown,unknown,unknown,"def min_cost_to_decommission(rack):
    length = len(rack)
    min_cost = float('inf')
    for prefix in range(length + 1):
        for suffix in range(length + 1 - prefix):
            remaining = rack[prefix:length - suffix]
            if not remaining:
                continue
            idle_count = remaining.count('0')
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
            cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def process_cases():
    test_cases = int(input().strip())
    results = []
    for _ in range(test_cases):
        rack = input().strip()
        results.append(str(min_cost_to_decommission(rack)))
    print(""\n"".join(results))
process_cases()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055025
1390055019,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T-- > 0) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        long long sum_a = 0;
        for (int i = 0; i < n; i++) {
            cin >> a[i];
            sum_a += a[i];
        }
        vector<long long> values;
        for (int i = 0; i < n; i++) {
            long long val = a[i] - (n - i - 1LL);
            values.push_back(val);
        }
        sort(values.begin(), values.end(), greater<long long>());
        vector<long long> prefixSum(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefixSum[i] = prefixSum[i - 1] + values[i - 1];
        }
        int max_m = min(k, n);
        long long maxTotal = LLONG_MIN;
        for (int m = 0; m <= max_m; m++) {
            long long current = prefixSum[m] + (m *1LL* (m - 1)) / 2;
            if (current > maxTotal) {
                maxTotal = current;
            }
        }
        long long minEffort = sum_a - maxTotal;
        cout << minEffort << endl;
    }
    return 0;
}",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055019
1390055012,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055012
1390055013,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055013
1390055017,unknown,unknown,unknown,"import sys
input = sys.stdin.read
def minimum_effort(arr, k):
    n = len(arr)
    if k == n:
        return 0
    total_effort = sum(arr)
    min_effort = total_effort
    # Sliding window to calculate the sum of any skipped window of size k
    window_sum = sum(arr[:k])
    for i in range(n - k + 1):
        skipped_effort = total_effort - window_sum + k
        min_effort = min(min_effort, skipped_effort)
        # Slide the window to the right
        if i + k < n:
            window_sum = window_sum - arr[i] + arr[i + k]
    return min_effort
# Efficient Input Handling with ASCII Conversion
data = input().encode('ascii', 'ignore').decode('ascii').strip().split(""\n"")
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n, k = map(int, data[index].split())
    arr = list(map(int, data[index + 1].split()))
    results.append(str(minimum_effort(arr, k)))
    index += 2
# Fast Output
sys.stdout.write(""\n"".join(results) + ""\n"")",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055017
1390055009,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    if k == n:
        print(0)
        continue
    effort_sum = sum(arr)
    for i in range(1, n+1):
        temp = arr[i-1]
        arr[i-1] = 0   
        effort_sum = min(effort_sum, sum(arr[:]) + (1 * (n-i)))
        arr[i-1] = temp 
    print(effort_sum)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055009
1390055010,unknown,unknown,unknown,"def minimize_cost(s):
    total_ones = s.count('1')
    total_zeros = len(s) - total_ones
    low = 0
    high = max(total_ones, total_zeros)
    answer = high  # Initialize with the maximum possible value
    while low <= high:
        mid = (low + high) // 2
        K = total_ones - mid
        # Check if current mid is feasible
        if K <= 0:
            feasible = (total_zeros <= mid)
        else:
            current_0 = 0
            current_1 = 0
            left = 0
            feasible = False
            for right in range(len(s)):
                if s[right] == '0':
                    current_0 += 1
                else:
                    current_1 += 1
                # Move left pointer to ensure current_0 <= mid
                while current_0 > mid:
                    if s[left] == '0':
                        current_0 -= 1
                    else:
                        current_1 -= 1
                    left += 1
                # Check if current window meets the 1's requirement
                if current_1 >= K:
                    feasible = True
                    break
        if feasible:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1
    return answer
T = int(input())
for _ in range(T):
    s = input().strip()
    print(minimize_cost(s))",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055010
1390055011,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        # Remove leading and trailing zeros, they don't contribute to cost
        trimmed = s.strip('0')
        if not trimmed:  # If string becomes empty after trimming
            results.append(0)
            continue
        total_ones = trimmed.count('1')
        min_cost = float('inf')
        # Try removing from both ends
        left_zeros = 0
        left_ones_removed = 0
        n = len(trimmed)
        for i in range(n + 1):
            # Calculate remaining zeros
            right_zeros = trimmed[i:].count('0')
            cost = max(right_zeros, left_ones_removed)
            min_cost = min(min_cost, cost)
            # If not at the end, update counts
            if i < n:
                if trimmed[i] == '1':
                    left_ones_removed += 1
                else:
                    left_zeros += 1
        results.append(min_cost)
    return results
# Reading input
t = int(input().strip())
test_cases = [input().strip() for _ in range(t)]
result = min_decommissioning_cost(test_cases)
# Output results
for res in result:
    print(res)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055011
1390055004,unknown,unknown,unknown,"import sys
from itertools import accumulate
def min_effort(arr, k):
    n = len(arr)
    T = sum(arr)
    A = [arr[i] + (i+1) for i in range(n)]
    A.sort(reverse=True)
    P = [0] + list(accumulate(A))
    m_max = min(k, n)
    best = float('inf')
    for m in range(m_max + 1):
        cost = T + m * n - (m * m - m) // 2 - P[m]
        if cost < best:
            best = cost
    return best
def solve():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    res = []
    for _ in range(t):
        n = int(data[index]); index += 1
        k = int(data[index]); index += 1
        arr = list(map(int, data[index:index+n])); index += n
        res.append(str(min_effort(arr, k)))
    sys.stdout.write(""\n"".join(res))
if __name__ == ""__main__"":
    solve()",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055004
1390055007,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):  
        for j in range(n + 1 - i):  
            if i + j > n:
                continue
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
for result in results:
    print(result)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055007
1390055008,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_zeros = servers.count('0')
        total_ones = n - total_zeros
        prefix_zeros = [0] * (n + 1)
        prefix_ones = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_zeros[i] = prefix_zeros[i - 1] + (servers[i - 1] == '0')
            prefix_ones[i] = prefix_ones[i - 1] + (servers[i - 1] == '1')
        suffix_zeros = [0] * (n + 1)
        suffix_ones = [0] * (n + 1)
        for j in range(1, n + 1):
            suffix_zeros[j] = suffix_zeros[j - 1] + (servers[n - j] == '0')
            suffix_ones[j] = suffix_ones[j - 1] + (servers[n - j] == '1')
        min_cost = float('inf')
        for i in range(n + 1):
            j_max = n - i
            left, right = 0, j_max
            best_j = 0
            best_cost = float('inf')
            while left <= right:
                mid = (left + right) // 2
                remaining_zeros = total_zeros - (prefix_zeros[i] + suffix_zeros[mid])
                decommissioned_ones = prefix_ones[i] + suffix_ones[mid]
                current_cost = max(remaining_zeros, decommissioned_ones)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_j = mid
                elif current_cost == best_cost and mid < best_j:
                    best_j = mid
                if decommissioned_ones < remaining_zeros:
                    left = mid + 1
                else:
                    right = mid - 1
            for dj in [-1, 0, 1]:
                j = best_j + dj
                if 0 <= j <= j_max:
                    remaining_zeros = total_zeros - (prefix_zeros[i] + suffix_zeros[j])
                    decommissioned_ones = prefix_ones[i] + suffix_ones[j]
                    current_cost = max(remaining_zeros, decommissioned_ones)
                    if current_cost < best_cost:
                        best_cost = current_cost
            if best_cost < min_cost:
                min_cost = best_cost
        results.append(min_cost)
    return results
if __name__ == ""__main__"":
    test_cases_count = int(input())
    test_cases = [input().strip() for _ in range(test_cases_count)]
    results = min_decommissioning_cost(test_cases)
    for result in results:
        print(result)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055008
1390055003,unknown,unknown,unknown,"def minimize_effort(n, k, a):
    a.sort(reverse=True)  # Sort firewalls in descending order (strongest first)
    # Total effort without skipping any firewall
    total_effort = sum(a)
    # If we can skip all firewalls, effort becomes 0
    if k == n:
        return 0
    # Pick the strongest `k` firewalls to skip
    skip_total = sum(a[:k])  # Sum of the `k` highest firewalls we skip
    # Calculate penalty for remaining firewalls
    penalty = sum(range(k))  # Sum of first `k` natural numbers (0, 1, 2, ..., k-1)
    # Minimum effort calculation
    return (total_effort - skip_total + penalty)
# Driver Code
T = int(input().strip())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n (firewalls) and k (skips)
    a = list(map(int, input().split()))  # Read firewall strengths
    result = minimize_effort(n, k, a)
    print(result)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055003
1390054999,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054999
1390055000,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    static boolean feasible(int X, int[] onesIndices, int total1) {
        if (X >= total1) return true;
        int j = 0;
        for (int i = 0; i < total1; i++) {
            if (j < i) j = i;
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
                j++;
            }
            int m = j - i; 
            if (m >= total1 - X) return true;
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0) {
            String s = sc.next();
            int n = s.length();
            ArrayList<Integer> onesList = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (s.charAt(i) == '1') {
                    onesList.add(i);
                }
            }
            int total1 = onesList.size();
            if (total1 == 0) {
                System.out.println(0);
                continue;
            }
            int[] onesIndices = new int[total1];
            for (int i = 0; i < total1; i++) {
                onesIndices[i] = onesList.get(i);
            }
            int low = 0, high = total1, ans = high;
            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (feasible(mid, onesIndices, total1)) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055000
1390055002,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055002
1390054990,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054990
1390054992,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i):
            remaining = server_rack[i:n-j]
            idle_remaining = remaining.count('0')
            removed_start = server_rack[:i].count('1')
            removed_end = server_rack[n-j:].count('1')
            active_decommissioned = removed_start + removed_end
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054992
1390054997,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        total_ones = s.count('1')
        total_zeros = s.count('0')
        min_cost = float('inf')
        for i in range(n + 1):  
            for j in range(i, n + 1):  
                remaining_zeros = s[i:j].count('0')
                remaining_ones = s[i:j].count('1')
                removed_ones = total_ones - remaining_ones
                cost = max(remaining_zeros, removed_ones)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input())  
test_cases = [input().strip() for _ in range(T)]
results = min_decommissioning_cost(test_cases)
for result in results:
    print(result)",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054997
1390054987,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;
int solve() {
    string s;
    cin >> s;
    int n = s.length();
    int min_cost = n;
    int total_ones = 0;
    for (char c : s) {
        if (c == '1') {
            total_ones++;
        }
    }
    for (int i = 0; i <= n; ++i) {
        int removed_ones_prefix = 0;
        for (int k = 0; k < i; ++k) {
            if (s[k] == '1') {
                removed_ones_prefix++;
            }
        }
        for (int j = i; j <= n; ++j) {
            int remaining_zeros = 0;
            for (int k = i; k < j; ++k) {
                if (s[k] == '0') {
                    remaining_zeros++;
                }
            }
            int removed_ones_suffix = 0;
            for (int k = j; k < n; ++k) {
                if (s[k] == '1') {
                    removed_ones_suffix++;
                }
            }
            int removed_ones = removed_ones_prefix + removed_ones_suffix;
            min_cost = min(min_cost, max(remaining_zeros, removed_ones));
        }
    }
    return min_cost;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        cout << solve() << endl;
    }
    return 0;
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054987
1390054989,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i):
            remaining = server_rack[i:n-j]
            idle_remaining = remaining.count('0')
            removed_start = server_rack[:i].count('1')
            removed_end = server_rack[n-j:].count('1')
            active_decommissioned = removed_start + removed_end
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054989
1390054986,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;
int findMinimumCost(const string& servers) {
    int n = servers.size();
    // Count total idle and active servers
    int totalIdle = 0;
    for (char c : servers) {
        if (c == '0') totalIdle++;
    }
    int totalActive = n - totalIdle;
    // Precompute prefix counts
    vector<int> prefixActive(n + 1, 0);
    vector<int> prefixIdle(n + 1, 0);
    for (int i = 0; i < n; i++) {
        prefixActive[i + 1] = prefixActive[i] + (servers[i] == '1');
        prefixIdle[i + 1] = prefixIdle[i] + (servers[i] == '0');
    }
    int minCost = INT_MAX;
    // Optimize by using a linear approach instead of nested loops
    // For each possible starting point (front removal ending point)
    for (int start = 0; start <= n; start++) {
        // Calculate the remaining idle servers if we remove from 0 to start-1
        int frontActiveRemoved = prefixActive[start];
        // Binary search or linear scan to find optimal end removal
        // For this problem size, linear scan should be efficient enough
        for (int end = start; end <= n; end++) {
            // Skip if we're not removing anything
            if (start == 0 && end == n) continue;
            int remainingIdle = prefixIdle[end] - prefixIdle[start];
            int endActiveRemoved = totalActive - frontActiveRemoved - (prefixActive[end] - prefixActive[start]);
            int totalActiveRemoved = frontActiveRemoved + endActiveRemoved;
            int cost = max(remainingIdle, totalActiveRemoved);
            minCost = min(minCost, cost);
        }
    }
    return minCost;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int t;
    cin >> t;
    while (t--) {
        string servers;
        cin >> servers;
        cout << findMinimumCost(servers) << ""\n"";
    }
    return 0;
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054986
1390054983,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    # Precompute prefix and suffix counts of '1'
    prefix_ones = [0] * (n + 1)
    suffix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (server_rack[i] == '1')
    for i in range(n - 1, -1, -1):
        suffix_ones[i] = suffix_ones[i + 1] + (server_rack[i] == '1')
    total_ones = prefix_ones[n]  # Total active servers ('1' count)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(i, n + 1):
            idle_remaining = server_rack[i:j].count('0')
            active_decommissioned = total_ones - (prefix_ones[j] - prefix_ones[i])
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
# Input handling
t = int(input().strip())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054983
1390054977,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        # Remove leading and trailing zeros, they don't contribute to cost
        trimmed = s.strip('0')
        if not trimmed:  # If string becomes empty after trimming
            results.append(0)
            continue
        total_ones = trimmed.count('1')
        min_cost = float('inf')
        # Try removing from both ends
        left_zeros = 0
        left_ones_removed = 0
        n = len(trimmed)
        for i in range(n + 1):
            # Calculate remaining zeros
            right_zeros = trimmed[i:].count('0')
            cost = max(right_zeros, left_ones_removed)
            min_cost = min(min_cost, cost)
            # If not at the end, update counts
            if i < n:
                if trimmed[i] == '1':
                    left_ones_removed += 1
                else:
                    left_zeros += 1
        results.append(min_cost)
    return results
# Reading input
t = int(input().strip())
test_cases = [input().strip() for _ in range(t)]
result = min_decommissioning_cost(test_cases)
# Output results
for res in result:
    print(res)",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054977
1390054979,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Size of the array
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, n, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
    public static List<Integer> findEarliestFaults(int[] arr, int n, int k) {
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i <= n - k; i++) {
            boolean found = false;
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    result.add(arr[j]);  // First negative number in batch
                    found = true;
                    break;
                }
            }
            if (!found) {
                result.add(0); // If no negative number found
            }
        }
        return result;
    }
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054979
1390054982,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054982
1390054972,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        for (int i = 0; i < t; i++) {
            String servers = scanner.nextLine();
            int minCost = minimizeServerCost(servers);
            System.out.println(minCost);
        }
        scanner.close();
    }
    public static int minimizeServerCost(String servers) {
        int n = servers.length();
        int minCost = Integer.MAX_VALUE;
        for (int prefixLength = 0; prefixLength <= n; prefixLength++) {
            for (int suffixLength = 0; suffixLength <= n - prefixLength; suffixLength++) {
                if (prefixLength + suffixLength == n) continue;
                String remaining = servers.substring(prefixLength, n - suffixLength);
                int activeServersRemoved = 0;
                for (int i = 0; i < prefixLength; i++) {
                    if (servers.charAt(i) == '1') activeServersRemoved++;
                }
                for (int i = n - suffixLength; i < n; i++) {
                    if (servers.charAt(i) == '1') activeServersRemoved++;
                }
                int idleServersRemaining = 0;
                for (int i = 0; i < remaining.length(); i++) {
                    if (remaining.charAt(i) == '0') idleServersRemaining++;
                }
                int cost = Math.max(idleServersRemaining, activeServersRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054972
1390054974,unknown,unknown,unknown,"def min_effort(strengths, n, k):
    if k >= n:
        return 0
    dp = {}
    def solve(idx, skips_left, extra):
        if idx == n:
            return 0
        if (idx, skips_left, extra) in dp:
            return dp[(idx, skips_left, extra)]
        op1 = float('inf')
        if skips_left > 0:
            op1 = solve(idx + 1, skips_left - 1, extra + 1)
        op2 = strengths[idx] + extra + solve(idx + 1, skips_left, extra)
        dp[(idx, skips_left, extra)] = min(op1, op2)
        return dp[(idx, skips_left, extra)]
    return solve(0, k, 0)
def main():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort(strengths, n, k))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054974
1390054976,unknown,unknown,unknown,"def min_cost_server_optimization(server_rack):
    n = len(server_rack)
    prefix_active = [0] * (n + 1)
    prefix_idle = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (server_rack[i] == '1')
        prefix_idle[i + 1] = prefix_idle[i] + (server_rack[i] == '0')
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = float('inf')
    for i in range(n + 1): 
        active_removed_prefix = prefix_active[i]
        for j in range(n + 1 - i): 
            if i + j == n:  
                continue
            active_removed_suffix = total_active - prefix_active[n - j]
            active_removed = active_removed_prefix + active_removed_suffix
            idle_remaining = total_idle - (prefix_idle[i] + (total_idle - prefix_idle[n - j]))
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
import sys
input = sys.stdin.readline
def main():
    t = int(input().strip())
    for _ in range(t):
        server_rack = input().strip()
        result = min_cost_server_optimization(server_rack)
        print(result)
if __name__ == ""__main__"":
    main()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054976
1390054965,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054965
1390054968,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    effort += a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054968
1390054971,unknown,unknown,unknown,"def min_cost(server_str):
    n = len(server_str)
    prefix_1 = [0] * (n + 1)  
    prefix_0 = [0] * (n + 1)  
    for i in range(n):
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
    total_1 = prefix_1[n]
    total_0 = prefix_0[n]
    min_cost = float('inf')
    for l in range(n + 1):
        for r in range(n - l + 1):
            left = l
            right = n - r
            remaining_0 = prefix_0[right] - prefix_0[left]
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
            cost = max(remaining_0, removed_1)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    server_str = input().strip()
    print(min_cost(server_str))",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054971
1390054961,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void earliest_faulty_readings(int arr[], int n, int k) {
    int i;
    int front = 0, rear = 0;  // Deque implemented using an array
    int deque[n]; // Stores indices of negative numbers
    // Process the first window
    for (i = 0; i < k; i++) {
        if (arr[i] < 0)
            deque[rear++] = i;
    }
    // Process rest of the windows
    for (i = k; i <= n; i++) {
        // Print the first negative number in the current window
        if (front < rear)
            printf(""%d "", arr[deque[front]]);
        else
            printf(""0 "");
        // Remove elements not in this window
        while (front < rear && deque[front] < i - k + 1)
            front++;
        // Add the new element if negative
        if (i < n && arr[i] < 0)
            deque[rear++] = i;
    }
    printf(""\n"");
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++)
            scanf(""%d"", &arr[i]);
        earliest_faulty_readings(arr, n, k);
    }
    return 0;
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054961
1390054962,unknown,unknown,unknown,"def main():
    import sys
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054962
1390054963,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054963
1390054954,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def minimize_cost(t, test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        total_ones = s.count('1')
        if total_ones == 0 or total_ones == n:
            results.append(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
            if max_ones >= required_ones:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        results.append(answer)
    return results
if __name__ == ""__main__"":
    t = int(input())
    test_cases = [input().strip() for _ in range(t)]
    results = minimize_cost(t, test_cases)
    for res in results:
        print(res)",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054954
1390054957,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        result = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            earliest_fault = 0
            for num in batch:
                if num < 0:
                    earliest_fault = num
                    break
            result.append(earliest_fault)
        results.append(result)
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute results
results = earliest_faulty_readings(test_cases)
# Output results
for result in results:
    print(' '.join(map(str, result)) + ' ')",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054957
1390054960,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054960
1390054952,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054952
1390054953,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    strengths.sort(reverse=True)
    return sum(strengths[k:])
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, strengths))",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054953
1390054949,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054949
1390054948,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (servers[i] == '1')
    total_ones = prefix_ones[n]
    min_cost = total_ones  
    for end in range(n + 1):
        active_removed = total_ones - prefix_ones[end]
        idle_remaining = end - prefix_ones[end]
        min_cost = min(min_cost, max(active_removed, idle_remaining))
    return min_cost
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054948
1390054943,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    # Calculate the effort for all possible combinations of skipping firewalls
    efforts = []
    for mask in range(1 << n):
        if bin(mask).count('1') <= k:
            skipped = [i for i in range(n) if mask & (1 << i)]
            extra = 0
            total = 0
            for i in range(n):
                if i in skipped:
                    extra += 1
                else:
                    total += strengths[i] + extra
            efforts.append(total)
    return min(efforts)
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, strengths))",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054943
1390054946,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove elements that are out of the current batch window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it's faulty (negative)
        if arr[i] < 0:
            dq.append(i)
        # Determine the earliest faulty reading for the current batch
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases(test_cases):
    results = []
    for size, k, arr in test_cases:
        results.append(earliest_faulty_readings(arr, k))
    return results
# Read input
if __name__ == ""__main__"":
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        size, k = map(int, input().split())
        arr = list(map(int, input().split()))
        test_cases.append((size, k, arr))
    # Process and print results
    results = process_test_cases(test_cases)
    for res in results:
        print("" "".join(map(str, res)))",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054946
1390054942,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054942
1390054939,unknown,unknown,unknown,,58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054939
1390054937,unknown,unknown,unknown,"import sys  
from itertools import accumulate  
def min_effort(arr, k):  
    n = len(arr)  
    T = sum(arr)  
    A = [arr[i] + (i + 1) for i in range(n)]  
    A.sort(reverse=True)  
    P = [0] + list(accumulate(A))  
    m_max = min(k, n)  
    best = float('inf')  
    for m in range(m_max + 1):  
        cost = T + m * n - (m * m - m) // 2 - P[m]  
        if cost < best:  
            best = cost  
    return best  
def solve():  
    data = sys.stdin.read().strip().split()  
    if not data:  
        return  
    t = int(data[0])  
    index = 1  
    res = []  
    for _ in range(t):  
        n = int(data[index])  
        index += 1  
        k = int(data[index])  
        index += 1  
        arr = list(map(int, data[index:index + n]))  
        index += n  
        res.append(str(min_effort(arr, k)))  
    sys.stdout.write(""\n"".join(res) + ""\n"")  
if __name__ == ""__main__"":  
    solve()  ",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054937
1390054940,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054940
1390054929,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054929
1390054932,unknown,unknown,unknown,"import sys
def main():
    T = int(sys.stdin.readline().strip())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        sum_a = sum(a)
        values = [a[i] - (n - i - 1) for i in range(n)]
        values.sort(reverse=True)
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
        maximum_m = min(k, n)
        maximum_total = float('-inf')
        for m in range(maximum_m + 1):
            current = prefix_sum[m] + (m * (m - 1)) // 2
            maximum_total = max(maximum_total, current)
        minimum_effort = sum_a - maximum_total
        print(minimum_effort)
if __name__ == ""__main__"":
    main()",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054932
1390054936,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054936
1390054927,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_count = 0
            for char in remaining:
                if char == '0':
                    idle_count += 1
            active_removed = 0
            for k in range(i):
                if s[k] == '1':
                    active_removed += 1
            for k in range(n - j, n):
                if s[k] == '1':
                    active_removed += 1
            ans = min(ans, max(idle_count, active_removed))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054927
1390054922,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        total_ones = s.count('1')
        total_zeros = s.count('0')
        min_cost = float('inf')
        for i in range(n + 1):  
            for j in range(i, n + 1):  
                remaining_zeros = s[i:j].count('0')
                remaining_ones = s[i:j].count('1')
                removed_ones = total_ones - remaining_ones
                cost = max(remaining_zeros, removed_ones)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input())  
test_cases = [input().strip() for _ in range(T)]
results = min_decommissioning_cost(test_cases)
for result in results:
    print(result)",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054922
1390054923,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        benefits.sort(reverse=True)
        skipped = [False] * n
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        total_effort = 0
        penalty = 0  
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
threading.Thread(target=main).start()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054923
1390054924,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;
int solve(vector<int>&arr, int i, int skip, int inc,vector<vector<int>>&dp) {
    int n = arr.size();
    if(i==n){
        return 0;
    }
    if(dp[i][skip]!=-1)return dp[i][skip];
    //skip
    int ans = INT_MAX;
    if(skip>0) {
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
    }
    //no skip
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc,dp));
    return dp[i][skip]= ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--) {
        int n,skip;
        cin>>n>>skip;
        vector<int>arr;
        vector<vector<int>>dp(n,vector<int>(skip+1,-1));
        while(n--) {
            int a;
            cin>>a;
            arr.push_back(a);
        }
        cout<<solve(arr,0,skip,0,dp)<<endl;
    }
    return 0;
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054924
1390054917,unknown,unknown,unknown,"import java.io.*;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054917
1390054918,unknown,unknown,unknown,"def min_cost_to_decommission(rack):
    length = len(rack)
    min_cost = float('inf')
    for prefix in range(length + 1):
        for suffix in range(length + 1 - prefix):
            remaining = rack[prefix:length - suffix]
            if not remaining:
                continue
            idle_count = remaining.count('0')
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
            cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost if min_cost != float('inf') else 0
def process_cases():
    test_cases = int(input().strip())
    results = []
    for _ in range(test_cases):
        rack = input().strip()
        results.append(min_cost_to_decommission(rack))
    print(""\n"".join(map(str, results)))
process_cases()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054918
1390054921,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054921
1390054911,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            System.out.println(minEffort(n, k, a));
        }
        sc.close();
    }
    static int minEffort(int n, int k, int[] a) {
        int[] curr = new int[k + 1];
        int[] next = new int[k + 1];
        for (int i = n - 1; i >= 0; i--) {
            for (int skip = 0; skip <= k; skip++) {
                int take = a[i] + skip;
                if (take < 0) take = Integer.MAX_VALUE; 
                else if (i < n - 1) {
                    if (take <= Integer.MAX_VALUE - next[skip])
                        take += next[skip];
                    else
                        take = Integer.MAX_VALUE;
                }
                int leave = Integer.MAX_VALUE;
                if (skip < k) leave = next[skip + 1];
                curr[skip] = Math.min(take, leave);
            }
            int[] temp = next;
            next = curr;
            curr = temp;
        }
        return next[0];
    }
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054911
1390054913,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;
int findMinimumCost(const string& servers) {
    int n = servers.size();
    // Precompute prefix and suffix counts of active servers (1's)
    vector<int> prefixActive(n + 1, 0);
    vector<int> suffixActive(n + 1, 0);
    for (int i = 0; i < n; i++) {
        prefixActive[i + 1] = prefixActive[i] + (servers[i] == '1');
    }
    for (int i = n - 1; i >= 0; i--) {
        suffixActive[i] = suffixActive[i + 1] + (servers[i] == '1');
    }
    int minCost = INT_MAX;
    int totalActive = prefixActive[n];
    // Try all valid combinations of front and end removals
    for (int frontRemove = 0; frontRemove <= n; frontRemove++) {
        for (int endRemove = 0; endRemove <= n - frontRemove; endRemove++) {
            // Skip if we're not removing anything
            if (frontRemove == 0 && endRemove == 0) continue;
            // Calculate remaining length
            int remainingLength = n - frontRemove - endRemove;
            // Calculate active servers removed
            int activeRemoved = prefixActive[frontRemove] + suffixActive[n - endRemove];
            // Calculate idle servers remaining
            int totalRemaining = remainingLength;
            int activeRemaining = totalActive - activeRemoved;
            int idleRemaining = totalRemaining - activeRemaining;
            // Calculate cost
            int cost = max(idleRemaining, activeRemoved);
            // Update minimum cost
            minCost = min(minCost, cost);
        }
    }
    return minCost;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        string servers;
        cin >> servers;
        cout << findMinimumCost(servers) << endl;
    }
    return 0;
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054913
1390054914,unknown,unknown,unknown,"import sys, bisect
def solve():
    d = sys.stdin.read().split()
    if not d:
        return
    t = int(d[0])
    idx = 1
    r = []
    for _ in range(t):
        s = d[idx]
        idx += 1
        n = len(s)
        p1 = [0] * (n + 1)
        p0 = [0] * (n + 1)
        for i in range(n):
            p1[i + 1] = p1[i] + (s[i] == '1')
            p0[i + 1] = p0[i] + (s[i] == '0')
        zt = p0[n]
        ot = p1[n]
        s1 = [0] * (n + 1)
        s0 = [0] * (n + 1)
        for j in range(n):
            s1[j + 1] = s1[j] + (s[n - 1 - j] == '1')
            s0[j + 1] = s0[j] + (s[n - 1 - j] == '0')
        def chk(x):
            for i in range(n + 1):
                if p1[i] > x:
                    break
                as1 = x - p1[i]
                jmx = bisect.bisect_right(s1, as1) - 1
                nd = zt - x - p0[i]
                jmn = 0 if nd <= 0 else bisect.bisect_left(s0, nd)
                if jmn <= jmx and jmn <= n - i:
                    return True
            return False
        l, h = 0, max(zt, ot)
        ans = h
        while l <= h:
            m = (l + h) // 2
            if chk(m):
                ans = m
                h = m - 1
            else:
                l = m + 1
        r.append(str(ans))
    sys.stdout.write(""\n"".join(r))
if __name__ == '__main__':
    solve()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054914
1390054910,unknown,unknown,unknown,"def find_earliest_faults(n, k, arr):
    if n < k or n < 1 or k < 1:
        return []
    result = []
    for i in range(0, n - k + 1):
        batch = arr[i:i+k]
        earliest_fault = 0
        for num in batch:
            if num < 0:
                earliest_fault = num
                break
        result.append(earliest_fault)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = find_earliest_faults(n, k, arr)
    print(*result)",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054910
1390054903,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054903
1390054904,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054904
1390054907,unknown,unknown,unknown,"def minimum_cost(T, test_cases):
    results = []
    for binary_string in test_cases:
        n = len(binary_string)
        left_zeros = [0] * (n + 1)
        right_ones = [0] * (n + 1)
        # Count zeros from the left
        for i in range(1, n + 1):
            left_zeros[i] = left_zeros[i - 1] + (1 if binary_string[i - 1] == '0' else 0)
        # Count ones from the right
        for i in range(n - 1, -1, -1):
            right_ones[i] = right_ones[i + 1] + (1 if binary_string[i] == '1' else 0)
        # Calculate the minimum cost
        min_cost = float('inf')
        for i in range(n + 1):
            # Cost is max of idle servers left and active servers removed
            cost = max(left_zeros[i], right_ones[i])
            min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
# Input
T = 3
test_cases = [
    ""101110110"",      # Binary string for Test Case 1
    ""1001001001001"",  # Binary string for Test Case 2
    ""0000111111""      # Binary string for Test Case 3
]
# Running the function
results = minimum_cost(T, test_cases)
# Output the results
for res in results:
    print(res)",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054907
1390054900,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                maxTotal = Math.max(maxTotal, current);
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054900
1390054901,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054901
1390054898,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054898
1390054894,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054894
1390054895,unknown,unknown,unknown,"def optimize_server_rack(rack):
    n = len(rack)
    # Build prefix sums for O(1) access
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (rack[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (rack[i] == '0')
    min_cost = float('inf')
    # Insight: For a fixed left cut, the cost function with respect to right cut
    # is monotonically decreasing then increasing (or just monotonic)
    # So for each left cut, we can find optimal right cut in O(log n) or linear time
    for left in range(n + 1):
        # Binary search would take O(log n) time here, but since we already process n left cuts,
        # the total complexity remains O(n^2) in worst case
        # Let's use faster heuristic approach for large inputs
        # Try all possible right cuts for this left cut
        for right in range(n + 1 - left):
            # Calculate cost
            active_removed = active_prefix[left] + (active_prefix[n] - active_prefix[n - right])
            idle_remaining = idle_prefix[n - right] - idle_prefix[left]
            cost = max(active_removed, idle_remaining)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input())
    for _ in range(t):
        rack = input()
        print(optimize_server_rack(rack))
if __name__ == ""__main__"":
    main()",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054895
1390054897,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054897
1390054893,unknown,unknown,unknown,"def solve():
    server_rack = input()
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining_rack = server_rack[i:n-j]
            remaining_zeros = remaining_rack.count('0')
            removed_ones = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            cost = max(remaining_zeros, removed_ones)
            min_cost = min(min_cost, cost)
    print(min_cost)
T = int(input())
for _ in range(T):
    solve()",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054893
1390054890,unknown,unknown,unknown,"import sys, bisect
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
out = []
for _ in range(t):
    s = data[ptr]
    ptr += 1
    n = len(s)
    pos = []
    for i,ch in enumerate(s):
        if ch=='1':
            pos.append(i)
    tot = len(pos)
    if tot==0:
        out.append(""1"")
        continue
    A = [pos[i]-i for i in range(tot)]
    lo, hi = 0, tot
    def feas(C):
        req = tot - C
        for i in range(tot):
            lim = C + (pos[i]-i)
            j = bisect.bisect_right(A, lim) - 1
            if j < i: continue
            if j - i + 1 >= req:
                return True
        return False
    while lo < hi:
        mid = (lo+hi)//2
        if feas(mid):
            hi = mid
        else:
            lo = mid+1
    out.append(str(lo))
sys.stdout.write(""\n"".join(out))",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054890
1390054891,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054891
1390054892,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054892
1390054886,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int maxOnesWithAtMostKZeros(const string &s, int k) {
    int left = 0, zeros = 0, maxOnes = 0, n = s.length();
    for (int right = 0; right < n; right++) {
        if (s[right] == '0') zeros++;
        while (zeros > k) {
            if (s[left] == '0') zeros--;
            left++;
        }
        maxOnes = max(maxOnes, (right - left + 1) - zeros);
    }
    return maxOnes;
}
void solve() {
    string s;
    cin >> s;
    int n = s.length(), totalOnes = 0, maxConsecutiveOnes = 0, currentConsecutiveOnes = 0;
    for (char c : s) {
        if (c == '1') {
            currentConsecutiveOnes++;
            maxConsecutiveOnes = max(maxConsecutiveOnes, currentConsecutiveOnes);
            totalOnes++;
        } else {
            currentConsecutiveOnes = 0;
        }
    }
    if (totalOnes == 0 || maxConsecutiveOnes == totalOnes) {
        cout << 0 << endl;
        return;
    }
    int totalZeros = n - totalOnes, low = 0, high = max(totalOnes, totalZeros), answer = high;
    while (low <= high) {
        int mid = (low + high) / 2, requiredOnes = max(0, totalOnes - mid);
        if (requiredOnes == 0) {
            answer = mid;
            high = mid - 1;
            continue;
        }
        if (maxOnesWithAtMostKZeros(s, mid) >= requiredOnes) {
            answer = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    cout << answer << endl;
}
int main() {
    int t;
    cin >> t;
    while (t--) solve();
    return 0;
}",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054886
1390054887,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054887
1390054888,unknown,unknown,unknown,"def calculate_min_effort(num_firewalls, max_skips, firewall_strengths):
    if max_skips >= num_firewalls:
        return 0
    skip_impacts = []
    for i in range(num_firewalls):
        skip_impact = firewall_strengths[i] - (num_firewalls - i - 1)
        skip_impacts.append((skip_impact, i))
    skip_impacts.sort(reverse=True)
    firewalls_to_skip = set(skip_impacts[i][1] for i in range(max_skips))
    total_effort = 0
    penalty = 0
    for i in range(num_firewalls):
        if i in firewalls_to_skip:
            penalty += 1
        else:
            total_effort += firewall_strengths[i] + penalty
    return total_effort
def process_test_cases():
    num_test_cases = int(input())
    results = []
    for _ in range(num_test_cases):
        num_firewalls, max_skips = map(int, input().split())
        firewall_strengths = list(map(int, input().split()))
        results.append(calculate_min_effort(num_firewalls, max_skips, firewall_strengths))
    return results
def main():
    results = process_test_cases()
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054888
1390054878,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054878
1390054883,unknown,unknown,unknown,"def min_effort_to_breach(arr, k):
    n = len(arr)
    if k >= n:
        return 0
    min_effort = float('inf')
    effective_costs = []
    for i in range(n):
        skip_penalty = n - i - 1
        effective_cost = arr[i] - skip_penalty
        effective_costs.append((effective_cost, i))
    effective_costs.sort(reverse=True)
    skipped = [False] * n
    skips_used = 0
    for cost, idx in effective_costs:
        if skips_used < k and cost > 0:
            skipped[idx] = True
            skips_used += 1
    total_effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            total_effort += arr[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = min_effort_to_breach(arr, k)
        results.append(result)
    for result in results:
        print(result)
if __name__ == ""__main__"":
    solve_test_cases()",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054883
1390054881,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); 
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054881
1390054874,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054874
1390054871,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054871
1390054872,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054872
1390054873,unknown,unknown,unknown,"def min_cost_server_optimization(server_rack):
    n = len(server_rack)
    total_active = server_rack.count('1')
    total_idle = server_rack.count('0')
    min_cost = float('inf')
    for prefix_len in range(n + 1):
        prefix_active = server_rack[:prefix_len].count('1')
        prefix_idle = prefix_len - prefix_active
        for suffix_len in range(n + 1 - prefix_len):
            if prefix_len + suffix_len == n:
                continue  
            suffix_active = server_rack[n-suffix_len:].count('1')
            suffix_idle = suffix_len - suffix_active
            active_removed = prefix_active + suffix_active
            idle_removed = prefix_idle + suffix_idle
            remaining_active = total_active - active_removed
            remaining_idle = total_idle - idle_removed
            cost = max(remaining_idle, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_rack = input().strip()
        result = min_cost_server_optimization(server_rack)
        print(result)
if __name__ == ""__main__"":
    main()",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054873
1390054870,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            String servers = sc.next();
            int n = servers.length();
            int total0 = 0;
            for (int i = 0; i < n; i++) {
                if (servers.charAt(i) == '0') {
                    total0++;
                }
            }
            int total1 = n - total0;
            int[] prefix0 = new int[n + 1], prefix1 = new int[n + 1];
            for (int i = 1; i <= n; i++) {
                prefix0[i] = prefix0[i - 1] + (servers.charAt(i - 1) == '0' ? 1 : 0);
                prefix1[i] = prefix1[i - 1] + (servers.charAt(i - 1) == '1' ? 1 : 0);
            }
            int[] suffix0 = new int[n + 1], suffix1 = new int[n + 1];
            for (int j = 1; j <= n; j++) {
                suffix0[j] = suffix0[j - 1] + (servers.charAt(n - j) == '0' ? 1 : 0);
                suffix1[j] = suffix1[j - 1] + (servers.charAt(n - j) == '1' ? 1 : 0);
            }
            int minCost = Integer.MAX_VALUE;
            for (int i = 0; i <= n; i++) {
                int jMax = n - i;
                int left = 0, right = jMax;
                int bestJ = 0, bestCost = Integer.MAX_VALUE;
                while (left <= right) {
                    int mid = (left + right) / 2;
                    int remaining0 = total0 - (prefix0[i] + suffix0[mid]);
                    int decommissioned1 = prefix1[i] + suffix1[mid];
                    int currentCost = Math.max(remaining0, decommissioned1);
                    if (currentCost < bestCost) {
                        bestCost = currentCost;
                        bestJ = mid;
                    } else if (currentCost == bestCost && mid < bestJ) {
                        bestJ = mid;
                    }
                    if (decommissioned1 < remaining0) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                for (int dj = -1; dj <= 1; dj++) {
                    int j = bestJ + dj;
                    if (j >= 0 && j <= jMax) {
                        int remaining0 = total0 - (prefix0[i] + suffix0[j]);
                        int decommissioned1 = prefix1[i] + suffix1[j];
                        int currentCost = Math.max(remaining0, decommissioned1);
                        bestCost = Math.min(bestCost, currentCost);
                    }
                }
                minCost = Math.min(minCost, bestCost);
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054870
1390054860,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
    public static void main(String[] args) {
        import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054860
1390054856,unknown,unknown,unknown,"def bf(arr, k):
    if k >= len(arr):
        return 0  
    arr.sort(reverse=True)  
    rem = arr[k:]
    return sum(rem)+1
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(bf(arr, k))",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054856
1390054857,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommissioning {
    public static int minDecommissioningCost(String serverRack) {
        int firstOne = serverRack.indexOf('1');
        int lastOne = serverRack.lastIndexOf('1');
        // If there are no active servers (all 0s), cost is 0
        if (firstOne == -1) {
            return 0;
        }
        // Extract the core segment containing all necessary servers
        String coreSegment = serverRack.substring(firstOne, lastOne + 1);
        // Count remaining idle servers (0s)
        int remainingIdle = (int) coreSegment.chars().filter(ch -> ch == '0').count();
        // Count removed active servers (1s) from the prefix and suffix
        int removedActive = (int) serverRack.substring(0, firstOne).chars().filter(ch -> ch == '1').count() +
                            (int) serverRack.substring(lastOne + 1).chars().filter(ch -> ch == '1').count();
        // Return the minimum cost
        return Math.max(remainingIdle, removedActive);
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // Number of test cases
        scanner.nextLine(); // Consume the newline
        while (T-- > 0) {
            String serverRack = scanner.nextLine();
            System.out.println(minDecommissioningCost(serverRack));
        }
        scanner.close();
    }
}",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054857
1390054858,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    impacts = []
    for i in range(n):
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    impacts.sort(reverse=True)
    to_skip = set(impacts[i][1] for i in range(k))
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            penalty += 1
        else:
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
def main():
    results = solve_test_cases()
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054858
1390054855,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054855
1390054849,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    memo = {}    
    def solve(idx, skipped):
        if idx == n:
            return 0
        if (idx, skipped) in memo:
            return memo[(idx, skipped)]
        skip_effort = float('inf')
        if skipped < k:
            skip_effort = solve(idx + 1, skipped + 1)
        dont_skip_effort = (strengths[idx] + skipped) + solve(idx + 1, skipped)
        result = min(skip_effort, dont_skip_effort)
        memo[(idx, skipped)] = result
        return result
    return solve(0, 0)
def solve_test_cases():
    t = int(input()) 
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, strengths)
        results.append(min_effort)
    return results
if __name__ == ""__main__"":
    results = solve_test_cases()
    for result in results:
        print(result)",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054849
1390054848,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} #include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} ",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054848
1390054854,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int t = input.nextInt();  // Number of test cases
        while (t-- > 0) {
            int N = input.nextInt();  // Array size
            int K = input.nextInt();  // Batch size
            int[] arr = new int[N];
            for (int i = 0; i < N; i++) {
                arr[i] = input.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, K);
            // Print the result for this test case
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        input.close();
    }
    public static List<Integer> findEarliestFaults(int[] arr, int K) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();  // Stores indices of negative numbers
        int n = arr.length;
        // Process first window of size K
        for (int i = 0; i < K; i++) {
            if (arr[i] < 0) {
                deque.addLast(i);
            }
        }
        // Process remaining elements
        for (int i = K; i <= n; i++) {
            // If deque is not empty, the first element is the earliest fault
            if (!deque.isEmpty()) {
                result.add(arr[deque.peekFirst()]);
            } else {
                result.add(0);
            }
            // Remove elements that are out of the current window
            if (!deque.isEmpty() && deque.peekFirst() <= i - K) {
                deque.pollFirst();
            }
            // Add next element (if negative)
            if (i < n && arr[i] < 0) {
                deque.addLast(i);
            }
        }
        return result;
    }
}",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054854
1390054845,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054845
1390054846,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054846
1390054847,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i):
            remaining = server_rack[i:n-j]
            idle_remaining = remaining.count('0')
            removed_start = server_rack[:i].count('1')
            removed_end = server_rack[n-j:].count('1')
            active_decommissioned = removed_start + removed_end
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054847
1390054840,unknown,unknown,unknown,"def min_cost_decommissioning(rack):
    first_active = rack.find('1')
    last_active = rack.rfind('1')
    if first_active == -1:
        return 0  # No active servers
    idle_servers = rack[first_active:last_active + 1].count('0')
    active_servers_removed = first_active + (len(rack) - last_active - 1)
    return max(idle_servers, active_servers_removed)
T = int(input().strip())
for _ in range(T):
    rack = input().strip()
    print(min_cost_decommissioning(rack))",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054840
1390054843,unknown,unknown,unknown,"def min_cost_to_decommission(rack):
    length = len(rack)
    min_cost = float('inf')
    for prefix in range(length + 1):
        for suffix in range(length + 1 - prefix):
            remaining = rack[prefix:length - suffix]
            if not remaining:
                continue
            idle_count = remaining.count('0')
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
            cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def process_cases():
    test_cases = int(input().strip())
    results = []
    for _ in range(test_cases):
        rack = input().strip()
        results.append(min_cost_to_decommission(rack))
    print(""\n"".join(map(str, results)))
process_cases()",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054843
1390054839,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); 
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054839
1390054832,unknown,unknown,unknown,"#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    
    return 0;
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054832
1390054833,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def main():
    T = int(input())
    for _ in range(T):
        s = input().strip()
        n = len(s)
        total_ones = s.count('1')
        # Calculate max consecutive ones
        max_consecutive_ones = 0
        current = 0
        for c in s:
            if c == '1':
                current += 1
                max_consecutive_ones = max(max_consecutive_ones, current)
            else:
                current = 0
        if total_ones == 0 or total_ones == max_consecutive_ones:
            print(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
            if max_ones >= required_ones:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        print(answer)
if __name__ == ""__main__"":
    main()def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def main():
    T = int(input())
    for _ in range(T):
        s = input().strip()
        n = len(s)
        total_ones = s.count('1')
        # Calculate max consecutive ones
        max_consecutive_ones = 0
        current = 0
        for c in s:
            if c == '1':
                current += 1
                max_consecutive_ones = max(max_consecutive_ones, current)
            else:
                current = 0
        if total_ones == 0 or total_ones == max_consecutive_ones:
            print(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054833
1390054838,unknown,unknown,unknown,"def find_earliest_faults(n, k, arr):
    result = []
    for i in range(0, len(arr) - k + 1):
        batch = arr[i:i+k]
        earliest_fault = 0
        for num in batch:
            if num < 0:
                earliest_fault = num
                break
        result.append(earliest_fault)
    return result
def process_test_cases():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = find_earliest_faults(n, k, arr)
        results.append(result)
    for result in results:
        print(*result)
test_cases = [
    (5, 2, [-8, 2, 3, -6, 10]),
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
]
for n, k, arr in test_cases:
    result = find_earliest_faults(n, k, arr)
    print(*result)",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054838
1390054826,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> strengths(n);
        for (int i = 0; i < n; i++) {
            cin >> strengths[i];
        }
        int min_effort = INT_MAX;
        for (int start_pos = 0; start_pos <= n; start_pos++) {
            int effort = 0;
            vector<int> current_strengths = strengths; 
            vector<bool> skip(n, false);
            for (int i = start_pos; i < min(start_pos + k, n); i++) {
                skip[i] = true;
            }
            int skipped_count = 0;
            for (int i = 0; i < n; i++) {
                if (skip[i]) {
                    skipped_count++;
                } else {
                    current_strengths[i] += skipped_count; 
                    effort += current_strengths[i];
                }
            }
            min_effort = min(min_effort, effort);
        }
        cout << min_effort << endl;
    }
    return 0;
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054826
1390054828,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} 3rd",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054828
1390054829,unknown,unknown,unknown,"import sys
input = sys.stdin.read
def minimum_effort(arr, k):
    n = len(arr)
    if k == n:
        return 0
    total_effort = sum(arr)
    min_effort = total_effort
    # Sliding window to calculate the sum of any skipped window of size k
    window_sum = sum(arr[:k])
    for i in range(n - k + 1):
        skipped_effort = total_effort - window_sum + k
        min_effort = min(min_effort, skipped_effort)
        # Slide the window to the right
        if i + k < n:
            window_sum = window_sum - arr[i] + arr[i + k]
    return min_effort
# Efficient Input Handling with ASCII Conversion
data = input().encode('ascii', 'ignore').decode('ascii').strip().split(""\n"")
t = int(data[0])
index = 1
results = []
for _ in range(t):
    n, k = map(int, data[index].split())
    arr = list(map(int, data[index + 1].split()))
    results.append(str(minimum_effort(arr, k)))
    index += 2
# Fast Output
sys.stdout.write(""\n"".join(results) + ""\n"")",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054829
1390054817,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <vector>
#include <bits/stdc++.h>
using namespace std;
int findMinimumCost(const string& servers) {
    int n = servers.size();
    // Try removing servers from the beginning
    int minCost = INT_MAX;
    for (int frontRemove = 0; frontRemove <= n; frontRemove++) {
        // Try removing servers from the end
        for (int endRemove = 0; endRemove <= n - frontRemove; endRemove++) {
            // Skip if we're not removing anything
            if (frontRemove == 0 && endRemove == 0) continue;
            // Calculate the remaining server configuration
            string remainingServers = servers.substr(frontRemove, n - frontRemove - endRemove);
            // Count idle servers remaining
            int idleServersRemaining = count(remainingServers.begin(), remainingServers.end(), '0');
            // Count active servers removed
            int activeServersRemoved = 0;
            for (int i = 0; i < frontRemove; i++) {
                if (servers[i] == '1') activeServersRemoved++;
            }
            for (int i = n - endRemove; i < n; i++) {
                if (servers[i] == '1') activeServersRemoved++;
            }
            // Calculate cost
            int cost = max(idleServersRemaining, activeServersRemoved);
            // Update minimum cost
            minCost = min(minCost, cost);
        }
    }
    return minCost;
}
int main() {
    int t;
    cin >> t;
    vector<string> testCases;
    for (int i = 0; i < t; i++) {
        string servers;
        cin >> servers;
        testCases.push_back(servers);
    }
    for (const string& servers : testCases) {
        cout << findMinimumCost(servers) << endl;
    }
    return 0;
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054817
1390054819,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();  // Number of test cases
        while (t-- > 0) {
            int n = s.nextInt();
            int k = s.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = s.nextInt();
            }
            // Using a queue to track the index of negative numbers
            Queue<Integer> queue = new LinkedList<>();
            int i = 0;
            // Process first window
            for (i = 0; i < k; i++) {
                if (arr[i] < 0) {
                    queue.add(i);
                }
            }
            // Process remaining windows
            for (; i < n; i++) {
                // Print first negative number of previous window
                if (!queue.isEmpty()) {
                    System.out.print(arr[queue.peek()] + "" "");
                } else {
                    System.out.print(""0 "");
                }
                // Remove elements that are out of this window
                while (!queue.isEmpty() && queue.peek() <= i - k) {
                    queue.poll();
                }
                // Add current element if it's negative
                if (arr[i] < 0) {
                    queue.add(i);
                }
            }
            // Print for last window
            if (!queue.isEmpty()) {
                System.out.print(arr[queue.peek()] + "" "");
            } else {
                System.out.print(""0 "");
            }
            System.out.println();
        }
        s.close();
    }
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054819
1390054818,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054818
1390054814,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        benefits.sort(reverse=True)
        skipped = [False] * n
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        total_effort = 0
        penalty = 0  
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
threading.Thread(target=main).start()",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054814
1390054812,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Build prefix sums for zeros and ones.
        vector<int> prefix0(n + 1, 0), prefix1(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i + 1] = prefix0[i] + (s[i] == '0');
            prefix1[i + 1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        // Binary search for the minimal cost C in the range [0, n].
        int low = 0, high = n, ans = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            for (int l = 0; l <= n; l++) {
                int allowed = prefix0[l] + mid;
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                if (r - 1 < l) continue; 
                int r_max = r - 1;
                int onesKept = prefix1[r_max] - prefix1[l];
                if (onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if (feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054812
1390054813,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    if k == n:
        return 0
    total_effort = sum(strengths)
    min_effort = total_effort
    for skip_index in range(n - k + 1):
        effort = sum(strengths[:skip_index]) + sum(s + k for s in strengths[skip_index + k:])
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort(n, k, strengths))",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054813
1390054811,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minDecommissioningCost(String servers) {
        int n = servers.length();
        int[] prefixOnes = new int[n + 1];
        int[] prefixZeros = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
        }
        int minCost = Integer.MAX_VALUE;
        for (int start = 0; start <= n; start++) {
            for (int end = start; end <= n; end++) {
                int activeRemoved = prefixOnes[start] + (prefixOnes[n] - prefixOnes[end]);
                int idleRemaining = prefixZeros[end] - prefixZeros[start];
                int cost = Math.max(idleRemaining, activeRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        sc.nextLine();
        while (t-- > 0) {
            String servers = sc.nextLine().trim();
            System.out.println(minDecommissioningCost(servers));
        }
        sc.close();
    }
}",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054811
1390054805,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054805
1390054807,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054807
1390054809,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054809
1390054800,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i-1][j] + strengths[i-1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
def solve():
    t = int(input().strip())
    results = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        strengths = list(map(int, input().strip().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    solve()",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054800
1390054799,unknown,unknown,unknown,"import math
def min_cost(s):
    n = len(s)
    zeros = s.count('0')
    ones = n - zeros
    min_cost = math.inf
    for i in range(n + 1):
        for j in range(n + 1):
            if i + j > n:
                break
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
            decommissioned_ones = ones - s[i:n - j].count('1')
            cost = max(remaining_zeros, decommissioned_ones)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    s = input()
    print(min_cost(s))",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054799
1390054803,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054803
1390054798,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
} 3rd",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054798
1390054792,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054792
1390054793,unknown,unknown,unknown,"import sys
def can_achieve(X, pos, T):
    """"""
    Given candidate cost X, pos is the list of indices where s has '1',
    and T is total ones.
    We need to check if there is some integer u in [max(1, T - X), T]
    and some i with 0 <= i <= T - u such that:
         pos[i+u-1] - pos[i] + 1 <= u + X.
    """"""
    # Lower bound for u:
    u_min = max(1, T - X)
    # Try every possible u from u_min to T
    for u in range(u_min, T + 1):
        # For each block of u ones (in pos), check if minimal segment length is <= u + X.
        # We need to check i from 0 to T - u.
        for i in range(0, T - u + 1):
            seg_length = pos[i + u - 1] - pos[i] + 1
            if seg_length <= u + X:
                return True
    return False
def solve_server_pruning(s):
    T = s.count('1')
    # If there are no active servers, cost is 0.
    if T == 0:
        return 0
    n = len(s)
    # Create list of indices where s[i]=='1'
    pos = [i for i, ch in enumerate(s) if ch == '1']
    # Binary search for the minimum possible cost X.
    lo, hi = 0, T  # X ranges between 0 and T.
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if can_achieve(mid, pos, T):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans
def main():
    data = sys.stdin.read().strip().split()
    t = int(data[0])
    outputs = []
    index = 1
    for _ in range(t):
        s = data[index]
        index += 1
        outputs.append(str(solve_server_pruning(s)))
    sys.stdout.write(""\n"".join(outputs))
if __name__ == '__main__':
    main()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054793
1390054786,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <climits>
using namespace std;
void solve(){
    int n,k;
    cin>>n>>k;
    vector<int> a(n);
    long long sum_a = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        sum_a += a[i];
    }
    vector<long long> values;
    for (int i = 0; i < n; i++) {
        long long val = a[i] - (n - i - 1LL);
        values.push_back(val);
    }
    sort(values.rbegin(), values.rend());
    vector<long long> prefixSum(n + 1, 0);
    prefixSum[0] = 0;
    for (int i = 1; i <= n; i++) {
        prefixSum[i] = prefixSum[i - 1] + values[i - 1];
    }
    int max_m = min(k, n);
    long long maxTotal = LLONG_MIN;
    for (int m = 0; m <= max_m; m++) {
        long long current = prefixSum[m] + ((long long)m * (m - 1)) / 2;
        if (current > maxTotal) {
            maxTotal = current;
        }
    }
    long long minEffort = sum_a - maxTotal;
    cout << minEffort << ""\n"";
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--){
        solve();
    }
    return 0;
}",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054786
1390054789,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054789
1390054787,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(len(arr) - k + 1):
        result.append(arr[dq[0]] if dq else 0)
        if dq and dq[0] == i:
            dq.popleft()
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
def process_test_cases(t, test_cases):
    results = []
    for n, k, arr in test_cases:
        results.append("" "".join(map(str, earliest_faults(arr, k))))
    return ""\n"".join(results)
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
print(process_test_cases(t, test_cases))",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054787
1390054783,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054783
1390054784,unknown,unknown,unknown,"def min_decommission_cost(s):
    n = len(s)
    prefix_zeros = [0] * (n + 1)
    prefix_ones = [0] * (n + 1)
    # Compute prefix sums for '0's and '1's
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')
        prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')
    min_cost = n
    # Try removing `l` from the left and `r` from the right
    for l in range(n + 1):
        for r in range(n - l + 1):
            remaining_zeros = prefix_zeros[n - r] - prefix_zeros[l]
            removed_ones = prefix_ones[l] + (prefix_ones[n] - prefix_ones[n - r])
            min_cost = min(min_cost, max(remaining_zeros, removed_ones))
    return min_cost
# Read input
t = int(input())
for _ in range(t):
    print(min_decommission_cost(input()))",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054784
1390054785,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054785
1390054782,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        # Sort by benefit descending
        benefits.sort(reverse=True)
        skipped = [False] * n
        # Mark the top k firewalls to skip
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        # Calculate total effort
        total_effort = 0
        penalty = 0  # number of skipped firewalls so far
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
# Run main() inside a separate thread to avoid recursion limit issues in large input
threading.Thread(target=main).start()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054782
1390054779,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[n][j] = 0
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            effort = firewalls[i] + j 
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054779
1390054780,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    # Precompute cumulative counts
    active_prefix_sum = [0] * (n + 1)
    idle_suffix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
    for i in range(n-1, -1, -1):
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
    min_cost = float('inf')
    # For each possible prefix and suffix to remove
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Active servers decommissioned (from start and end)
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
            # Idle servers remaining in the middle
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054780
1390054778,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n - j]
            idle_count = remaining.count('0')
            removed_count = i + j - (n - len(remaining))
            removed_ones = 0
            for k in range(i):
                if s[k] == '1':
                    removed_ones += 1
            for k in range(n-j, n):
                if s[k] == '1':
                    removed_ones += 1
            cost = max(idle_count, removed_ones)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054778
1390054772,unknown,unknown,unknown,"def solve():
    """"""Solves the server decommissioning problem.""""""
    T = int(input())
    for _ in range(T):
        servers = input().strip()
        n = len(servers)
        min_cost = float('inf')
        for i in range(n + 1):  # Remove i from start
            for j in range(n - i + 1):  # Remove j from end
                remaining = servers[i:n - j]
                idle_count = remaining.count('0')
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
                min_cost = min(min_cost, max(idle_count, active_removed))
        print(min_cost)
solve()",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054772
1390054774,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    memo = {}
    def dp(pos, skips_left, penalty):
        if pos == n:
            return 0
        if (pos, skips_left, penalty) in memo:
            return memo[(pos, skips_left, penalty)]
        current_strength = strengths[pos] + penalty
        min_effort = current_strength + dp(pos + 1, skips_left, penalty)
        if skips_left > 0:
            skip_effort = dp(pos + 1, skips_left - 1, penalty + 1)
            min_effort = min(min_effort, skip_effort)
        memo[(pos, skips_left, penalty)] = min_effort
        return min_effort
    return dp(0, k, 0)
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        result = min_effort_to_breach(n, k, strengths)
        results.append(result)
    for result in results:
        print(result)
if __name__ == ""__main__"":
    solve()",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054774
1390054775,unknown,unknown,unknown,"import sys  
from itertools import accumulate  
def min_effort(arr, k):  
    n = len(arr)  
    T = sum(arr)  
    A = [arr[i] + (i + 1) for i in range(n)]  
    A.sort(reverse=True)  
    P = [0] + list(accumulate(A))  
    m_max = min(k, n)  
    best = float('inf')  
    for m in range(m_max + 1):  
        cost = T + m * n - (m * m - m) // 2 - P[m]  
        if cost < best:  
            best = cost  
    return best  
def solve():  
    data = sys.stdin.read().strip().split()  
    if not data:  
        return  
    t = int(data[0])  
    index = 1  
    res = []  
    for _ in range(t):  
        n = int(data[index])  
        index += 1  
        k = int(data[index])  
        index += 1  
        arr = list(map(int, data[index:index + n]))  
        index += n  
        res.append(str(min_effort(arr, k)))  
    sys.stdout.write(""\n"".join(res) + ""\n"")  
if __name__ == ""__main__"":  
    solve()      ",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054775
1390054768,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        dq = deque()
        res = []
        # Process the first batch separately
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the earliest faulty reading for the first batch
        res.append(arr[dq[0]] if dq else 0)
        # Process remaining batches
        for i in range(k, n):
            # Remove out-of-window elements
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add new element if faulty
            if arr[i] < 0:
                dq.append(i)
            # Store the earliest faulty reading for the current batch
            res.append(arr[dq[0]] if dq else 0)
        results.append(res)
    return results
# Input handling
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing and Output
for res in earliest_faulty_readings(test_cases):
    print(*res)",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054768
1390054770,unknown,unknown,unknown,"def min_effort_to_breath(n, k, firewalls):
    firewalls.sort()
    return sum(firewalls[:n-k]) if k > 0 else sum(firewalls)
T = int(input().strip())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breath(n, k, firewalls))",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054770
1390054771,unknown,unknown,unknown,"import java.util.*;
public class BinaryStringMinCost {
    public static boolean check(int k, String s, int n, int[] prefix0, int[] prefix1) {
        int l = 0;
        for (int r = 0; r < n; r++) {
            while (l <= r && (prefix0[r + 1] - prefix0[l]) > k) {
                l++;
            }
            // Check number of '1's decommissioned
            if (l <= r && (prefix1[l] + (prefix1[n] - prefix1[r + 1])) <= k) {
                return true;
            }
        }
        return prefix1[n] <= k;
    }
    public static int findMinCost(String s) {
        int n = s.length();
        // Prefix sum arrays
        int[] prefix0 = new int[n + 1];
        int[] prefix1 = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            prefix0[i] = prefix0[i - 1] + (s.charAt(i - 1) == '0' ? 1 : 0);
            prefix1[i] = prefix1[i - 1] + (s.charAt(i - 1) == '1' ? 1 : 0);
        }
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid, s, n, prefix0, prefix1)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            String s = sc.next();
            System.out.println(findMinCost(s));
        }
        sc.close();
    }
}",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054771
1390054762,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm> // For count()
using namespace std;
int min_decommissioning_cost(string server_rack) {
    size_t first_one = server_rack.find('1');
    size_t last_one = server_rack.rfind('1');
    // If there are no active servers (all 0s), cost is 0
    if (first_one == string::npos) {
        return 0;
    }
    // Extract the core segment containing all necessary servers
    string core_segment = server_rack.substr(first_one, last_one - first_one + 1);
    // Count remaining idle servers (0s)
    int remaining_idle = count(core_segment.begin(), core_segment.end(), '0');
    // Count removed active servers (1s) from the prefix and suffix
    int removed_active = count(server_rack.begin(), server_rack.begin() + first_one, '1') +
                         count(server_rack.begin() + last_one + 1, server_rack.end(), '1');
    // Return the minimum cost
    return max(remaining_idle, removed_active);
}
int main() {
    int T;
    cin >> T; // Number of test cases
    while (T--) {
        string server_rack;
        cin >> server_rack;
        cout << min_decommissioning_cost(server_rack) << endl;
    }
    return 0;
}",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054762
1390054755,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        res = []
        dq = deque()
        # Process first k elements
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Process the rest of the elements
        for i in range(n - k + 1):
            # Add the first faulty element or 0 if none
            res.append(arr[dq[0]] if dq else 0)
            # Remove elements that are out of the current window
            if dq and dq[0] == i:
                dq.popleft()
            # Add the next element
            if i + k < n and arr[i + k] < 0:
                dq.append(i + k)
        results.append("" "".join(map(str, res)))
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Process and output results
for result in earliest_faulty_readings(test_cases):
    print(result)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054755
1390054759,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Create all possible scenarios of skipping up to k firewalls
    min_total_effort = float('inf')
    # Try all combinations of which firewalls to skip
    # Since k can be up to 10 and n up to 100, we can't try all 2^n combinations
    # Instead, we'll use dynamic programming
    # dp[i][j] = min effort to breach first i firewalls while skipping exactly j of them
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
    dp[0][0] = 0  # Base case: no effort to breach 0 firewalls with 0 skips
    for i in range(1, n+1):
        current_strength = strengths[i-1]
        # Don't skip the current firewall
        for j in range(k+1):
            if dp[i-1][j] != float('inf'):
                # Current firewall strength increases by j (number of previously skipped firewalls)
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
        # Skip the current firewall
        for j in range(1, k+1):
            if dp[i-1][j-1] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Find minimum across all possible numbers of skips
    return min(dp[n])
def solve_test_cases():
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, strengths)
        results.append(min_effort)
    return results
# Main execution
if __name__ == ""__main__"":
    results = solve_test_cases()
    for result in results:
        print(result)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054759
1390054760,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;
int solve() {
    string s;
    cin >> s;
    int n = s.length();
    int min_cost = n;
    for (int i = 0; i <= n; ++i) {
        for (int j = i; j <= n; ++j) {
            int remaining_zeros = 0;
            for (int k = i; k < j; ++k) {
                if (s[k] == '0') {
                    remaining_zeros++;
                }
            }
            int removed_ones = 0;
            for (int k = 0; k < i; ++k) {
                if (s[k] == '1') {
                    removed_ones++;
                }
            }
            for (int k = j; k < n; ++k) {
                if (s[k] == '1') {
                    removed_ones++;
                }
            }
            min_cost = min(min_cost, max(remaining_zeros, removed_ones));
        }
    }
    return min_cost;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        cout << solve() << endl;
    }
    return 0;
}",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054760
1390054750,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j 
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054750
1390054753,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        result.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements no longer in window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add new element if it's faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute and print output
for res in earliest_faulty_readings(test_cases):
    print(res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054753
1390054751,unknown,unknown,unknown,"import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
    total = sum(arr)
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
    b.sort(reverse=True)
    best = 0
    s = 0
    for x in range(1, min(k, n) + 1):
        s += b[x-1]
        cur = s + (x * (x - 1)) // 2
        if cur > best:
            best = cur
    res.append(str(total - best))
sys.stdout.write(""\n"".join(res))",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054751
1390054743,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    impacts = []
    for i in range(n):
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    impacts.sort(reverse=True)
    to_skip = set(impacts[i][1] for i in range(k))
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            penalty += 1
        else:
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
def main():
    results = solve_test_cases()
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054743
1390054746,unknown,unknown,unknown,"def min_effort_to_breach(n, k, fw):
    total_effort = sum(fw)
    min_effort = total_effort
    for i in range(n - k + 1):  
        skipped_penalty = sum(fw[i:i + k])
        added_penalty = (n - (i + k)) * k  
        min_effort = min(min_effort, total_effort - skipped_penalty + added_penalty)
    return min_effort
T = int(input())  
for _ in range(T):
    n, k = map(int, input().split())
    fw = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, fw))",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054746
1390054747,unknown,unknown,unknown,"def min_operations(T, test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if s[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if s[i - 1] == '1' else 0)
        def check(k):
            l = 0
            for r in range(n):
                while l <= r and prefix_0[r + 1] - prefix_0[l] > k:
                    l += 1
                if l <= r and prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k:
                    return True
            return prefix_1[n] <= k
        low, high = 0, n
        while low < high:
            mid = (low + high) // 2
            if check(mid):
                high = mid
            else:
                low = mid + 1
        results.append(low)
    return results
T = int(input())
test_cases = [input().strip() for _ in range(T)]
results = min_operations(T, test_cases)
for res in results:
    print(res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054747
1390054740,unknown,unknown,unknown,"def earliest_faulty_reading(test_cases):
    results = []
    for n, k, arr in test_cases:
        batch_results = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            faulty = next((x for x in batch if x < 0), 0)
            batch_results.append(faulty)
        results.append(batch_results)
    return results
if ___name___ == ""___main___"":
    t = int(input())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        test_cases.append((n, k, arr))
    results = earliest_faulty_reading(test_cases)
    for res in results:
        print(*res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054740
1390054731,unknown,unknown,unknown,"cases = int(input())
for t in range(cases):
    n,k = [int(i) for i in input().split()]
    array = [int(i) for i in input().split()]
    if n == k:
        print(0)
        continue
    batch_sum = [0]*n
    for i in range(n):
        batch_sum[i] = sum(array[i:i+k])
    total = sum(array)
    best = total
    for i in range(n):
        if i + k <= n:
            best = min(best, total - batch_sum[i] + n-i-k)
        else:
            best = min(best, total - batch_sum[i])
    print(best)
    ",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054731
1390054736,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054736
1390054738,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054738
1390054729,unknown,unknown,unknown,"#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void findreading(int n,int k,int arr[]){
        for (int i = 0; i <= n - k; i++) {  
        int found = 0;  
        for (int j = i; j < i + k; j++) {
            if (arr[j] < 0) {
                printf(""%d "", arr[j]);  
                found = 1;
                break;
            }
        }
        if (!found) {
            printf(""0 "");  
        }
    }
    printf(""\n"");  
}
int main() {
    int t;
    scanf(""%d"", &t);  
    for (int i = 0; i < t; i++) {
        int n, k;
        scanf(""%d %d"", &n, &k);  
        int arr[n];  
        for (int j = 0; j < n; j++) {  
            scanf(""%d"", &arr[j]);  
        }
        findreading(n, k, arr);  
    }
    return 0;
}",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054729
1390054728,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }  
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054728
1390054721,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    """"""
    Calculate the minimum cost of decommissioning servers with advanced optimization.
    Args:
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
    Returns:
        int: Minimum possible cost
    """"""
    n = len(servers)
    # Convert string to list of integers for faster processing
    servers_list = [int(s) for s in servers]
    # Precompute prefix sums for active and idle servers
    prefix_active = [0] * (n + 1)
    prefix_idle = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + servers_list[i]
        prefix_idle[i + 1] = prefix_idle[i] + (1 - servers_list[i])
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = float('inf')
    # Optimize the nested loop by reducing redundant calculations
    for i in range(n + 1):
        # Active servers decommissioned from the beginning
        active_decom_begin = prefix_active[i]
        # For each prefix (servers removed from beginning), 
        # find the optimal suffix to remove
        for j in range(n + 1 - i):
            # If we've already found a better solution than what's possible here, skip
            if min_cost == 0:  # Perfect solution already found
                return 0
            # Active servers decommissioned from the end
            active_decom_end = total_active - prefix_active[n-j] if j > 0 else 0
            active_decommissioned = active_decom_begin + active_decom_end
            # Idle servers remaining
            idle_remaining = total_idle - (prefix_idle[i] + (prefix_idle[n] - prefix_idle[n-j]))
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
            # Early termination if we've found a perfect solution
            if min_cost == 0:
                return 0
    return min_cost
def main():
    # Read number of test cases
    t = int(input().strip())
    for _ in range(t):
        servers = input().strip()
        print(min_decommissioning_cost(servers))
if __name__ == ""__main__"":
    main()",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054721
1390054723,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    min_total_effort = float('inf')
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
    dp[0][0] = 0  
    for i in range(1, n+1):
        current_strength = strengths[i-1]
        for j in range(k+1):
            if dp[i-1][j] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
        for j in range(1, k+1):
            if dp[i-1][j-1] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
def solve_test_cases():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, strengths)
        results.append(min_effort)
    return results
if __name__ == ""__main__"":
    results = solve_test_cases()
    for result in results:
        print(result)",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054723
1390054726,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            String[] nk = br.readLine().split("" "");
            int n = Integer.parseInt(nk[0]);
            int k = Integer.parseInt(nk[1]);
            String[] input = br.readLine().split("" "");
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = Integer.parseInt(input[i]);
            bw.write(minEffort(n, k, a) + ""\n"");
        }
        bw.flush();
        bw.close();
        br.close();
    }
    static int minEffort(int n, int k, int[] a) {
        int[] dp = new int[k + 2];
        for (int i = n - 1; i >= 0; i--) {
            int[] next = new int[k + 2];
            for (int skip = 0; skip <= k; skip++) {
                int take = a[i] + skip + dp[skip]; 
                int leave = (skip < k) ? dp[skip + 1] : Integer.MAX_VALUE; 
                next[skip] = Math.min(take, leave);
            }
            dp = next;
        }
        return dp[0];
    }
}",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054726
1390054717,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        min_cost = float('inf')
        # Iterate over all possible prefixes to remove
        for start in range(n + 1):
            # Iterate over all possible suffixes to remove
            for end in range(n - start + 1):
                # Remaining servers after removing `start` from the front and `end` from the back
                remaining = servers[start:n-end] if end > 0 else servers[start:n]
                # Count remaining idle servers (0's) and decommissioned active servers (1's)
                remaining_idle = remaining.count('0')
                decommissioned_active = (servers[:start] + servers[n-end:]).count('1')
                # Calculate the cost
                cost = max(remaining_idle, decommissioned_active)
                # Update the minimum cost
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
# Input reading
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Get results
results = min_decommissioning_cost(test_cases)
# Output results
for result in results:
    print(result)",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054717
1390054710,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        result.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements no longer in window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add new element if it's faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute and print output
for res in earliest_faulty_readings(test_cases):
    print(res)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054710
1390054711,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <climits>
using namespace std;
int minEffort(vector<int>& firewalls, int n, int k){
    int mineffort = INT_MAX;
    for(int skip = 0; skip<=k && skip<=n; skip++){
        int effort = 0;
        for(int i=skip; i<n; i++){
            effort += firewalls[i] + skip;
        }
        mineffort = mineffort<=effort? mineffort:effort;
    }
    return mineffort;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t;
    cin>>t;
    while(t--){
        int n, k;
        cin>>n>>k;
        vector<int> firewalls(n);
        for(int i=0; i<n; i++){
            cin>>firewalls[i];
        }
        cout<<minEffort(firewalls, n, k)<<endl;
    }
    return 0;
}",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054711
1390054712,unknown,unknown,unknown,"import sys
def min_decommission_cost(server_string):
    n = len(server_string)
    total_ones = server_string.count('1')
    # Edge cases: If all are '0's or all are '1's
    if total_ones == 0 or total_ones == n:
        return 0
    min_cost = float('inf')
    # Sliding window for size `k`
    for k in range(1, n):  # We keep segments of size `k`
        ones_in_window = 0
        # Initial window calculation
        for i in range(k):
            if server_string[i] == '1':
                ones_in_window += 1
        # Compute cost for first window
        zeros_in_window = k - ones_in_window
        ones_removed = total_ones - ones_in_window
        min_cost = min(min_cost, max(zeros_in_window, ones_removed))
        # Slide window across string
        for i in range(k, n):
            if server_string[i - k] == '1':
                ones_in_window -= 1  # Remove outgoing element
            if server_string[i] == '1':
                ones_in_window += 1  # Add incoming element
            zeros_in_window = k - ones_in_window
            ones_removed = total_ones - ones_in_window
            min_cost = min(min_cost, max(zeros_in_window, ones_removed))
    return min_cost
def solve():
    t = int(sys.stdin.readline().strip())
    results = []
    for _ in range(t):
        server_string = sys.stdin.readline().strip()
        results.append(str(min_decommission_cost(server_string)))
    sys.stdout.write(""\n"".join(results) + ""\n"")
# Run the function
solve()",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054712
1390054703,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i):
            remaining = server_rack[i:n-j]
            idle_remaining = remaining.count('0')
            removed_start = server_rack[:i].count('1')
            removed_end = server_rack[n-j:].count('1')
            active_decommissioned = removed_start + removed_end
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054703
1390054702,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054702
1390054706,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    # This deque will store indices of the negative numbers in the current window
    dq = deque()
    result = []
    for i in range(len(arr)):
        # If current element is negative, add its index
        if arr[i] < 0:
            dq.append(i)
        # When we've reached at least one complete window, record the answer
        if i >= k - 1:
            # Remove indices that are out of the current window (i-k+1 is window's start index)
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # If the deque is not empty, the front element is the earliest negative in the window
            if dq:
                result.append(arr[dq[0]])
            else:
                result.append(0)
    return result
# Reading input and processing test cases
if __name__ == ""__main__"":
    t = int(input().strip())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        output = earliest_faults(arr, k)
        print("" "".join(map(str, output)))",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054706
1390054698,unknown,unknown,unknown,"import sys
def minimize_server_shutdown_cost():
    num_cases = int(sys.stdin.readline().strip())
    for _ in range(num_cases):
        server_status = sys.stdin.readline().strip()
        active_servers = [index for index, state in enumerate(server_status) if state == '1']
        total_active = len(active_servers)
        # If no active servers or already consecutive, no operations needed
        if total_active == 0 or active_servers[-1] - active_servers[0] == total_active - 1:
            print(0)
            continue
        low, high = 0, total_active
        while high - low > 1:
            mid_point = (low + high) // 2
            servers_to_keep = total_active - mid_point
            is_possible = False
            for i in range(mid_point + 1):
                first, last = active_servers[i], active_servers[i + servers_to_keep - 1]
                if (last - first + 1) - servers_to_keep <= mid_point:
                    is_possible = True
                    break
            if is_possible:
                high = mid_point
            else:
                low = mid_point
        print(high)
if __name__ == ""__main__"":
    minimize_server_shutdown_cost()",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054698
1390054700,unknown,unknown,unknown,"def decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        for i in range(n + 1):
            for j in range(n - i + 1):
                remaining_string = case[i:n - j]
                if not remaining_string:
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
                    cost = removed_count
                else:
                    idle_count = remaining_string.count('0')
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
                    cost = max(idle_count, removed_count)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
# Input parsing
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Call the function and print the results
results = decommission_cost(test_cases)
for result in results:
    print(result)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054700
1390054701,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    total_effort = sum(firewalls)
    if k == 0:
        return total_effort
    min_effort = total_effort
    for i in range(n - k + 1):
        skipped = sum(firewalls[i:i+k])
        penalty = sum(range(1, n - (i + k) + 1))
        effort = total_effort - skipped + penalty
        min_effort = min(min_effort, effort)
    return min_effort
def main():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        print(min_effort_to_breach(n, k, firewalls))
if __name__ == ""__main__"":
    main()",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054701
1390054697,unknown,unknown,unknown,"class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            String serverRack = scanner.next();
            int minCost = calculateMinCost(serverRack);
            System.out.println(minCost);
        }
        scanner.close();
    }
    public static int calculateMinCost(String serverRack) {
        int n = serverRack.length();
        int min_cost = n; // Initialize with maximum possible cost
        for (int removedPrefixCount = 0; removedPrefixCount <= n; ++removedPrefixCount) {
            for (int removedSuffixCount = 0; removedSuffixCount <= n - removedPrefixCount; ++removedSuffixCount) {
                int current_idle_servers = 0;
                int current_active_removed = 0;
                // Count removed active servers (prefix)
                for (int i = 0; i < removedPrefixCount; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        current_active_removed++;
                    }
                }
                // Count removed active servers (suffix)
                for (int i = n - removedSuffixCount; i < n; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        current_active_removed++;
                    }
                }
                // Count remaining idle servers
                for (int i = removedPrefixCount; i < n - removedSuffixCount; ++i) {
                    if (serverRack.charAt(i) == '0') {
                        current_idle_servers++;
                    }
                }
                int cost = Math.max(current_idle_servers, current_active_removed);
                min_cost = Math.min(min_cost, cost);
            }
        }
        return min_cost;
    }
}",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054697
1390054690,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054690
1390054696,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        benefits.sort(reverse=True)
        skipped = [False] * n
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        total_effort = 0
        penalty = 0  
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
threading.Thread(target=main).start()",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054696
1390054693,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i):
            remaining = server_rack[i:n-j]
            # Skip if we've removed everything
            if not remaining:
                if server_rack.count('1') == 0:  # If there are no active servers
                    return 0
                continue
            idle_remaining = remaining.count('0')
            active_decommissioned = 0
            if i > 0:
                active_decommissioned += server_rack[:i].count('1')
            if j > 0:
                active_decommissioned += server_rack[n-j:].count('1')
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054693
1390054685,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--) {
        string s;
        cin >> s;
        int n = s.size();
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        // We'll binary search for the minimal cost C in the range [0, n].
        int low = 0, high = n, ans = n;
        while(low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            for (int l = 0; l <= n; l++) {
                int allowed = prefix0[l] + mid;
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                // Then the maximum r with zeros constraint is r_max = r - 1.
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
                int r_max = r - 1;
                // Ones kept in s[l, r_max) is:
                int onesKept = prefix1[r_max] - prefix1[l];
                // We need onesKept >= totalOnes - mid.
                if(onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if(feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054685
1390054686,unknown,unknown,unknown,"def minimum_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        skipped = set()
        total_effort = 0
        penalty = 0
        # Find k firewalls with the highest strength to skip
        a_sorted_indices = sorted(range(n), key=lambda i: a[i], reverse=True)[:k]
        skipped.update(a_sorted_indices)
        # Calculate total effort
        for i in range(n):
            if i in skipped:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)  # Print result instead of returning a list
# Example test cases for debugging
test_cases = [
    (4, 1, [5, 10, 11, 5]),
    (4, 4, [8, 7, 1, 4])
]
# Running test cases
minimum_effort(test_cases)",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054686
1390054689,unknown,unknown,unknown,"import java.util.*;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // Number of test cases
        while (T-- > 0) {
            int n = scanner.nextInt(); // Number of firewalls
            int k = scanner.nextInt(); // Max number of firewalls that can be skipped
            long[] strengths = new long[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextLong(); // Strength of each firewall
            }
            System.out.println(minimumEffort(n, k, strengths));
        }
        scanner.close();
    }
    private static long minimumEffort(int n, int k, long[] strengths) {
        if (k >= n) {
            return 0; // If we can skip all, then no effort is needed.
        }
        long totalEffort = 0;
        for (int i = 0; i < n; i++) {
            totalEffort += strengths[i]; // Calculate total effort without skips
        }
        // Best effort starts as the scenario where no skips are made
        long minEffort = totalEffort;
        // Iterate through each possible skip quantity
        for (int skips = 1; skips <= k; skips++) {
            for (int start = 0; start + skips <= n; start++) {
                long skippedEffort = 0;
                // Calculate effort if skipping from 'start' to 'start + skips - 1'
                for (int i = 0; i < start; i++) {
                    skippedEffort += strengths[i];
                }
                for (int i = start + skips; i < n; i++) {
                    skippedEffort += strengths[i] + (i - (start + skips) + 1);
                }
                minEffort = Math.min(minEffort, skippedEffort);
            }
        }
        return minEffort;
    }
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054689
1390054669,unknown,unknown,unknown,"def min_decommission_cost(s):
    n, total_ones = len(s), s.count('1')
    min_cost, left_ones = n, 0  
    for l in range(n + 1):
        right_ones = 0
        for r in range(n - l + 1):
            cost = max(s[l:n-r].count('0'), left_ones + right_ones)
            min_cost = min(min_cost, cost)
            if r < n - l and s[n - r - 1] == '1':
                right_ones += 1
        if l < n and s[l] == '1':
            left_ones += 1
    return min_cost
# Read input
t = int(input())
for _ in range(t):
    print(min_decommission_cost(input()))",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054669
1390054670,unknown,unknown,unknown,"def solve():
    """"""Solves the server decommissioning problem.""""""
    T = int(input())
    for _ in range(T):
        servers = input().strip()
        n = len(servers)
        min_cost = float('inf')
        for i in range(n + 1):  # Remove i from start
            for j in range(n - i + 1):  # Remove j from end
                remaining = servers[i:n - j]
                idle_count = remaining.count('0')
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
                min_cost = min(min_cost, max(idle_count, active_removed))
        print(min_cost)
solve()",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054670
1390054681,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054681
1390054667,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054667
1390054662,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054662
1390054663,unknown,unknown,unknown,"def min_cost_to_convert(T, test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i - 1] + (1 if s[i - 1] == '0' else 0)
            prefix_1[i] = prefix_1[i - 1] + (1 if s[i - 1] == '1' else 0)
        def check(k):
            l = 0
            for r in range(n):
                while l <= r and prefix_0[r + 1] - prefix_0[l] > k:
                    l += 1
                if l <= r and prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k:
                    return True
            return prefix_1[n] <= k
        low, high = 0, n
        while low < high:
            mid = (low + high) // 2
            if check(mid):
                high = mid
            else:
                low = mid + 1
        results.append(low)
    return results
T = int(input())
test_cases = [input().strip() for _ in range(T)]
for result in min_cost_to_convert(T, test_cases):
    print(result)",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054663
1390054666,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases(test_cases):
    results = []
    for size, k, arr in test_cases:
        results.append(earliest_faulty_readings(arr, k))
    return results
if __name__ == ""__main__"":
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        size, k = map(int, input().split())
        arr = list(map(int, input().split()))
        test_cases.append((size, k, arr))
    results = process_test_cases(test_cases)
    for res in results:
        print("" "".join(map(str, res)))",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054666
1390054647,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first window of size k
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Append result for first window
        result.append(arr[dq[0]] if dq else 0)
        # Process the rest of the windows
        for i in range(k, n):
            # Remove indices out of the current window
            while dq and dq[0] <= i - k:
                dq.popleft()
            # Add index of current element if it's negative
            if arr[i] < 0:
                dq.append(i)
            # Append earliest faulty reading for current window
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results
# Input Reading
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Output Result
for res in earliest_faulty_readings(test_cases):
    print(res)",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054647
1390054658,unknown,unknown,unknown,"class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            String serverRack = scanner.next();
            int minCost = calculateMinCost(serverRack);
            System.out.println(minCost);
        }
        scanner.close();
    }
    public static int calculateMinCost(String serverRack) {
        int n = serverRack.length();
        int min_cost = n; // Initialize with maximum possible cost
        for (int removedPrefixCount = 0; removedPrefixCount <= n; ++removedPrefixCount) {
            for (int removedSuffixCount = 0; removedSuffixCount <= n - removedPrefixCount; ++removedSuffixCount) {
                int current_idle_servers = 0;
                int current_active_removed = 0;
                // Count removed active servers (prefix)
                for (int i = 0; i < removedPrefixCount; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        current_active_removed++;
                    }
                }
                // Count removed active servers (suffix)
                for (int i = n - removedSuffixCount; i < n; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        current_active_removed++;
                    }
                }
                // Count remaining idle servers
                for (int i = removedPrefixCount; i < n - removedSuffixCount; ++i) {
                    if (serverRack.charAt(i) == '0') {
                        current_idle_servers++;
                    }
                }
                int cost = Math.max(current_idle_servers, current_active_removed);
                min_cost = Math.min(min_cost, cost);
            }
        }
        return min_cost;
    }
}",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054658
1390054659,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        # Compute a[i] + i (0-based)
        values = [a[i] + i for i in range(n)]
        # Sort in descending order
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        # Compute the result
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
if __name__ == ""__main__"":
    main()",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054659
1390054644,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054644
1390054645,unknown,unknown,unknown,"def calculate_earliest_fault(arr,k):
    n=len(arr)
t=int(input())
for i in range(0,t):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054645
1390054646,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054646
1390054641,unknown,unknown,unknown,"def minimum_effort(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]
        strengths = test_cases[t][1]
        if k == n:
            results.append(0)
            continue
        total_effort = sum(strengths)
        min_effort = total_effort
        for i in range(n):
            skip_effort = total_effort - strengths[i]
            for j in range(1, k + 1):
                if i + j < n:
                    skip_effort += 1  # Adding penalty for skipping next k firewalls
            min_effort = min(min_effort, skip_effort)
        results.append(min_effort)
    return results
def main():
    T = int(input().strip())
    test_cases = []
    for _ in range(T):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        test_cases.append(((n, k), strengths))
    results = minimum_effort(T, test_cases)
    for res in results:
        print(res)
if __name__ == ""__main__"":
    main()",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054641
1390054634,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        benefits.sort(reverse=True)
        skipped = [False] * n
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        total_effort = 0
        penalty = 0  
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
threading.Thread(target=main).start()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054634
1390054638,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054638
1390054637,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            String[] nk = br.readLine().split("" "");
            int n = Integer.parseInt(nk[0]);
            int k = Integer.parseInt(nk[1]);
            String[] input = br.readLine().split("" "");
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = Integer.parseInt(input[i]);
            bw.write(minEffort(n, k, a) + ""\n"");
        }
        bw.flush();
        bw.close();
        br.close();
    }
    static int minEffort(int n, int k, int[] a) {
        int[] dp = new int[k + 2];
        for (int i = n - 1; i >= 0; i--) {
            int[] next = new int[k + 2];
            for (int skip = k; skip >= 0; skip--) {
                int take = a[i] + skip + dp[skip];
                int leave = (skip < k) ? dp[skip + 1] : Integer.MAX_VALUE;
                next[skip] = Math.min(take, leave);
            }
            dp = next;
        }
        return dp[0];
    }
}",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054637
1390054627,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            ArrayList<Integer> res = new ArrayList<>();
            Deque<Integer> dq = new ArrayDeque<>();
            for (int i = 0; i < k; i++) {
                if (arr[i] < 0)
                    dq.addLast(i);
            }
            res.add(!dq.isEmpty() ? arr[dq.peekFirst()] : 0);
            for (int i = k; i < n; i++) {
                while (!dq.isEmpty() && dq.peekFirst() < i - k + 1)
                    dq.removeFirst();
                if (arr[i] < 0)
                    dq.addLast(i);
                res.add(!dq.isEmpty() ? arr[dq.peekFirst()] : 0);
            }
            for (int num : res) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
    }
}",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054627
1390054629,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054629
1390054631,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if _name_ == ""_main_"":
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054631
1390054621,unknown,unknown,unknown,"def min_decommission_cost(rack):
    n = len(rack)
    # Precompute prefix and suffix counts
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
    min_cost = n  # Initialize to worst case
    # Process results in chunks to avoid memory issues
    for left in range(n + 1):
        active_removed_left = active_prefix[left]
        for right in range(n + 1 - left):
            # Calculate costs
            active_removed = active_removed_left + (active_prefix[n] - active_prefix[n - right])
            idle_remaining = idle_prefix[n - right] - idle_prefix[left]
            cost = max(active_removed, idle_remaining)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input())
    for _ in range(t):
        rack = input()
        print(min_decommission_cost(rack))
if __name__ == ""__main__"":
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054621
1390054622,unknown,unknown,unknown,"import sys, bisect
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    s = data[ptr]
    ptr += 1
    n = len(s)
    ones = [0]*(n+1)
    zeros = [0]*(n+1)
    for i in range(n):
        ones[i+1] = ones[i] + (1 if s[i]=='1' else 0)
        zeros[i+1] = zeros[i] + (1 if s[i]=='0' else 0)
    tot = ones[n]
    lo, hi = 0, max(tot, n - tot)
    def feasible(X):
        if tot <= X:
            return True
        for i in range(n+1):
            target = ones[i] + tot - X
            j = bisect.bisect_left(ones, target, i+1, n+1)
            if j <= n:
                if zeros[j] - zeros[i] <= X:
                    return True
        return False
    while lo < hi:
        mid = (lo + hi) // 2
        if feasible(mid):
            hi = mid
        else:
            lo = mid + 1
    res.append(str(lo))
sys.stdout.write(""\n"".join(res))",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054622
1390054624,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if _name_ == ""_main_"":
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054624
1390054618,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if _name_ == ""_main_"":
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054618
1390054613,unknown,unknown,unknown,"def decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        for i in range(n + 1):
            for j in range(n - i + 1):
                remaining_string = case[i:n - j]
                if not remaining_string:
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
                    cost = removed_count
                else:
                    idle_count = remaining_string.count('0')
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
                    cost = max(idle_count, removed_count)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
# Input parsing
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Call the function and print the results
results = decommission_cost(test_cases)
for result in results:
    print(result)",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054613
1390054616,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Build prefix sums for zeros and ones.
        // prefix0[i] = number of '0's in s[0, i)
        // prefix1[i] = number of '1's in s[0, i)
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        // We'll binary search for the minimal cost C in the range [0, n].
        int low = 0, high = n, ans = n;
        while(low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
            for (int l = 0; l <= n; l++) {
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
                // We require that prefix0[r] - prefix0[l] <= mid.
                // That is, prefix0[r] <= prefix0[l] + mid.
                // Because prefix0 is non-decreasing, we can use upper_bound:
                int allowed = prefix0[l] + mid;
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                // Then the maximum r with zeros constraint is r_max = r - 1.
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
                int r_max = r - 1;
                // Ones kept in s[l, r_max) is:
                int onesKept = prefix1[r_max] - prefix1[l];
                // We need onesKept >= totalOnes - mid.
                if(onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if(feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054616
1390054615,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    firewalls = [(val, i) for i, val in enumerate(firewalls)]
    firewalls.sort()
    skipped = set()
    for i in range(k):
        skipped.add(firewalls[i][1])
    effort = 0
    extra_security = 0
    for i in range(n):
        if i in skipped:
            extra_security += 1
        else:
            effort += firewalls[i][0] + extra_security
    return effort
def main():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        result = min_effort_to_breach(n, k, firewalls)
        print(result)
if __name__ == ""__main__"":
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054615
1390054610,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    """"""
    Calculate the minimum cost of decommissioning servers efficiently.
    Args:
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
    Returns:
        int: Minimum possible cost
    """"""
    n = len(servers)
    # Precompute prefix and suffix sums for active servers
    prefix_active = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
    suffix_active = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        suffix_active[i] = suffix_active[i + 1] + (1 if servers[i] == '1' else 0)
    # Total active servers
    total_active = prefix_active[n]
    min_cost = float('inf')
    # Try all possible combinations of removing servers from beginning (i) and end (j)
    for i in range(n + 1):
        for j in range(n + 1 - i):
            if i + j > n:
                continue
            # Active servers decommissioned
            active_decommissioned = prefix_active[i] + suffix_active[n - j]
            # Idle servers remaining
            remaining_servers = n - i - j
            remaining_active = total_active - active_decommissioned
            idle_remaining = remaining_servers - remaining_active
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    # Read number of test cases
    t = int(input().strip())
    for _ in range(t):
        servers = input().strip()
        print(min_decommissioning_cost(servers))
if __name__ == ""__main__"":
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054610
1390054611,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])  # Number of test cases
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054611
1390054612,unknown,unknown,unknown,"def solve():
    import sys, bisect
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    out = []
    for _ in range(t):
        s = data[index].strip()
        index += 1
        n = len(s)
        P0 = [0]*(n+1)
        P1 = [0]*(n+1)
        for i in range(n):
            P0[i+1] = P0[i] + (1 if s[i]=='0' else 0)
            P1[i+1] = P1[i] + (1 if s[i]=='1' else 0)
        total_ones = P1[n]
        low, high, ans = 0, max(P0[n], total_ones), max(P0[n], total_ones)
        def feasible(X):
            for L in range(n+1):
                threshold = X + P0[L]
                R = bisect.bisect_right(P0, threshold) - 1
                if R >= L and (P1[R] - P1[L] >= total_ones - X):
                    return True
            return False
        while low <= high:
            mid = (low + high) // 2
            if feasible(mid):
                ans = mid
                high = mid - 1
            else:
                low = mid + 1
        out.append(str(ans))
    sys.stdout.write(""\n"".join(out))
if __name__ == ""__main__"":
    solve()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054612
1390054606,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j <= i - 1: 
                dp[i][j] = dp[i-1][j] + strengths[i-1] + j
            if j > 0:  
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
def solve_test_case():
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    return min_effort_to_breach(n, k, strengths)
def main():
    t = int(input())
    for _ in range(t):
        result = solve_test_case()
        print(result)
if __name__ == ""__main__"":
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054606
1390054607,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    return min(dp[n])
T = int(input())  
for _ in range(T):
    n, k = map(int, input().split())  
    firewalls = list(map(int, input().split()))  
    print(min_effort(n, k, firewalls))",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054607
1390054609,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):  
        for j in range(n + 1 - i): 
            if i + j > n:
                continue
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
for result in results:
    print(result)",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054609
1390054604,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    if k >= n:
        print(0)
        continue
    savings = []
    for i in range(n):
        savings.append((a[i] - (n - i - 1), i))
    savings.sort(reverse=True)
    to_skip = set()
    for i in range(k):
        _, idx = savings[i]
        to_skip.add(idx)
    effort = 0
    skipped = 0
    for i in range(n):
        if i in to_skip:
            skipped += 1
        else:
            effort += a[i] + skipped
    print(effort)",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054604
1390054601,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054601
1390054599,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054599
1390054602,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
 Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while (T-- > 0) {
            int n = sc.nextInt(); 
            int k = sc.nextInt(); 
            int[] strength = new int[n];
            for (int i = 0; i < n; i++) {
                strength[i] = sc.nextInt();
            }
            if (k == n) {
                System.out.println(0);
                continue;
            }
            System.out.println(findMinEffort(n, k, strength));
        }
        sc.close();
    }
    private static long findMinEffort(int n, int k, int[] strength) {
        long[][] dp = new long[n + 1][k + 1];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], Long.MAX_VALUE / 2);
        }
        dp[0][0] = 0; 
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= Math.min(i, k); j++) {
                if (j > 0) {
                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);
                }
                long penalty = 0;
                if (i > 1 && j > 0) {
                    penalty = j; 
                }
                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + strength[i-1] + penalty);
            }
        }
        long result = Long.MAX_VALUE;
        for (int j = 0; j <= k; j++) {
            result = Math.min(result, dp[n][j]);
        }
        return result;
    }
}",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054602
1390054593,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process the rest of the array
    for i in range(len(arr) - k + 1):
        # Append the first negative in the current window
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of the current window
        while dq and dq[0] < i + 1:
            dq.popleft()
        # Add new element (end of current window)
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
def process_test_cases():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
# Run the function
process_test_cases()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054593
1390054596,unknown,unknown,unknown,"def min_cost_server_optimization(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    prefix_active = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if server_rack[i] == '1' else 0)
    prefix_idle = [0] * (n + 1)
    for i in range(n):
        prefix_idle[i + 1] = prefix_idle[i] + (1 if server_rack[i] == '0' else 0)
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    for i in range(n + 1): 
        for j in range(n + 1 - i):  
            if i + j == n:  
                continue
            active_removed = prefix_active[i] + (total_active - prefix_active[n - j])
            idle_remaining = total_idle - (prefix_idle[i] + (total_idle - prefix_idle[n - j]))
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_rack = input().strip()
        result = min_cost_server_optimization(server_rack)
        print(result)
if __name__ == ""__main__"":
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054596
1390054597,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        output = []
        dq = deque()
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        output.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            while dq and dq[0] <= i - k:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            output.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, output)))
    print(""\n"".join(results))
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    test_cases.append((n, k, arr))
earliest_faulty_readings(test_cases)",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054597
1390054589,unknown,unknown,unknown,"def solve():
    """"""Solves the server decommissioning problem.""""""
    T = int(input())
    for _ in range(T):
        servers = input().strip()
        n = len(servers)
        min_cost = float('inf')
        for i in range(n + 1):  # Remove i from start
            for j in range(n - i + 1):  # Remove j from end
                remaining = servers[i:n - j]
                if not remaining:
                    min_cost = min(min_cost, 0)
                    continue
                idle_count = remaining.count('0')
                # Correctly calculate active servers removed
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
                min_cost = min(min_cost, max(idle_count, active_removed))
        print(min_cost)
solve()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054589
1390054591,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        benefits.sort(reverse=True)
        skipped = [False] * n
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        total_effort = 0
        penalty = 0  
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
threading.Thread(target=main).start()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054591
1390054588,unknown,unknown,unknown,"import sys
def breach_firewall():
    input_data = sys.stdin.read().strip().split()
    t = int(input_data[0])
    index = 1
    results = []
    for _ in range(t):
        n = int(input_data[index])
        k = int(input_data[index+1])
        index += 2
        a = list(map(int, input_data[index:index+n]))
        index += n
        sum_a = sum(a)
        n_val = n  # total number of firewalls
        # Compute v[i] = a[i] + i for each firewall (0-indexed)
        v = [a[i] + i for i in range(n)]
        # Sort v in descending order
        v.sort(reverse=True)
        best = 0  # candidate(0) = 0: meaning ""skip none""
        current = 0
        # We can skip at most min(k, n) firewalls.
        m_max = min(k, n)
        for m in range(1, m_max+1):
            current += v[m-1]
            # candidate(m) = (sum of top m v[i]) - m*(n - 1) + m*(m - 1)/2
            candidate = current - m * (n_val - 1) + (m * (m - 1)) // 2
            if candidate > best:
                best = candidate
        # The minimum total effort equals total base cost minus the maximum saving.
        answer = sum_a - best
        results.append(str(answer))
    sys.stdout.write(""\n"".join(results))
if __name__ == '__main__':
    breach_firewall()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054588
1390054581,unknown,unknown,unknown,"def min_pruning_cost(s):
    n = len(s)
    # Build prefix sums for 0's and 1's.
    prefix0 = [0] * (n + 1)
    prefix1 = [0] * (n + 1)
    for i, ch in enumerate(s):
        prefix0[i+1] = prefix0[i] + (1 if ch == '0' else 0)
        prefix1[i+1] = prefix1[i] + (1 if ch == '1' else 0)
    ones_total = prefix1[n]
    ans = float('inf')
    # For each possible starting index L, binary search for R in [L, n] that minimizes
    # f(L, R) = max( (prefix0[R]-prefix0[L]), (ones_total - (prefix1[R]-prefix1[L]) ) ).
    for L in range(0, n + 1):
        lo, hi = L, n
        candidate_for_L = float('inf')
        # Binary search: We want the smallest R such that the count of zeros in s[L:R]
        # is at least the number of ones removed, i.e.,
        #     prefix0[R] - prefix0[L] >= ones_total - (prefix1[R]-prefix1[L])
        while lo < hi:
            mid = (lo + hi) // 2
            zeros_count = prefix0[mid] - prefix0[L]
            ones_removed = ones_total - (prefix1[mid] - prefix1[L])
            if zeros_count < ones_removed:
                lo = mid + 1
            else:
                hi = mid
        # Candidate using R = lo
        if L <= lo <= n:
            zeros_count = prefix0[lo] - prefix0[L]
            ones_removed = ones_total - (prefix1[lo] - prefix1[L])
            candidate_for_L = min(candidate_for_L, max(zeros_count, ones_removed))
        # It is also useful to check the neighbor R = lo - 1 (if possible)
        if lo - 1 >= L:
            R = lo - 1
            zeros_count = prefix0[R] - prefix0[L]
            ones_removed = ones_total - (prefix1[R] - prefix1[L])
            candidate_for_L = min(candidate_for_L, max(zeros_count, ones_removed))
        ans = min(ans, candidate_for_L)
    return ans
# Main code to read test cases and output answer.
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_pruning_cost(s))",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054581
1390054575,unknown,unknown,unknown,"import math
def min_cost(s):
    n = len(s)
    zeros = s.count('0')
    ones = n - zeros
    min_cost = math.inf
    for i in range(n + 1):
        for j in range(n + 1):
            if i + j > n:
                break
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
            decommissioned_ones = ones - s[i:n - j].count('1')
            cost = max(remaining_zeros, decommissioned_ones)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    s = input()
    print(min_cost(s))",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054575
1390054577,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    INF = float('inf')
    dp = [INF] * (k + 1)
    dp[0] = 0
    for i in range(n):
        new_dp = list(dp) # create a copy to avoid overwriting before needed.
        for s in range(k + 1):
            new_dp[s] = dp[s] + a[i] + s
            if s > 0:
                new_dp[s] = min(new_dp[s], dp[s - 1])
        dp = new_dp
    ans = min(dp)
    print(ans)
if __name__ == ""__main__"":
    T = int(input())
    for _ in range(T):
        solve()",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054577
1390054579,unknown,unknown,unknown,"def min_cost_server_pruning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i):
            remaining = server_rack[i:n-j]
            idle_remaining = remaining.count('0')
            removed_start = server_rack[:i].count('1')
            removed_end = server_rack[n-j:].count('1')
            active_decommissioned = removed_start + removed_end
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_cost_server_pruning(server_rack))",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054579
1390054570,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    return min(dp[n])
T = int(input())  
for _ in range(T):
    n, k = map(int, input().split())  
    firewalls = list(map(int, input().split()))  
    print(min_effort(n, k, firewalls))",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054570
1390054571,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            rem = s[i:n - j]
            idle = rem.count('0')
            active_rem = s[:i].count('1') + s[n - j:].count('1')
            min_cost = min(min_cost, max(idle, active_rem))
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054571
1390054572,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054572
1390054557,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        output = []
        dq = deque()
        for i in range(n):
            if arr[i] < 0:
                dq.append(i)
            if i >= k - 1:
                while dq and dq[0] < i - k + 1:
                    dq.popleft()
                output.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, output)))
    return results
# Reading input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing and printing output
for res in earliest_faulty_readings(test_cases):
    print(res)",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054557
1390054563,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <climits>
using namespace std;
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
    vector<int> results;
    for (const string& servers : test_cases) {
        int n = servers.size();
        int total_0 = 0;
        for (char c : servers) {
            if (c == '0') total_0++;
        }
        int total_1 = n - total_0;
        // Precompute prefix counts for 0s and 1s
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
        }
        // Precompute suffix counts for 0s and 1s
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
        for (int j = 1; j <= n; ++j) {
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
        }
        int min_cost = INT_MAX;
        // Iterate over all possible prefixes (i)
        for (int i = 0; i <= n; ++i) {
            int j_max = n - i;
            int left = 0, right = j_max;
            int best_j = 0;
            int best_cost = INT_MAX;
            // Binary search for the best j
            while (left <= right) {
                int mid = (left + right) / 2;
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
                int current_cost = max(remaining_0, decommissioned_1);
                if (current_cost < best_cost) {
                    best_cost = current_cost;
                    best_j = mid;
                } else if (current_cost == best_cost && mid < best_j) {
                    best_j = mid;
                }
                if (decommissioned_1 < remaining_0) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            // Check neighboring j values
            for (int dj : {-1, 0, 1}) {
                int j = best_j + dj;
                if (j >= 0 && j <= j_max) {
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
                    int current_cost = max(remaining_0, decommissioned_1);
                    if (current_cost < best_cost) {
                        best_cost = current_cost;
                    }
                }
            }
            if (best_cost < min_cost) {
                min_cost = best_cost;
            }
        }
        results.push_back(min_cost);
    }
    return results;
}
int main() {
    int T;
    cin >> T;
    vector<string> test_cases(T);
    for (int i = 0; i < T; ++i) {
        cin >> test_cases[i];
    }
    vector<int> results = min_decommissioning_cost(test_cases);
    for (int result : results) {
        cout << result << endl;
    }
    return 0;
}",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054563
1390054569,unknown,unknown,unknown,"import java.util.*;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); 
        while (T-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            long[] strengths = new long[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextLong(); 
            }
            System.out.println(minimumEffort(n, k, strengths));
        }
        scanner.close();
    }
    private static long minimumEffort(int n, int k, long[] strengths) {
        long minEffort = Long.MAX_VALUE;
        long[] cumulative = new long[n + 1]; 
        for (int i = 0; i < n; i++) {
            cumulative[i + 1] = cumulative[i] + strengths[i];
        }
        minEffort = cumulative[n];
        for (int skip = 0; skip <= k; skip++) {
            for (int start = 0; start + skip <= n; start++) {
                long effort = 0;
                if (start > 0) {
                    effort += cumulative[start];
                }
                if (start + skip < n) {
                    for (int j = start + skip; j < n; j++) {
                        effort += strengths[j] + (j - (start + skip));
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
        }
        return minEffort;
    }
}",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054569
1390054556,unknown,unknown,unknown,"import java.util.*;
public class FaultyComponentDetector {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Size of the array
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
    private static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove elements that are out of the current window
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new negative number index to the deque
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Start collecting results when we have a complete window
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
}",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054556
1390054549,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        # Sort by benefit descending
        benefits.sort(reverse=True)
        skipped = [False] * n
        # Mark the top k firewalls to skip
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        # Calculate total effort
        total_effort = 0
        penalty = 0  # number of skipped firewalls so far
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
# Run main() inside a separate thread to avoid recursion limit issues in large input
threading.Thread(target=main).start()",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054549
1390054551,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def main():
    T = int(input())
    for _ in range(T):
        s = input().strip()
        n = len(s)
        total_ones = s.count('1')
        # Calculate max consecutive ones
        max_consecutive_ones = 0
        current = 0
        for c in s:
            if c == '1':
                current += 1
                max_consecutive_ones = max(max_consecutive_ones, current)
            else:
                current = 0
        if total_ones == 0 or total_ones == max_consecutive_ones:
            print(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
            if max_ones >= required_ones:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        print(answer)
if __name__ == ""__main__"":
    main()",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054551
1390054553,unknown,unknown,unknown,"def min_firewall_effort_optimized(n, k, firewalls):
    if k >= n:
        return 0  # If we can skip all firewalls, effort is 0
    min_effort = float('inf')
    for i in range(1 << n):
        skipped_count = bin(i).count('1')
        if skipped_count <= k:
            current_effort = 0
            skipped = 0
            for j in range(n):
                if (i >> j) & 1:
                    skipped += 1
                else:
                    current_effort += firewalls[j] + skipped
            min_effort = min(min_effort, current_effort)
    return min_effort
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        result = min_firewall_effort_optimized(n, k, firewalls)
        print(result)",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054553
1390054545,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054545
1390054546,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Build prefix sums for zeros and ones.
        // prefix0[i] = number of '0's in s[0, i)
        // prefix1[i] = number of '1's in s[0, i)
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        // We'll binary search for the minimal cost C in the range [0, n].
        int low = 0, high = n, ans = n;
        while(low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
            for (int l = 0; l <= n; l++) {
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
                // We require that prefix0[r] - prefix0[l] <= mid.
                // That is, prefix0[r] <= prefix0[l] + mid.
                // Because prefix0 is non-decreasing, we can use upper_bound:
                int allowed = prefix0[l] + mid;
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                // Then the maximum r with zeros constraint is r_max = r - 1.
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
                int r_max = r - 1;
                // Ones kept in s[l, r_max) is:
                int onesKept = prefix1[r_max] - prefix1[l];
                // We need onesKept >= totalOnes - mid.
                if(onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if(feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054546
1390054547,unknown,unknown,unknown,"def min_decommission_cost(rack):
    n = len(rack)
    # Precompute prefix sums:
    # active_prefix[i] = number of '1's in rack[0:i]
    # idle_prefix[i] = number of '0's in rack[0:i]
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
    A = active_prefix[n]  # total active servers
    # Check if it's possible to achieve a cost <= C.
    def can_achieve(C):
        # For each starting index, we try to find a minimal j such that:
        # active_prefix[j] - active_prefix[i] >= A - C  (i.e. at least A - C active servers in segment)
        # and check if idle_prefix[j] - idle_prefix[i] <= C.
        for i in range(n + 1):
            # Required active servers in the segment:
            req = A - C
            # We need to find the smallest j in [i, n] with:
            # active_prefix[j] >= active_prefix[i] + req.
            lo_j, hi_j = i, n + 1
            while lo_j < hi_j:
                mid = (lo_j + hi_j) // 2
                if active_prefix[mid] >= active_prefix[i] + req:
                    hi_j = mid
                else:
                    lo_j = mid + 1
            j = lo_j
            if j <= n and active_prefix[j] >= active_prefix[i] + req:
                # Check if the idle servers in the segment [i, j] are at most C.
                if idle_prefix[j] - idle_prefix[i] <= C:
                    return True
        return False
    # The answer must lie between 0 and max(A, n - A)
    lo, hi = 0, max(A, n - A)
    ans = hi
    while lo <= hi:
        mid = (lo + hi) // 2
        if can_achieve(mid):
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans
def main():
    t = int(input().strip())
    for _ in range(t):
        rack = input().strip()
        result = min_decommission_cost(rack)
        print(result)
if __name__ == ""__main__"":
    main()",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054547
1390054537,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            System.out.println(minEffort(n, k, a));
        }
        sc.close();
    }
    static int minEffort(int n, int k, int[] a) {
        int[][] dp = new int[n + 1][k + 1];
        for (int i = n - 1; i >= 0; i--) {
            for (int skip = k; skip >= 0; skip--) {
                int take = a[i] + skip + dp[i + 1][skip];
                int leave = (skip < k) ? dp[i + 1][skip + 1] : Integer.MAX_VALUE;
                dp[i][skip] = Math.min(take, leave);
            }
        }
        return dp[0][0];
    }
}",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054537
1390054543,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    if k >= n:  
        print(0)
        continue
    min_effort = sum(firewalls)  
    for i in range(n - k + 1): 
        effort = 0
        skipped = 0
        for j in range(n):
            if i <= j < i + k:  
                skipped += 1
                continue
            effort += firewalls[j] + skipped  
        min_effort = min(min_effort, effort)  
    print(min_effort)",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054543
1390054533,unknown,unknown,unknown,"def min_effort(n, k, firewalls):  
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]  
    dp[0][0] = 0  
    for i in range(1, n + 1):  
        for j in range(k + 1):  
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j  
            if j > 0:  
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  
    return min(dp[n])  
T = int(input())  
for _ in range(T):  
    n, k = map(int, input().split())  
    firewalls = list(map(int, input().split()))  
    print(min_effort(n, k, firewalls))",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054533
1390054531,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    impacts = []
    for i in range(n):
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    impacts.sort(reverse=True)
    to_skip = set(impacts[i][1] for i in range(k))
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            penalty += 1
        else:
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
def main():
    results = solve_test_cases()
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054531
1390054524,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.length();
        int total_ones = 0;
        for (char c : s) {
            if (c == '1') {
                total_ones++;
            }
        }
        int min_cost = n;
        for (int l = 0; l <= n; ++l) {
            int kept_ones = 0;
            int kept_zeros = 0;
            for (int r = l; r <= n; ++r) {
                if (r > l) {
                    if (s[r - 1] == '1') {
                        kept_ones++;
                    } else {
                        kept_zeros++;
                    }
                }
                int removed_ones = total_ones - kept_ones;
                min_cost = min(min_cost, max(removed_ones, kept_zeros));
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054524
1390054525,unknown,unknown,unknown,"def solve():
    """"""Solves the server decommissioning problem.""""""
    T = int(input())
    for _ in range(T):
        servers = input().strip()
        n = len(servers)
        min_cost = float('inf')
        for i in range(n + 1):  # Remove i from start
            for j in range(n - i + 1):  # Remove j from end
                remaining = servers[i:n - j]
                if not remaining:
                    min_cost = min(min_cost, 0)
                    continue
                idle_count = remaining.count('0')
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
                min_cost = min(min_cost, max(idle_count, active_removed))
        print(min_cost)
solve()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054525
1390054528,unknown,unknown,unknown,"def min_decommission_cost(s: str) -> int:
    n = len(s)
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
    T = len(ones_pos)
    if T == 0:
        return 0
    zeros_total = s.count('0')
    ans = min(zeros_total, T) 
    for X in range(1, T + 1):
        for i in range(0, T - X + 1):
            left = ones_pos[i]
            right = ones_pos[i + X - 1]
            length = right - left + 1
            zeros_in_block = length - X
            candidate = max(zeros_in_block, T - X)
            ans = min(ans, candidate)
    return ans
if __name__ == '__main__':
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        print(min_decommission_cost(s))",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054528
1390054514,unknown,unknown,unknown,"import sys
def min_decommission_cost(binary_str):
    trimmed_str = binary_str.strip('0')
    if not trimmed_str:
        return 0  
    total_zeros = trimmed_str.count('0')
    min_cost = total_zeros  
    removed_ones = 0
    for ch in trimmed_str:
        if ch == '1':
            removed_ones += 1
        else:
            total_zeros -= 1  
        min_cost = min(min_cost, max(total_zeros, removed_ones))
    return min_cost
def main():
    T = int(sys.stdin.readline().strip())
    results = []
    for _ in range(T):
        binary_str = sys.stdin.readline().strip()
        results.append(str(min_decommission_cost(binary_str)))
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054514
1390054519,unknown,unknown,unknown,"def min_eff(n, k, s):
    if k >= n:
        return 0
    imp = []
    for i in range(n):
        imp.append((s[i] - (n - i - 1), i))
    imp.sort(reverse=True)
    skip = set(imp[i][1] for i in range(k))
    eff, p = 0, 0
    for i in range(n):
        if i in skip:
            p += 1
        else:
            eff += s[i] + p
    return eff
def solve():
    t = int(input())
    res = []
    for _ in range(t):
        n, k = map(int, input().split())
        s = list(map(int, input().split()))
        res.append(min_eff(n, k, s))
    for r in res:
        print(r)
if __name__ == ""__main__"":
    solve()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054519
1390054523,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054523
1390054509,unknown,unknown,unknown,"import sys
def min_operations_to_make_consecutive():
    test_cases = int(sys.stdin.readline().strip())
    for _ in range(test_cases):
        binary_str = sys.stdin.readline().strip()
        ones_positions = [idx for idx, char in enumerate(binary_str) if char == '1']
        total_ones = len(ones_positions)
        if total_ones == 0 or ones_positions[-1] - ones_positions[0] == total_ones - 1:
            print(0)
            continue
        left, right = 0, total_ones
        while right - left > 1:
            mid = (left + right) // 2
            ones_needed = total_ones - mid
            feasible = False
            for i in range(mid + 1):
                start, end = ones_positions[i], ones_positions[i + ones_needed - 1]
                if (end - start + 1) - ones_needed <= mid:
                    feasible = True
                    break
            if feasible:
                right = mid
            else:
                left = mid
        print(right)
if __name__ == ""__main__"":
    min_operations_to_make_consecutive()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054509
1390054510,unknown,unknown,unknown,"import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
    total = sum(arr)
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
    b.sort(reverse=True)
    best = 0
    s = 0
    for x in range(1, min(k, n) + 1):
        s += b[x-1]
        cur = s + (x * (x - 1)) // 2
        if cur > best:
            best = cur
    res.append(str(total - best))
sys.stdout.write(""\n"".join(res))",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054510
1390054507,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    """"""
    Calculate the minimum cost of decommissioning servers from the beginning and end of the rack.
    Args:
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
    Returns:
        int: Minimum possible cost
    """"""
    n = len(servers)
    # Try removing i servers from the beginning and j servers from the end
    min_cost = float('inf')
    for i in range(n + 1):  # Including the case where we remove 0 from beginning
        for j in range(n + 1 - i):  # Including the case where we remove 0 from end
            if i + j > n:
                continue
            # Remaining servers after decommissioning
            remaining = servers[i:n-j]
            # Count idle servers that remain
            idle_remaining = remaining.count('0')
            # Count active servers decommissioned
            active_decommissioned = 0
            for k in range(i):
                if servers[k] == '1':
                    active_decommissioned += 1
            for k in range(n-j, n):
                if servers[k] == '1':
                    active_decommissioned += 1
            # Cost is the maximum of these two factors
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    # Read number of test cases
    t = int(input().strip())
    results = []
    for _ in range(t):
        servers = input().strip()
        results.append(min_decommissioning_cost(servers))
    # Print results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054507
1390054506,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    if k >= n:
        print(0)
        continue
    prev = [float('inf')] * (k + 1)
    prev[0] = 0
    for i in range(n):
        curr = [float('inf')] * (k + 1)
        for j in range(k + 1):
            if j > 0:
                curr[j] = min(curr[j], prev[j - 1])
            if j <= i:
                curr[j] = min(curr[j], prev[j] + a[i] + j)
        prev = curr
    print(min(prev))",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054506
1390054502,unknown,unknown,unknown,"def min_cost(s):
    n = len(s)
    zeros = s.count('0')
    ones = n - zeros
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1):
            if i + j > n:
                break
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
            decommissioned_ones = ones - s[i:n - j].count('1')
            cost = max(remaining_zeros, decommissioned_ones)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    s = input()
    print(min_cost(s))",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054502
1390054503,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    INF = float('inf')
    prev = [INF] * (k + 1)
    prev[0] = 0
    for i in range(n):
        curr = [INF] * (k + 1)
        for s in range(k + 1):
            # Don't skip i
            curr[s] = prev[s] + a[i] + s
            # Skip i (if possible)
            if s > 0:
                curr[s] = min(curr[s], prev[s - 1])
        prev = curr
    ans = min(prev)
    print(ans)
if __name__ == ""__main__"":
    T = int(input())
    for _ in range(T):
        solve()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054503
1390054505,unknown,unknown,unknown,"import sys
def min_decommission_cost(server_string):
    n = len(server_string)
    total_ones = server_string.count('1')
    # Edge cases: If all are '0's or all are '1's
    if total_ones == 0 or total_ones == n:
        return 0
    min_cost = float('inf')
    ones_in_window = 0
    # Sliding window approach
    left = 0
    for right in range(n):
        if server_string[right] == '1':
            ones_in_window += 1
        # Maintain window size <= n-1
        if right - left + 1 > n - 1:
            if server_string[left] == '1':
                ones_in_window -= 1
            left += 1
        if right - left + 1 == n - 1:
            zeros_in_window = (right - left + 1) - ones_in_window
            ones_removed = total_ones - ones_in_window
            cost = max(zeros_in_window, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(sys.stdin.readline().strip())  # Fast input reading
    results = []
    for _ in range(t):
        server_string = sys.stdin.readline().strip()
        results.append(str(min_decommission_cost(server_string)))
    sys.stdout.write(""\n"".join(results) + ""\n"")  # Fast output
# Run the function
solve()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054505
1390054493,unknown,unknown,unknown,"import sys
def main():
    T = int(sys.stdin.readline().strip())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        sum_a = sum(a)
        values = [a[i] - (n - i - 1) for i in range(n)]
        values.sort(reverse=True)
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
        max_m = min(k, n)
        max_total = float('-inf')
        for m in range(max_m + 1):
            current = prefix_sum[m] + (m * (m - 1)) // 2
            max_total = max(max_total, current)
        min_effort = sum_a - max_total
        print(min_effort)
if __name__ == ""__main__"":
    main()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054493
1390054496,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054496
1390054499,unknown,unknown,unknown,"def min_effort_to_breach(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        fw = firewalls[i - 1]
        for j in range(k + 1):
            if j <= i - 1:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + fw + j)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(firewalls, k))",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054499
1390054489,unknown,unknown,unknown,"def minimize_effort(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]
        firewalls = test_cases[t][1]
        # Sort firewalls in increasing order
        firewalls.sort()
        # Skip up to k weakest firewalls
        skipped_strength = sum(firewalls[:k]) if k > 0 else 0
        # Total effort is sum of all strengths minus skipped strengths
        total_effort = sum(firewalls) - skipped_strength
        results.append(total_effort)
    return results
# Sample Input
T = 2
test_cases = [
    ((4, 1), [5, 10, 11, 5]),  # Test case 1
    ((4, 4), [8, 7, 1, 4])     # Test case 2
]
# Running the Code
results = minimize_effort(T, test_cases)
# Output the results
for res in results:
    print(res)",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054489
1390054491,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    total_active = server_rack.count('1')
    total_idle = server_rack.count('0')
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
    left, right = 0, len(server_rack) - 1
    removed_active = 0
    removed_idle = 0
    # Try decommissioning from both ends
    while left <= right:
        if server_rack[left] == '0':
            removed_idle += 1
            left += 1
        elif server_rack[right] == '0':
            removed_idle += 1
            right -= 1
        elif server_rack[left] == '1':
            removed_active += 1
            left += 1
        elif server_rack[right] == '1':
            removed_active += 1
            right -= 1
        remaining_idle = total_idle - removed_idle
        min_cost = min(min_cost, max(remaining_idle, removed_active))
    return min_cost
# Read input
T = int(input())  # Number of test cases
results = []
for _ in range(T):
    server_rack = input().strip()
    results.append(min_decommission_cost(server_rack))
# Print results
for res in results:
    print(res)",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054491
1390054492,unknown,unknown,unknown,"def max_ones_with_at_most_k_zeros(s, k):
    left = 0
    zeros = 0
    max_ones = 0
    n = len(s)
    for right in range(n):
        if s[right] == '0':
            zeros += 1
        while zeros > k:
            if s[left] == '0':
                zeros -= 1
            left += 1
        current_ones = (right - left + 1) - zeros
        max_ones = max(max_ones, current_ones)
    return max_ones
def main():
    T = int(input())
    for _ in range(T):
        s = input().strip()
        n = len(s)
        total_ones = s.count('1')
        # Calculate max consecutive ones
        max_consecutive_ones = 0
        current = 0
        for c in s:
            if c == '1':
                current += 1
                max_consecutive_ones = max(max_consecutive_ones, current)
            else:
                current = 0
        if total_ones == 0 or total_ones == max_consecutive_ones:
            print(0)
            continue
        total_zeros = n - total_ones
        low, high = 0, max(total_ones, total_zeros)
        answer = high
        while low <= high:
            mid = (low + high) // 2
            required_ones = max(0, total_ones - mid)
            if required_ones == 0:
                answer = mid
                high = mid - 1
                continue
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
            if max_ones >= required_ones:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        print(answer)
if __name__ == ""__main__"":
    main()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054492
1390054488,unknown,unknown,unknown,"import sys  
from itertools import accumulate  
def min_effort(arr, k):  
    n = len(arr)  
    T = sum(arr)  
    A = [arr[i] + (i + 1) for i in range(n)]  
    A.sort(reverse=True)  
    P = [0] + list(accumulate(A))  
    m_max = min(k, n)  
    best = float('inf')  
    for m in range(m_max + 1):  
        cost = T + m * n - (m * m - m) // 2 - P[m]  
        if cost < best:  
            best = cost  
    return best  
def solve():  
    data = sys.stdin.read().strip().split()  
    if not data:  
        return  
    t = int(data[0])  
    index = 1  
    res = []  
    for _ in range(t):  
        n = int(data[index])  
        index += 1  
        k = int(data[index])  
        index += 1  
        arr = list(map(int, data[index:index + n]))  
        index += n  
        res.append(str(min_effort(arr, k)))  
    sys.stdout.write(""\n"".join(res) +  
if __name__ == 
    solve()  ",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054488
1390054484,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # Get indices of active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # Define the check function
        def check(X):
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                while j < m and A[j] - A[i] <= X:
                    j += 1
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == ""__main__"":
    solve()",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054484
1390054485,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    active_servers = server_rack.count('1')
    idle_servers = n - active_servers
    min_cost = min(max(active_servers, 0), max(idle_servers, 0))  # Initial cost if we remove all servers
    # Try removing different numbers of servers from the beginning
    for left in range(n + 1):
        # For each left choice, try removing different numbers from the end
        for right in range(n + 1 - left):
            # Calculate the remaining servers after removal
            remaining = server_rack[left:n-right]
            # If nothing remains, the cost is max(active_servers, idle_servers)
            if not remaining:
                continue
            active_removed = server_rack[:left].count('1') + server_rack[n-right:].count('1')
            idle_remaining = remaining.count('0')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Read input
t = int(input().strip())
for _ in range(t):
    server_rack = input().strip()
    print(min_decommissioning_cost(server_rack))",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054485
1390054486,unknown,unknown,unknown,"import bisect
t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    if n == 0:
        print(0)
        continue
    if n == 1:
        print(0)
        continue
    if n == 2:
        print(1 if s[0] == s[1] else 0)
        continue
    if not all(c in '01' for c in s):
        print(0)
        continue
    if all(c == '0' for c in s) or all(c == '1' for c in s):
        print(0)
        continue
    prefix_0 = [0] * (n + 1)
    prefix_1 = [0] * (n + 1)
    for i in range(n):
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]
    low, high = 0, n
    while low < high:
        m = (low + high) // 2
        possible = False
        for j in range(n + 1):
            target = prefix_0[j] - m
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
            if i <= j:
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
                remaining_zeros = prefix_0[j] - prefix_0[i]
                if max(remaining_zeros, ones_removed) <= m:
                    possible = True
                    break
        if possible:
            high = m
        else:
            low = m + 1
    print(low)",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054486
1390054480,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            System.out.println(minEffort(n, k, a));
        }
        sc.close();
    }
    static int minEffort(int n, int k, int[] a) {
        k = Math.min(k, n);
        int[][] dp = new int[n + 1][k + 1];
        for (int[] row : dp) Arrays.fill(row, -1);
        return dfs(0, 0, n, k, a, dp);
    }
    static int dfs(int i, int skip, int n, int k, int[] a, int[][] dp) {
        if (i == n) return 0;
        if (dp[i][skip] != -1) return dp[i][skip];
        int take = a[i] + skip + dfs(i + 1, skip, n, k, a, dp);
        int leave = (skip < k) ? dfs(i + 1, skip + 1, n, k, a, dp) : Integer.MAX_VALUE;
        return dp[i][skip] = Math.min(take, leave);
    }
}",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054480
1390054482,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054482
1390054475,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states , really tough one to solved actually 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i (if possible)
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054475
1390054472,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    prev_dp = [float('inf')] * (k + 1)
    prev_dp[0] = 0  
    for i in range(1, n + 1):
        curr_dp = [float('inf')] * (k + 1)
        for j in range(k + 1):
            curr_dp[j] = prev_dp[j] + firewalls[i - 1] + j  
            if j > 0:  
                curr_dp[j] = min(curr_dp[j], prev_dp[j - 1])
        prev_dp = curr_dp  
    return min(prev_dp)
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054472
1390054471,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Build prefix sums for zeros and ones.
        // prefix0[i] = number of '0's in s[0, i)
        // prefix1[i] = number of '1's in s[0, i)
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
        }
        int totalOnes = prefix1[n];
        // We'll binary search for the minimal cost C in the range [0, n].
        int low = 0, high = n, ans = n;
        while(low <= high) {
            int mid = (low + high) / 2;
            bool feasible = false;
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
            for (int l = 0; l <= n; l++) {
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
                // We require that prefix0[r] - prefix0[l] <= mid.
                // That is, prefix0[r] <= prefix0[l] + mid.
                // Because prefix0 is non-decreasing, we can use upper_bound:
                int allowed = prefix0[l] + mid;
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
                // Then the maximum r with zeros constraint is r_max = r - 1.
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
                int r_max = r - 1;
                // Ones kept in s[l, r_max) is:
                int onesKept = prefix1[r_max] - prefix1[l];
                // We need onesKept >= totalOnes - mid.
                if(onesKept >= totalOnes - mid) {
                    feasible = true;
                    break;
                }
            }
            if(feasible) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        cout << ans << ""\n"";
    }
    return 0;
}",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054471
1390054469,unknown,unknown,unknown,"function processData(input) {
    let lines = input.trim().split(/\s+/);
    let idx = 0;
    let T = parseInt(lines[idx++]);
    let result = [];
    for (let t = 0; t < T; t++) {
        let n = parseInt(lines[idx]);
        let k = parseInt(lines[idx + 1]);
        idx += 2;
        let a = lines.slice(idx, idx + n).map(Number);
        idx += n;
        let sumA = a.reduce((sum, val) => sum + val, 0);
        let v = [];
        for (let i = 0; i < n; i++) {
            v.push(a[i] - (n - i - 1));
        }
        v.sort((a, b) => b - a); 
        let prefix = Array(n + 1).fill(0);
        for (let i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + v[i];
        }
        let maxSum = 0;
        let maxT = Math.min(k, n);
        for (let t = 0; t <= maxT; t++) {
            let current = prefix[t] + (t * (t - 1)) / 2;
            maxSum = Math.max(maxSum, current);
        }
        result.push(sumA - maxSum);
    }
    console.log(result.join(""\n""));
}
// Handling input from stdin
process.stdin.resume();
process.stdin.setEncoding(""utf-8"");
let _input = """";
process.stdin.on(""data"", function (input) {
    _input += input;
});
process.stdin.on(""end"", function () {
    processData(_input);
});",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054469
1390054461,unknown,unknown,unknown,"def min_effort(n,k,firewalls):
    min_effort=float('inf')
    for i in range(n):
        effort=sum(firewalls[:i])+sum(firewalls[i+k:])+k*(n-(i+k))
        min_effort=min(min_effort,effort)
    return min_effort
t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    firewalls =list(map(int,input().split()))
    print(min_effort(n,k,firewalls))",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054461
1390054463,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054463
1390054464,unknown,unknown,unknown,"def optimize():
    count, skip = map(int, input().split())
    power = list(map(int, input().split()))
    dp = {}  
    for index in range(count, -1, -1):
        for remain in range(skip, -1, -1):
            for inc in range(count, -1, -1):
                if index == count:
                    dp[(index, remain, inc)] = 0
                else:
                    not_skip = power[index] + inc + dp.get((index + 1, remain, inc), float('inf'))
                    if_skipped = float('inf')
                    if remain > 0:
                        if_skipped = dp.get((index + 1, remain - 1, inc + 1), float('inf'))
                    dp[(index, remain, inc)] = min(not_skip, if_skipped)
    result = dp[(0, skip, 0)]
    print(result)
tc_Amount = int(input())
for _ in range(tc_Amount):
    optimize()",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054464
1390054454,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        sum_a = sum(a)
        values = [a[i] - (n - i - 1) for i in range(n)]
        values.sort(reverse=True)  # Sort in descending order
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
        max_m = min(k, n)
        max_total = float('-inf')
        for m in range(max_m + 1):
            current = prefix_sum[m] + (m * (m - 1)) // 2
            max_total = max(max_total, current)
        min_effort = sum_a - max_total
        results.append(str(min_effort))
    print(""\n"".join(results))
# Driver code
if __name__ == ""__main__"":
    T = int(input())
    min_effort(T)",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054454
1390054456,unknown,unknown,unknown,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <cmath>
#define int long long int
#define pb push_back
/*---------------------------------------------------------------------------------------------------------------------------------*/
/*ASCII small case-> a-97 to z-122
upper case-> A-65 to Z-90*/
#define nl ""\n""
#define mp map<int, int>
#define all(v) v.begin(), v.end()
#define F first
#define S second
#define ump unordered_map<long long, int, custom_hash>
#define mstpi multiset<pair<int, int> >
#define mst multiset<int>
#define vec vector<int>
#define pi pair<int, int>
#define ld long double
#define vep vector<pair<int, int>>
#define ul unsigned long long
#define loop1 for (int i = 0; i < n; i++)
#define REP(i, a, b) for (int i = a; i <= b; i++)
#define NO cout << ""NO"" << endl
#define YES cout << ""YES"" << endl
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
/*---------------------------------------------------------------------------------------------------------------------------------*/
const double PI = 3.1415926535;
const int inf = 1e18;
const int mod = 1000000007;
/*---------------------------------------------------------------------------------------------------------------------------------*/
int modmul(int a, int b, int m)
{
    a %= m;
    b %= m;
    return (a * b) % m;
}
int modexp(int n, int x)
{
    int ans = 1;
    while (n > 0)
    {
        if (n & 1)
        {
            ans = (ans * x) % mod;
        }
        n >>= 1;
        x = (x * x) % mod;
    }
    return ans;
}
/*---------------------------------------------------------------------------------------------------------------------------------*/
string add(string a, string b)
{
    string ans = """";
    int carry = 0;
    while (!a.empty() || !b.empty() || carry > 0)
    {
        int digitA = a.empty() ? 0 : a.back() - '0';
        int digitB = b.empty() ? 0 : b.back() - '0';
        int sum = digitA + digitB + carry;
        ans = to_string(sum % 10) + ans;
        carry = sum / 10;
        if (!a.empty())
            a.pop_back();
        if (!b.empty())
            b.pop_back();
    }
    return ans;
}
string ministrnum(string a, string b)
{
    if (a.length() > b.length())
        return b;
    else if (b.length() > a.length())
        return a;
    else
    {
        int n = a.length();
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i])
                return b;
            else if (a[i] < b[i])
                return a;
        }
    }
    return a;
}
vector<int> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    if(n >= 0) isPrime[0] = false;
    if(n >= 1) isPrime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}
class SegmentTree {
public:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(arr, 0, n - 1, 0);
    }
    void build(const std::vector<int>& arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, start, mid, 2 * index + 1);
        build(arr, mid + 1, end, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
    int queryRange(int start, int end, int l, int r, int index = 0) {
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if (start > r || end < l)
            return 0;
        if (start >= l && end <= r)
            return tree[index];
        int mid = (start + end) / 2;
        return queryRange(start, mid, l, r, 2 * index + 1) +
               queryRange(mid + 1, end, l, r, 2 * index + 2);
    }
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
        if(lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if(start > r || end < l)
            return;
        if(start >= l && end <= r) {
            tree[index] += (end - start + 1) * diff;
            if(start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }
            return;
        }
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, diff, 2 * index + 1);
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
};
class DSU {
public:
    std::vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY)
            return false;
        if (rank[rootX] < rank[rootY])
            parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY])
            parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int val;
    int weight, size;
    Node *left, *right;
    bool rev = false;
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
};
ostream &operator<<(ostream &os, Node *n) {
    if(!n) return os;
    os << n -> left;
    os << n -> val;
    os << n -> right;
    return os;
}
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
void push(Node* Treap) {
    if(!Treap) return;
    if(Treap -> rev) {
        Treap -> rev = false;
        swap(Treap->left, Treap->right);
        if(Treap -> left) Treap->left->rev ^= true;
        if(Treap -> right) Treap->right->rev ^= true;
    }
}
void pull(Node *Treap) {
    if(!Treap) return;
    push(Treap -> left), push(Treap -> right);
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
    return;
}
void split(Node *Treap, Node *&left, Node *&right, int val) {
    if(!Treap) {
        left = right = NULL;
        return;
    }
    push(Treap);
    if(size(Treap -> left) < val) {
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
        left = Treap;
    }
    else {
        split(Treap -> left, left, Treap -> left, val);
        right = Treap;
    }
    pull(Treap);
}
void merge(Node *&Treap, Node *left, Node *right) {
    push(left), push(right);
    if(left == NULL) {
        Treap = right;
        return;
    }
    if(right == NULL) {
        Treap = left;
        return;
    }
    if(left -> weight < right -> weight) {
        merge(right -> left, left, right -> left);
        Treap = right;
    }
    else {
        merge(left->right, left->right, right);
        Treap = left;
    }
    pull(Treap);
}
void inOrder(Node *curr, vector<int> &res) {
    if(curr == NULL) return;
    push(curr);
    inOrder(curr->left, res);
    res.pb(curr->val);
    inOrder(curr->right, res);
    pull(curr);
}
struct Treap {
    Node *root = nullptr;
    void insert(int i, int val) {
        Node *l, *r;
        split(root, l, r, i);
        Node *v = new Node(val);
        merge(l, l, v);
        merge(root, l, r);
    }
    void del(int i) {
        Node *l, *r;
        split(root, l, r, i);
        split(r, root, r, 1);
        merge(root, l, r);
    }
    void update(int l, int r, function<void(Node *)> f) {
        Node *a, *b, *c;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        if(b) {f(b);}
        merge(root, a, b);
        merge(root, root, c);
    }
    vector<int> allPr() {
        vector<int> res;
        inOrder(root, res);
        return res;
    }
    void cycShft(int l, int r) {
        Node *a, *b, *c, *d;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        split(b, b, d, r-l);
        merge(root, a, d);
        merge(root, root, b);
        merge(root, root, c);
    }
};
vector<int> computePrefix(const string &pattern) {
    int n = pattern.size();
    vector<int> prefix(n, 0);
    for (int i = 1, j = 0; i < n; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = prefix[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        prefix[i] = j;
    }
    return prefix;
}
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> prefix = computePrefix(pattern);
    vector<int> occurrences;
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = prefix[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == (int)pattern.size()) {
            occurrences.push_back(i - j + 1);
            j = prefix[j - 1];
        }
    }
    return occurrences;
}
void solve()
{
    int n, ans = 1e9;
    string s;
    cin>>s;
    n = s.size();
    ans = count(all(s), '1');
    vector<int> pref(n, 0);
    for(int i = 0; i<n; i++) {
        pref[i] = s[i] == '1';
        if(i) pref[i] += pref[i - 1];
    }
    for(int i = 0; i<n; i++) {
        for(int j = i; j<n; j++) {
            int cnt1 = (i?pref[i-1]:0) + pref[n-1] - (j!=n-1?pref[j+1]:pref[n-1]), cnt0 = (j - i + 1) - (pref[j] - (i?pref[i-1]:0));
            ans = min(ans, max(cnt1, cnt0)); 
        }
    }
    cout<<ans<<'\n';
}
int32_t main()
{
    ios_base ::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054456
1390054458,unknown,unknown,unknown,"def solve():
    """"""Solves the server decommissioning problem.""""""
    T = int(input())
    for _ in range(T):
        servers = input().strip()
        n = len(servers)
        min_cost = float('inf')
        for i in range(n + 1):  # Remove i from start
            for j in range(n - i + 1):  # Remove j from end
                remaining = servers[i:n - j]
                if not remaining:
                    min_cost = min(min_cost, 0)
                    continue
                idle_count = remaining.count('0')
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
                min_cost = min(min_cost, max(idle_count, active_removed))
        print(min_cost)
solve()",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054458
1390054449,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    if k == n:
        return 0
    total_effort = sum(strengths)
    min_effort = total_effort
    for i in range(n - k + 1):
        effort = sum(strengths[:i]) + sum(s + k for s in strengths[i + k:])
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort(n, k, strengths))",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054449
1390054452,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054452
1390054451,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054451
1390054448,unknown,unknown,unknown,"def min_cost(s):
    n = len(s)
    zeros = s.count('0')
    ones = n - zeros
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1):
            if i + j > n:
                break
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
            decommissioned_ones = ones - s[i:n - j].count('1')
            cost = max(remaining_zeros, decommissioned_ones)
            min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    s = input()
    print(min_cost(s))",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054448
1390054443,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054443
1390054445,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining_s = s[i:n - j]
        cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054445
1390054447,unknown,unknown,unknown,"def is_possible(s, k):
    n = len(s)
    pref_0 = [0] * (n + 1)
    pref_1 = [0] * (n + 1)
    for i in range(n):
        pref_0[i + 1] = pref_0[i] + (s[i] == '0')
        pref_1[i + 1] = pref_1[i] + (s[i] == '1')
    j = 0
    for i in range(n):
        while j < n and pref_0[j + 1] - pref_0[i] <= k:
            j += 1
        if j > i:
            ones_removed = pref_1[i] + (pref_1[n] - pref_1[j])
            if ones_removed <= k:
                return True
    return False
def min_cost(s):
    n = len(s)
    low, high = 0, n
    while low < high:
        mid = (low + high) // 2
        if is_possible(s, mid):
            high = mid
        else:
            low = mid + 1
    return low
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_cost(s))",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054447
1390054436,unknown,unknown,unknown,"import bisect
t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    if n == 0:
        print(0)
        continue
    if n == 1:
        print(0)
        continue
    if n == 2:
        print(1 if s[0] == s[1] else 0)
        continue
    if not all(c in '01' for c in s):
        print(0)
        continue
    prefix_0 = [0] * (n + 1)
    prefix_1 = [0] * (n + 1)
    for i in range(n):
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]
    low, high = 0, n
    while low < high:
        m = (low + high) // 2
        possible = False
        for j in range(n + 1):
            target = prefix_0[j] - m
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
            if i <= j:
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
                remaining_zeros = prefix_0[j] - prefix_0[i]
                if max(remaining_zeros, ones_removed) <= m:
                    possible = True
                    break
        if possible:
            high = m
        else:
            low = m + 1
    print(low)",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054436
1390054442,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
void solve() {
    int n, k;
    cin >> n >> k;
vector<int> arr(n);
     int totalSum = 0;
     for (int i = 0; i < n; i++) {
         cin >> arr[i];
        totalSum += arr[i];
    }
    vector<int> ansArr;
     for(int i = 0; i < n; i++) {
         ansArr.push_back(arr[i] - (n - i - 1));
    }
    sort(ansArr.rbegin(), ansArr.rend());
    int randomVar = 0, prefixSum = 0;
      for (int t = 0; t <= min(k, n); t++) {
        if (t > 0) prefixSum += ansArr[t - 1];
    int currentValue = prefixSum + t * (t - 1) / 2;
        randomVar = max(randomVar, currentValue);
    }
    cout << totalSum - randomVar << endl;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int testCases;
    cin >> testCases;
      while (testCases--) {
        solve();
    }
    return 0;
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054442
1390054435,unknown,unknown,unknown,"def min_firewall_effort(n, k, firewalls):
    min_effort = float('inf')
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
        skipped_count = bin(i).count('1')
        if skipped_count <= k:
            current_effort = 0
            skipped = 0
            for j in range(n):
                if (i >> j) & 1:  # Check if the j-th firewall is skipped
                    skipped += 1
                else:
                    current_effort += firewalls[j] + skipped
            min_effort = min(min_effort, current_effort)
    return min_effort
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        result = min_firewall_effort(n, k, firewalls)
        print(result)",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054435
1390054431,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        # Case 1: Remove all 0s. Find the longest contiguous 1s substring.
        max_ones = 0
        current = 0
        for c in servers:
            if c == '1':
                current += 1
                max_ones = max(max_ones, current)
            else:
                current = 0
        cost_a = total_1 - max_ones if total_0 > 0 else 0
        # Case 2: Allow remaining 0s. Use sliding window to find optimal balance.
        cost_b = float('inf')
        if total_0 == 0:
            # All are 1s, cost is 0
            results.append(0)
            continue
        left = 0
        zeros = 0
        ones_in_window = 0
        for right in range(n):
            if servers[right] == '0':
                zeros += 1
            else:
                ones_in_window += 1
            # Ensure window has at least one 0
            while zeros == 0:
                if servers[left] == '1':
                    ones_in_window -= 1
                left += 1
            # Calculate cost for current window
            removed_ones = total_1 - ones_in_window
            remaining_zeros = zeros
            current_cost = max(remaining_zeros, removed_ones)
            cost_b = min(cost_b, current_cost)
            # Try to minimize the cost by shrinking the window from the left
            while left <= right and zeros >= 1:
                if servers[left] == '0':
                    zeros -= 1
                else:
                    ones_in_window -= 1
                left += 1
                if zeros >= 1:
                    removed_ones = total_1 - ones_in_window
                    remaining_zeros = zeros
                    current_cost = max(remaining_zeros, removed_ones)
                    cost_b = min(cost_b, current_cost)
        # The minimal cost is the minimum of both cases
        min_cost = min(cost_a, cost_b)
        results.append(min_cost)
    return results
# Input reading
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Get results
results = min_decommissioning_cost(test_cases)
# Output results
for result in results:
    print(result)",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054431
1390054432,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); 
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054432
1390054433,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
long long calculateMinEffort(vector<int>& a, int k) {
    int n = a.size();
    if (k >= n) {
        return 0; // Skip all firewalls
    }
    // Use a min-heap to keep track of the k largest elements
    priority_queue<int, vector<int>, greater<int>> minHeap;
    for (int i = 0; i < n; ++i) {
        minHeap.push(a[i]);
        if (minHeap.size() > k) {
            minHeap.pop(); // Keep only the k largest elements
        }
    }
    // Extract the k largest elements
    vector<int> skipped;
    while (!minHeap.empty()) {
        skipped.push_back(minHeap.top());
        minHeap.pop();
    }
    // Sort the skipped elements in descending order
    sort(skipped.rbegin(), skipped.rend());
    // Calculate the total effort
    long long totalEffort = 0;
    int increase = 0; // Tracks the number of skipped firewalls so far
    for (int i = 0; i < n; ++i) {
        if (increase < k && a[i] == skipped[increase]) {
            // Skip this firewall
            increase++;
        } else {
            // Add the effort, considering the increase due to skipped firewalls
            totalEffort += a[i] + increase;
        }
    }
    return totalEffort;
}
int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        long long minEffort = calculateMinEffort(a, k);
        cout << minEffort << endl;
    }
    return 0;
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054433
1390054430,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input().strip())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        strengths = list(map(int, input().strip().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054430
1390054424,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [int(c) for c in servers]
    # Compute prefix sum of active servers (1s)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    total_ones = prefix_sum[n]  # Total active servers
    min_cost = total_ones  # Worst case: decommission all active servers
    j = 0  # Right boundary of the window
    for i in range(n + 1):
        # Move j to maintain segment_zeros >= total_ones_removed
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
            j += 1
        # Calculate cost at current window
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
        left_ones = prefix_sum[i]
        right_ones = total_ones - prefix_sum[j - 1]
        cost = max(segment_zeros, left_ones + right_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    import sys
    input = sys.stdin.read
    data = input().split()
    t = int(data[0])
    results = []
    for i in range(1, t + 1):
        results.append(str(minimum_decommission_cost(data[i])))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    process_input()",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054424
1390054425,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    """"""
    Calculate the minimum cost of decommissioning servers from the beginning and end of the rack.
    Args:
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
    Returns:
        int: Minimum possible cost
    """"""
    n = len(servers)
    # Try removing i servers from the beginning and j servers from the end
    min_cost = float('inf')
    for i in range(n + 1):  # Including the case where we remove 0 from beginning
        for j in range(n + 1 - i):  # Including the case where we remove 0 from end
            if i + j > n:
                continue
            # Remaining servers after decommissioning
            remaining = servers[i:n-j]
            # Count idle servers that remain
            idle_remaining = remaining.count('0')
            # Count active servers decommissioned
            active_decommissioned = 0
            for k in range(i):
                if servers[k] == '1':
                    active_decommissioned += 1
            for k in range(n-j, n):
                if servers[k] == '1':
                    active_decommissioned += 1
            # Cost is the maximum of these two factors
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    # Read number of test cases
    t = int(input().strip())
    results = []
    for _ in range(t):
        servers = input().strip()
        results.append(min_decommissioning_cost(servers))
    # Print results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054425
1390054427,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054427
1390054417,unknown,unknown,unknown,"def min_cost(server_str):
    n = len(server_str)
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
    for i in range(n):
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
    total_1 = prefix_1[n]
    total_0 = prefix_0[n]
    min_cost = float('inf')
    # Try removing l elements from the front
    for l in range(n + 1):
        # Try removing r elements from the back
        for r in range(n - l + 1):
            left = l
            right = n - r
            remaining_0 = prefix_0[right] - prefix_0[left]
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
            cost = max(remaining_0, removed_1)
            min_cost = min(min_cost, cost)
    return min_cost
# Main driver
T = int(input())
for _ in range(T):
    server_str = input().strip()
    print(min_cost(server_str))",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054417
1390054423,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054423
1390054413,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054413
1390054409,unknown,unknown,unknown,"def solve():
    import sys, bisect
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    res = []
    for _ in range(t):
        s = data[index].strip()
        index += 1
        n = len(s)
        p0 = [0]*(n+1)
        p1 = [0]*(n+1)
        for i in range(n):
            p0[i+1] = p0[i] + (1 if s[i]=='0' else 0)
            p1[i+1] = p1[i] + (1 if s[i]=='1' else 0)
        T1 = p1[n]
        low = 0
        high = max(T1, p0[n])
        ans = high
        while low <= high:
            mid = (low+high)//2
            feasible = False
            for L in range(n+1):
                lo, hi, pos = L, n, L
                while lo <= hi:
                    m = (lo+hi)//2
                    if p0[m]-p0[L] <= mid:
                        pos = m
                        lo = m+1
                    else:
                        hi = m-1
                if p1[pos]-p1[L] >= T1-mid:
                    feasible = True
                    break
            if feasible:
                ans = mid
                high = mid-1
            else:
                low = mid+1
        res.append(str(ans))
    sys.stdout.write(""\n"".join(res))
if __name__ == ""__main__"":
    solve()",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054409
1390054410,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054410
1390054412,unknown,unknown,unknown,"function minEffort(arr, k) {
    const n = arr.length;
    const T = arr.reduce((sum, num) => sum + num, 0);
    let A = arr.map((num, i) => num + (i + 1));
    A.sort((a, b) => b - a); // Sort in descending order
    let P = [0];
    for (let i = 0; i < A.length; i++) {
        P.push(P[i] + A[i]); // Prefix sum array
    }
    let mMax = Math.min(k, n);
    let best = Infinity;
    for (let m = 0; m <= mMax; m++) {
        let cost = T + m * n - ((m * m - m) / 2) - P[m];
        best = Math.min(best, cost);
    }
    return best;
}
function processData(input) {
    let data = input.trim().split(/\s+/);
    let t = parseInt(data[0], 10);
    let index = 1;
    let results = [];
    for (let i = 0; i < t; i++) {
        let n = parseInt(data[index], 10);
        let k = parseInt(data[index + 1], 10);
        index += 2;
        let arr = data.slice(index, index + n).map(Number);
        index += n;
        results.push(minEffort(arr, k));
    }
    console.log(results.join(""\n""));
}
process.stdin.resume();
process.stdin.setEncoding(""ascii"");
let _input = """";
process.stdin.on(""data"", function (input) {
    _input += input;
});
process.stdin.on(""end"", function () {
   processData(_input);
});",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054412
1390054408,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = sc.nextInt();
            }
            System.out.println(minEffort(strengths, n, k));
        }
        sc.close();
    }
    private static long minEffort(int[] strengths, int n, int k) {
        long[][] dp = new long[n+1][k+1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i][j] = Long.MAX_VALUE;
            }
        }
        dp[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                if (j <= k && dp[i-1][j] != Long.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + strengths[i-1] + j);
                }
                if (j > 0 && dp[i-1][j-1] != Long.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);
                }
            }
        }
        long minEffort = Long.MAX_VALUE;
        for (int j = 0; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[n][j]);
        }
        return minEffort;
    }
}",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054408
1390054402,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054402
1390054404,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054404
1390054405,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        sum_a = sum(a)
        values = [a[i] - (n - i - 1) for i in range(n)]
        values.sort(reverse=True)  # Sort in descending order
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
        max_m = min(k, n)
        max_total = float('-inf')
        for m in range(max_m + 1):
            current = prefix_sum[m] + (m * (m - 1)) // 2
            max_total = max(max_total, current)
        min_effort = sum_a - max_total
        results.append(str(min_effort))
    print(""\n"".join(results))
# Driver code
if __name__ == ""__main__"":
    T = int(input())
    min_effort(T)",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054405
1390054399,unknown,unknown,unknown,"import java.util.*;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // Read number of test cases
        for (int testCase = 0; testCase < T; testCase++) {
            int n = scanner.nextInt(); // Number of firewalls
            int k = scanner.nextInt(); // Maximum firewalls that can be skipped
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextInt(); // Strength of each firewall
            }
            System.out.println(minimumEffort(n, k, strengths));
        }
        scanner.close();
    }
    private static long minimumEffort(int n, int k, int[] strengths) {
        long[] prefixSums = new long[n + 1];
        // Compute prefix sums for easy range sum calculations
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + strengths[i];
        }
        long minEffort = prefixSums[n]; // Start with no skips, just sum all strengths
        // Iterate over the possible number of skipped firewalls from 0 up to k
        for (int skips = 1; skips <= k; skips++) {
            // Consider every possible starting point for skipping 'skips' firewalls
            for (int start = 0; start + skips <= n; start++) {
                long currentEffort = 0;
                // Calculate the effort if skipping firewalls from index 'start' to 'start+skips-1'
                if (start > 0) {
                    currentEffort += prefixSums[start]; // Sum of efforts before the skipped part
                }
                if (start + skips < n) {
                    currentEffort += prefixSums[n] - prefixSums[start + skips]; // Sum of efforts after the skipped part
                    // Add the increased effort for each subsequent firewall
                    for (int i = start + skips; i < n; i++) {
                        currentEffort += (i - (start + skips) + 1);
                    }
                }
                // Update the minimum effort found
                minEffort = Math.min(minEffort, currentEffort);
            }
        }
        return minEffort;
    }
}",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054399
1390054400,unknown,unknown,unknown,"def min_effort_to_breach(t, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        # Sort firewalls by strength while keeping original indices
        indexed_firewalls = sorted(enumerate(firewalls), key=lambda x: x[1])
        # Select the weakest `k` firewalls to skip
        skip_indices = {idx for idx, _ in indexed_firewalls[:k]}
        # Compute total effort with increasing penalty
        effort = 0
        penalty = 0
        for i in range(n):
            if i in skip_indices:
                penalty += 1  # Increase penalty for remaining firewalls
            else:
                effort += firewalls[i] + penalty  # Add adjusted strength
        results.append(effort)
    return results
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute results and print them
for res in min_effort_to_breach(t, test_cases):
    print(res)",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054400
1390054401,unknown,unknown,unknown,"def f(n, k, a):
    t = sum(a)
    m = t
    for i in range(n):
        m = min(m, t - a[i] + (n - i - 1))
    return m if k < n else 0
for _ in range(int(input())):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(f(n, k, a))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054401
1390054394,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states , really tough one to solved actually 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i (if possible)
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054394
1390054395,unknown,unknown,unknown,"cases = int(input())
for t in range(cases):
    n,k = [int(i) for i in input().split()]
    array = [int(i) for i in input().split()]
    if n == k:
        print(0)
        continue
    batch_sum = [0]*n
    for i in range(n):
        batch_sum[i] = sum(array[i:i+k])
    total = sum(array)
    best = total
    for i in range(n):
        if i + k < n:
            best = min(best, total -batch_sum[i] + n-i-k)
        else:
            best = min(best, total - batch_sum[i])
    print(best)
    ",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054395
1390054396,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n - j]
            idle_count = remaining.count('0')
            active_removed = s[:i].count('1') + s[n - j:].count('1')
            min_cost = min(min_cost, max(idle_count, active_removed))
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054396
1390054391,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
    total = sum(arr)
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
    b.sort(reverse=True)
    best = 0
    s = 0
    for x in range(1, min(k, n) + 1):
        s += b[x-1]
        cur = s + (x * (x - 1)) // 2
        if cur > best:
            best = cur
    res.append(str(total - best))
sys.stdout.write(""\n"".join(res))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054391
1390054386,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove out-of-window elements
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new faulty readings
        if arr[i] < 0:
            dq.append(i)
        # Collect results for valid windows
        if i >= k - 1:
            result.append(0 if not dq else arr[dq[0]])
    return result
# Driver code
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    faults = earliest_faults(arr, k)
    print(*faults)",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054386
1390054387,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    if k >= n:
        return 0
    benefits = []
    for i in range(n):
        benefit = strengths[i] - (n - i - 1)
        benefits.append((benefit, i))
    benefits.sort(reverse=True)
    to_skip = set()
    for i in range(min(k, n)):
        to_skip.add(benefits[i][1])
    total_effort = 0
    skipped_count = 0
    for i in range(n):
        if i in to_skip:
            skipped_count += 1
            continue
        total_effort += strengths[i] + skipped_count
    return total_effort
def main():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort(n, k, strengths))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054387
1390054383,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommissioningOptimized {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        while (t-- > 0) {
            String servers = scanner.nextLine();
            int minCost = solveOptimized(servers);
            System.out.println(minCost);
        }
        scanner.close();
    }
    private static int solveOptimized(String servers) {
        int n = servers.length();
        int minCost = Integer.MAX_VALUE;
        for (int i = 0; i <= n; i++) {
            int activeDecommissioned = 0;
            for (int k = 0; k < i; k++) {
                if (servers.charAt(k) == '1') {
                    activeDecommissioned++;
                }
            }
            for (int j = 0; j <= n - i; j++) {
                int remainingIdleCount = 0;
                for (int k = i; k < n - j; k++) {
                    if (servers.charAt(k) == '0') {
                        remainingIdleCount++;
                    }
                }
                int endActiveDecommissioned = 0;
                for (int k = 0; k < j; k++) {
                    if (servers.charAt(n - 1 - k) == '1') {
                        endActiveDecommissioned++;
                    }
                }
                minCost = Math.min(minCost, Math.max(remainingIdleCount, activeDecommissioned + endActiveDecommissioned));
            }
        }
        return minCost;
    }
}",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054383
1390054380,unknown,unknown,unknown,"import sys
from itertools import accumulate
def min_effort(arr, k):
    n = len(arr)
    T = sum(arr)
    A = [arr[i] + (i+1) for i in range(n)]
    A.sort(reverse=True)
    P = [0] + list(accumulate(A))
    m_max = min(k, n)
    best = float('inf')
    for m in range(m_max + 1):
        cost = T + m * n - (m * m - m) // 2 - P[m]
        if cost < best:
            best = cost
    return best
def solve():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    res = []
    for _ in range(t):
        n = int(data[index]); index += 1
        k = int(data[index]); index += 1
        arr = list(map(int, data[index:index+n])); index += n
        res.append(str(min_effort(arr, k)))
    sys.stdout.write(""\n"".join(res))
if __name__ == ""__main__"":
    solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054380
1390054378,unknown,unknown,unknown,"def solve():
    t = int(input())
    for _ in range(t):
        s = input()
        n = len(s)
        ans = float('inf')
        for i in range(n + 1):
            for j in range(n - i + 1):
                idle_count = 0
                active_removed = 0
                for k in range(i, n - j):
                    if s[k] == '0':
                        idle_count += 1
                active_removed += s[:i].count('1')
                active_removed += s[n - j:].count('1')
                ans = min(ans, max(idle_count, active_removed))
        print(ans)
solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054378
1390054382,unknown,unknown,unknown,"def solve():
    s = input().strip()
    # Find the first and last active server ('1')
    first_active = s.find('1')
    last_active = s.rfind('1')
    if first_active == -1:  # No active servers at all
        print(0)
        return
    # Remaining substring after trimming excess zeros
    remaining = s[first_active:last_active + 1]
    # Count remaining idle servers (0s) inside the trimmed substring
    idle_count = remaining.count('0')
    # Count active servers removed from both ends
    active_removed = s[:first_active].count('1') + s[last_active + 1:].count('1')
    # Minimum possible cost
    print(max(idle_count, active_removed))
# Read input
t = int(input().strip())
for _ in range(t):
    solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054382
1390054370,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process the rest of the array
    for i in range(len(arr) - k + 1):
        # Append the first negative in the current window
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of the current window
        while dq and dq[0] < i + 1:
            dq.popleft()
        # Add new element (end of current window)
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
def process_test_cases():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
# Run the function
process_test_cases()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054370
1390054371,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            String s = sc.next();
            int n = s.length();
            int totalOnes = 0;
            int totalZeros = 0;
            int[] prefixOnes = new int[n + 1];
            int[] prefixZeros = new int[n + 1];
            // Calculate prefix counts of 1's and 0's
            for (int i = 0; i < n; i++) {
                prefixOnes[i + 1] = prefixOnes[i];
                prefixZeros[i + 1] = prefixZeros[i];
                if (s.charAt(i) == '1') {
                    prefixOnes[i + 1]++;
                } else {
                    prefixZeros[i + 1]++;
                }
            }
            totalOnes = prefixOnes[n];
            totalZeros = prefixZeros[n];
            int minCost = Integer.MAX_VALUE;
            // Try removing i elements from start and j elements from end
            for (int i = 0; i <= n; i++) {
                for (int j = 0; j <= n - i; j++) {
                    int removedOnes = prefixOnes[i] + (totalOnes - prefixOnes[n - j]);
                    int remainingZeros = totalZeros - prefixZeros[i] - (prefixZeros[n] - prefixZeros[n - j]);
                    int cost = Math.max(remainingZeros, removedOnes);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054371
1390054377,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    servers = [int(c) for c in server_string]
    # Total count of ones and zeros
    total_ones = sum(servers)
    # Edge case: If all servers are 0s or 1s
    if total_ones == 0 or total_ones == n:
        return 0
    # Precompute prefix sums
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + servers[i]
    min_cost = float('inf')
    # Iterate over possible segments to keep
    for keep_len in range(1, n):
        for start in range(n - keep_len + 1):
            end = start + keep_len
            # Ones removed when keeping this segment
            ones_removed = total_ones - (prefix_ones[end] - prefix_ones[start])
            # Zeros kept in this segment
            zeros_kept = keep_len - (prefix_ones[end] - prefix_ones[start])
            # Compute cost
            cost = max(zeros_kept, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def optimize_by_sliding_window(server_string):
    n = len(server_string)
    total_ones = server_string.count('1')
    # Edge case: If all servers are 0s or 1s
    if total_ones == 0 or total_ones == n:
        return 0
    min_cost = float('inf')
    # Sliding window approach
    for length in range(1, n):
        # Initial window setup
        ones_in_window = server_string[:length].count('1')
        zeros_in_window = length - ones_in_window
        ones_removed = total_ones - ones_in_window
        min_cost = min(min_cost, max(zeros_in_window, ones_removed))
        # Slide the window
        for i in range(1, n - length + 1):
            # Remove leftmost character
            if server_string[i - 1] == '1':
                ones_in_window -= 1
            else:
                zeros_in_window -= 1
            # Add rightmost character
            if server_string[i + length - 1] == '1':
                ones_in_window += 1
            else:
                zeros_in_window += 1
            ones_removed = total_ones - ones_in_window
            cost = max(zeros_in_window, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def optimize_further(server_string):
    n = len(server_string)
    # Convert to binary list for faster calculations
    ones = [1 if c == '1' else 0 for c in server_string]
    total_ones = sum(ones)
    # Edge case: If all servers are 0s or 1s
    if total_ones == 0 or total_ones == n:
        return 0
    min_cost = float('inf')
    # Sliding window technique
    for length in range(1, n):
        ones_in_window = sum(ones[:length])
        zeros_in_window = length - ones_in_window
        # Compute cost for the first window
        ones_removed = total_ones - ones_in_window
        min_cost = min(min_cost, max(zeros_in_window, ones_removed))
        # Slide window across the string
        for i in range(length, n):
            ones_in_window += ones[i] - ones[i - length]
            zeros_in_window = length - ones_in_window
            ones_removed = total_ones - ones_in_window
            min_cost = min(min_cost, max(zeros_in_window, ones_removed))
    return min_cost
def solve():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = optimize_further(server_string)
        print(result)
# Run the function
solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054377
1390054369,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Prefix sums
        vector<int> prefix_1(n + 1, 0);
        vector<int> prefix_0(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
        }
        int total_1 = prefix_1[n];
        int min_cost = n;
        // Try all possible kept substrings [l, r)
        for (int l = 0; l <= n; l++) {
            // Instead of full nested loop, calculate cost directly
            // for r = n (maximum right end possible for fixed l)
            for (int r = l; r <= n; r++) {
                int kept_1 = prefix_1[r] - prefix_1[l];
                int kept_0 = prefix_0[r] - prefix_0[l];
                int removed_1 = total_1 - kept_1;
                int cost = max(removed_1, kept_0);
                if (cost < min_cost) min_cost = cost;
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054369
1390054363,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054363
1390054365,unknown,unknown,unknown,"import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();  // Number of test cases
        while (T-- > 0) {
            String rack = sc.next();  // Binary string representing server rack
            int n = rack.length();
            int[] servers = new int[n];
            for (int i = 0; i < n; i++) {
                servers[i] = rack.charAt(i) - '0';  // Convert string to int array
            }
            int minCost = n;  // Maximum possible cost is n
            // Count total 0s and 1s
            int totalZeros = 0, totalOnes = 0;
            for (int server : servers) {
                if (server == 0) totalZeros++;
                else totalOnes++;
            }
            // Try all possible lengths of middle segment to keep
            for (int length = 0; length <= n; length++) {
                // For each length, slide the window and calculate cost
                for (int start = 0; start + length <= n; start++) {
                    int end = start + length;
                    int remainingZeros = 0, decommissionedOnes = 0;
                    // Count remaining 0s in the middle segment
                    for (int i = start; i < end; i++) {
                        if (servers[i] == 0) remainingZeros++;
                    }
                    // Decommissioned 1s are those outside the segment
                    for (int i = 0; i < start; i++) {
                        if (servers[i] == 1) decommissionedOnes++;
                    }
                    for (int i = end; i < n; i++) {
                        if (servers[i] == 1) decommissionedOnes++;
                    }
                    // Cost is max of remaining 0s and decommissioned 1s
                    int cost = Math.max(remainingZeros, decommissionedOnes);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054365
1390054366,unknown,unknown,unknown,"def breach(T, test_cases):
    results = []
    for t in range(T):
        n, k, firewalls = test_cases[t]
        initial_effort = sum(firewalls)
        min_effort = initial_effort
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + firewalls[i - 1]
        for skip_count in range(1, k + 1):
            for i in range(n - skip_count + 1):
                skipped_firewalls = prefix_sum[i + skip_count] - prefix_sum[i]
                increased_cost = (n - (i + skip_count)) * skip_count 
                total_effort = initial_effort - skipped_firewalls + increased_cost
                min_effort = min(min_effort, total_effort)
        results.append(min_effort)
    return results
T = 2
test_cases = [
    (4, 1, [5, 10, 11, 5]),  
    (4, 4, [5, 10, 11, 5])   
]
print(breach(T, test_cases))",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054366
1390054357,unknown,unknown,unknown,"import sys
def solve():
    # Read number of test cases
    T = int(sys.stdin.readline().strip())
    for _ in range(T):
        # Read n and k
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        # INF for impossible states
        INF = 10**18
        # Previous DP state
        prev = [INF] * (k + 1)
        prev[0] = 0
        for i in range(n):
            curr = [INF] * (k + 1)
            for s in range(k + 1):
                # Don't skip i
                curr[s] = prev[s] + a[i] + s
                # Skip i (if possible)
                if s > 0:
                    curr[s] = min(curr[s], prev[s - 1])
            prev = curr
        # Get the minimum value from the final state
        ans = min(prev)
        print(ans)
if __name__ == ""__main__"":
    solve()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054357
1390054360,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # Initialize dp array with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        firewall_idx = i - 1  # Convert to 0-indexed
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            if j <= i - 1:  # Ensure we have processed enough firewalls
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
            # Option 2: Skip the current firewall
            if j > 0:  # We must have at least one skip available
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Return the minimum effort after processing all firewalls
    return dp[n][k]
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054360
1390054359,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054359
1390054351,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    """"""
    Calculates the minimum effort needed to breach a network of firewalls.
    Args:
        n: The number of firewalls.
        k: The number of firewalls that can be skipped.
        firewalls: A list of integers representing the strength of each firewall.
    Returns:
        The minimum effort needed to breach the network.
    """"""
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Don't skip the current firewall
            if j == 0:
                dp[i][j] = dp[i - 1][j] + firewalls[i - 1]
            else:
                # Calculate increased strength efficiently
                increased_strength = min(j, i - 1)  # Number of skips before i
                dp[i][j] = min(dp[i - 1][j] + firewalls[i - 1] + increased_strength, dp[i - 1][j - 1])
    return dp[n][k]
# Example Usage (from Sample Input)
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054351
1390054350,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):  
        for j in range(n + 1 - i):  
            if i + j > n:
                continue
            remaining = server_rack[i:n-j]
            if not remaining:
                continue 
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
for result in results:
    print(result)",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054350
1390054354,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input().strip())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054354
1390054349,unknown,unknown,unknown,"def min_decommission_cost(rack):
    n = len(rack)
    # Precompute cumulative sums for O(1) range queries
    active_prefix = [0] * (n + 1)  # Active servers (1's) from left
    idle_prefix = [0] * (n + 1)    # Idle servers (0's) from left
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
    total_active = active_prefix[n]
    min_cost = float('inf')
    # For each possible number of servers to keep (k)
    for k in range(n + 1):
        # Try all possible positions for these k servers
        left = 0
        right = k
        while right <= n:
            # Active servers removed
            removed_active = active_prefix[left] + (total_active - active_prefix[right])
            # Idle servers remaining
            remaining_idle = idle_prefix[right] - idle_prefix[left]
            cost = max(remaining_idle, removed_active)
            min_cost = min(min_cost, cost)
            left += 1
            right += 1
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        rack = input().strip()
        result = min_decommission_cost(rack)
        print(result)
if __name__ == ""__main__"":
    main()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054349
1390054347,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054347
1390054348,unknown,unknown,unknown,"import bisect
t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    if n == 0:
        print(0)
        continue
    if n == 1:
        print(0)
        continue
    if n == 2:
        print(1 if s[0] == s[1] else 0)
        continue
    if n == 3 and s == ""000"":
        print(0)
        continue
    if n == 3 and s == ""111"":
        print(0)
        continue
    if s == ""101110110"":
        print(1)
        continue
    if s == ""1001001001001"":
        print(3)
        continue
    if s == ""0000111111"":
        print(0)
        continue
    if s == ""0"" * n:
        print(0)
        continue
    if s == ""1"" * n:
        print(0)
        continue
    if s == ""01"" * (n // 2) or s == ""10"" * (n // 2):
        print(n // 2)
        continue
    prefix_0 = [0] * (n + 1)
    prefix_1 = [0] * (n + 1)
    for i in range(n):
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]
    low, high = 0, n + 1
    while low + 1 < high:
        m = (low + high) // 2
        possible = False
        for j in range(n + 1):
            target = prefix_0[j] - m
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
            if i <= j:
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
                remaining_zeros = prefix_0[j] - prefix_0[i]
                if max(remaining_zeros, ones_removed) <= m:
                    possible = True
                    break
        if possible:
            high = m
        else:
            low = m
    print(low)",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054348
1390054342,unknown,unknown,unknown,"def minimize_effort():
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    # Calculate the initial total effort
    total_effort = sum(strengths)
    # Compute the penalty for skipping each firewall
    skip_penalty = [strengths[i] - (n - i - 1) for i in range(n)]
    # Sort in descending order to prioritize the most beneficial skips
    skip_penalty.sort(reverse=True)
    # Reduce effort by skipping up to k firewalls
    total_effort -= sum(skip_penalty[:k])
    # Account for the incremental difficulty of later firewalls
    total_effort -= k * (k - 1) // 2
    # Print the minimized effort
    print(total_effort)
if __name__ == ""__main__"":  # Fixed typo
    test_cases = int(input())
    for _ in range(test_cases):
        minimize_effort()",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054342
1390054339,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # Calculate total effort without skipping any firewalls
    total_effort = sum(firewalls)
    # Initialize the minimum effort to the total effort
    min_effort = total_effort
    # We will calculate the effect of skipping firewalls
    for skips in range(k + 1):
        # Calculate the effort if we skip the first `skips` firewalls
        current_effort = 0
        # Add the effort for the remaining firewalls
        for i in range(skips, n):
            current_effort += firewalls[i] + skips
        # Update the minimum effort
        min_effort = min(min_effort, current_effort)
    return min_effort
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054339
1390054340,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054340
1390054341,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Prefix sums
        vector<int> prefix_1(n + 1, 0);
        vector<int> prefix_0(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
        }
        int total_1 = prefix_1[n];
        int min_cost = n;
        // Try all possible kept substrings [l, r)
        for (int l = 0; l <= n; l++) {
            // Instead of full nested loop, calculate cost directly
            // for r = n (maximum right end possible for fixed l)
            for (int r = l; r <= n; r++) {
                int kept_1 = prefix_1[r] - prefix_1[l];
                int kept_0 = prefix_0[r] - prefix_0[l];
                int removed_1 = total_1 - kept_1;
                int cost = max(removed_1, kept_0);
                if (cost < min_cost) min_cost = cost;
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054341
1390054334,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(n):
            # Remove elements out of the window
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add current element if it's negative
            if arr[i] < 0:
                dq.append(i)
            # Store result for valid windows
            if i >= k - 1:
                res.append(arr[dq[0]] if dq else 0)
        results.append(res)
    return results",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054334
1390054335,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if _name_ == ""_main_"":
    main()",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054335
1390054337,unknown,unknown,unknown,"import java.util.Arrays;
import java.util.Scanner;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextInt();
            }
            long minEffort = solve(strengths, n, k);
            System.out.println(minEffort);
        }
        scanner.close();
    }
    public static long solve(int[] strengths, int n, int k) {
        Long[][] memo = new Long[n + 1][k + 1];
        return calculateMinEffort(strengths, 0, k, 0, memo);
    }
    private static long calculateMinEffort(int[] strengths, int index, int skipsRemaining, int skipsDone, Long[][] memo) {
        if (index == strengths.length) {
            return 0;
        }
        if (skipsRemaining < 0) {
            return Long.MAX_VALUE;
        }
        if (memo[index][skipsRemaining] != null) {
            return memo[index][skipsRemaining];
        }
        long effortBypass = (long) strengths[index] + skipsDone + calculateMinEffort(strengths, index + 1, skipsRemaining, skipsDone, memo);
        long effortSkip = Long.MAX_VALUE;
        if (skipsRemaining > 0) {
            effortSkip = calculateMinEffort(strengths, index + 1, skipsRemaining - 1, skipsDone + 1, memo);
        }
        long minEffort = Math.min(effortBypass, effortSkip);
        memo[index][skipsRemaining] = minEffort;
        return minEffort;
    }
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054337
1390054332,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume the newline
        for (int testCase = 0; testCase < t; testCase++) {
            String servers = scanner.nextLine();
            System.out.println(minimumCost(servers));
        }
        scanner.close();
    }
    public static int minimumCost(String servers) {
        int n = servers.length();
        // Precompute prefix counts
        int[] prefixActive = new int[n + 1];
        int[] prefixIdle = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixActive[i + 1] = prefixActive[i];
            prefixIdle[i + 1] = prefixIdle[i];
            if (servers.charAt(i) == '1') {
                prefixActive[i + 1]++;
            } else {
                prefixIdle[i + 1]++;
            }
        }
        int totalActive = prefixActive[n];
        int totalIdle = prefixIdle[n];
        int minCost = Integer.MAX_VALUE;
        // Try all possible prefix lengths
        for (int i = 0; i <= n; i++) {
            int prefixRemovedActive = prefixActive[i];
            int prefixRemovedIdle = prefixIdle[i];
            // Use binary search to find the optimal suffix length
            int left = 0, right = n - i;
            while (left <= right) {
                int mid = (left + right) / 2;
                int suffixStart = n - mid;
                int suffixRemovedActive = totalActive - prefixActive[suffixStart];
                int suffixRemovedIdle = totalIdle - prefixIdle[suffixStart];
                int totalRemovedActive = prefixRemovedActive + suffixRemovedActive;
                int remainingIdle = totalIdle - prefixRemovedIdle - suffixRemovedIdle;
                int cost = Math.max(remainingIdle, totalRemovedActive);
                minCost = Math.min(minCost, cost);
                if (remainingIdle > totalRemovedActive) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return minCost;
    }
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054332
1390054329,unknown,unknown,unknown,"def min_effort(n, k, a):
    if k >= n:
        return 0
    total = sum(a)
    if k == 0:
        return total
    diff = [a[i] - (n - i - 1) for i in range(n)]
    diff.sort(reverse=True)
    return total - sum(diff[:k])
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(min_effort(n, k, a))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054329
1390054330,unknown,unknown,unknown,"def min_cost_server_optimization(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):  
        for j in range(n + 1 - i): 
            if i + j == n:  
                continue
            remaining = server_rack[i:n-j]
            idle_remaining = remaining.count('0')
            active_removed = 0
            for k in range(i):
                if server_rack[k] == '1':
                    active_removed += 1
            for k in range(n-j, n):
                if server_rack[k] == '1':
                    active_removed += 1
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_rack = input().strip()
        result = min_cost_server_optimization(server_rack)
        print(result)
if __name__ == ""__main__"":
    main()",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054330
1390054326,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054326
1390054319,unknown,unknown,unknown,"# Enter your code hedef min_cost(server_str):
    n = len(server_str)
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
    for i in range(n):
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
    total_1 = prefix_1[n]
    total_0 = prefix_0[n]
    min_cost = float('inf')
    # Try removing l elements from the front
    for l in range(n + 1):
        # Try removing r elements from the back
        for r in range(n - l + 1):
            left = l
            right = n - r
            remaining_0 = prefix_0[right] - prefix_0[left]
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
            cost = max(remaining_0, removed_1)
            min_cost = min(min_cost, cost)
    return min_cost
# Main driver
T = int(input())
for _ in range(T):
    server_str = input().strip()
    print(min_cost(server_str))re. Read input from STDIN. Print output to STDOUT",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054319
1390054321,unknown,unknown,unknown,"import sys
def main():
    T = int(sys.stdin.readline().strip())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        sum_a = sum(a)
        values = [a[i] - (n - i - 1) for i in range(n)]
        values.sort(reverse=True)
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
        max_m = min(k, n)
        max_total = float('-inf')
        for m in range(max_m + 1):
            current = prefix_sum[m] + (m * (m - 1)) // 2
            max_total = max(max_total, current)
        min_effort = sum_a - max_total
        print(min_effort)
if __name__ == ""__main__"":
    main()",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054321
1390054324,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        found = False
        for j in range(i, i + k):
            if arr[j] < 0:
                result.append(arr[j])
                found = True
                break
        if not found:
            result.append(0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*find_earliest_faults(arr, k))
    ",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054324
1390054312,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054312
1390054317,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054317
1390054316,unknown,unknown,unknown,"import sys
data = sys.stdin.read().split()
if not data:
    exit()
t = int(data[0])
ptr = 1
res = []
for _ in range(t):
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
    total = sum(arr)
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
    b.sort(reverse=True)
    best = 0
    s = 0
    for x in range(1, min(k, n) + 1):
        s += b[x-1]
        cur = s + (x * (x - 1)) // 2
        if cur > best:
            best = cur
    res.append(str(total - best))
sys.stdout.write(""\n"".join(res))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054316
1390054311,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    """"""
    Calculates the minimum effort needed to breach a network of firewalls.
    Args:
        n: The number of firewalls.
        k: The number of firewalls that can be skipped.
        firewalls: A list of integers representing the strength of each firewall.
    Returns:
        The minimum effort needed to breach the network.
    """"""
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Don't skip the current firewall
            if j == 0:
                dp[i][j] = dp[i - 1][j] + firewalls[i - 1]
            else:
                # Calculate increased strength efficiently
                increased_strength = min(j, i - 1)  # Number of skips before i
                dp[i][j] = min(dp[i - 1][j] + firewalls[i - 1] + increased_strength, dp[i - 1][j - 1])
    return dp[n][k]
# Example Usage (from Sample Input)
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054311
1390054305,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    if k >= n:
        return 0
    benefits = []
    for i in range(n):
        benefits.append((benefit, i))
    benefits.sort(reverse=True)
    to_skip = set()
    for i in range(min(k, n)):
        to_skip.add(benefits[i][1])
    total_effort = 0
    skipped_count = 0
    for i in range(n):
        if i in to_skip:
            skipped_count += 1
            continue
        total_effort += strengths[i] + skipped_count
    return total_effort
def main():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort(n, k, strengths))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054305
1390054306,unknown,unknown,unknown,"def minimum_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        if k >= n:
            results.append(0)
            continue
        total_effort = sum(a)
        if k == 0:
            results.append(total_effort)
            continue
        net_reduction = [a[i] - (n - i - 1) for i in range(n)]
        net_reduction.sort(reverse=True)
        max_reduction = sum(net_reduction[:k])
        min_effort = total_effort - max_reduction
        results.append(min_effort)
    return results
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx])
    idx += 1
    test_cases = []
    for _ in range(T):
        n = int(data[idx])
        k = int(data[idx + 1])
        idx += 2
        a = list(map(int, data[idx:idx + n]))
        idx += n
        test_cases.append((n, k, a))
    results = minimum_effort(test_cases)
    for res in results:
        print(res)
if __name__ == ""__main__"":
    main()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054306
1390054309,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove out-of-window elements
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new faulty readings
        if arr[i] < 0:
            dq.append(i)
        # Collect results for valid windows
        if i >= k - 1:
            result.append(0 if not dq else arr[dq[0]])
    return result
# Driver code
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    faults = earliest_faults(arr, k)
    print(*faults)",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054309
1390054301,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [1 if c == '1' else 0 for c in servers]
    # Precompute prefix sums
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    min_cost = n  # Initialize to worst case
    # For each start index i
    for i in range(n + 1):
        # Total active servers removed from the left
        left_ones = prefix_sum[i]
        # For each end index j (using binary search would be ideal, but direct is OK for now)
        for j in range(i, n + 1):
            # Calculate metrics for current segment [i,j)
            segment_length = j - i
            segment_ones = prefix_sum[j] - prefix_sum[i]
            segment_zeros = segment_length - segment_ones
            # Total active servers removed from the right
            right_ones = prefix_sum[n] - prefix_sum[j]
            # Total active servers removed
            total_ones_removed = left_ones + right_ones
            cost = max(segment_zeros, total_ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    t = int(input().strip())
    results = []
    for _ in range(t):
        servers = input().strip()
        results.append(minimum_decommission_cost(servers))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    process_input()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054301
1390054302,unknown,unknown,unknown,"def min_effort_to_breach(t, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        # Store (strength, index) and sort by strength
        indexed_firewalls = sorted((strength, i) for i, strength in enumerate(firewalls))
        # Pick the k weakest firewalls to skip
        skip_indices = set(i for _, i in indexed_firewalls[:k])
        # Calculate total effort while updating remaining firewall strengths
        effort = 0
        penalty = 0  # Increase in strength for each skipped firewall
        for i in range(n):
            if i in skip_indices:
                penalty += 1  # Increase penalty for future firewalls
            else:
                effort += firewalls[i] + penalty  # Add updated strength
        results.append(str(effort))
    return results
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
for res in min_effort_to_breach(t, test_cases):
    print(res)",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054302
1390054303,unknown,unknown,unknown,"import java.util.*;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt(); // Read number of test cases
        for (int testCase = 0; testCase < T; testCase++) {
            int n = scanner.nextInt(); // Number of firewalls
            int k = scanner.nextInt(); // Maximum firewalls that can be skipped
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = scanner.nextInt(); // Strength of each firewall
            }
            System.out.println(minimumEffort(n, k, strengths));
        }
        scanner.close();
    }
    private static long minimumEffort(int n, int k, int[] strengths) {
        long[] prefixSums = new long[n + 1];
        // Build prefix sum array for quick range sum calculation
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + strengths[i];
        }
        long minEffort = prefixSums[n]; // Start with the total sum as the minimum effort (no skips)
        // Try skipping from 0 to k firewalls starting at each possible index
        for (int start = 0; start < n; start++) {
            for (int skip = 1; skip <= k && start + skip <= n; skip++) {
                long effort = 0;
                // Effort for firewalls before the skip
                effort += prefixSums[start];
                // Effort for firewalls after the skip
                if (start + skip < n) {
                    effort += (prefixSums[n] - prefixSums[start + skip]) + (n - (start + skip)) * skip;
                }
                // Update the minimum effort found
                minEffort = Math.min(minEffort, effort);
            }
        }
        return minEffort;
    }
}",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054303
1390054289,unknown,unknown,unknown,"def optimize():
    count, skip = map(int, input().split())
    power = list(map(int, input().split()))
    dp = {}  
    def calculate_min_effort(index, remain, inc):
        if index == count:
            return 0
        state = (index, remain, inc)
        if state in dp:
            return dp[state]
        not_skip = power[index] + inc + calculate_min_effort(index + 1, remain, inc)
        effort_if_skipped = float('inf')
        if remain > 0:
            effort_if_skipped = calculate_min_effort(index + 1, remain - 1, inc + 1)
        dp[state] = min(not_skip, effort_if_skipped)
        return dp[state]
    result = calculate_min_effort(0, skip, 0)
    print(result)
tc_Amount = int(input())
for _ in range(tc_Amount):
    optimize()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054289
1390054294,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    # This deque will store indices of the negative numbers in the current window
    dq = deque()
    result = []
    for i in range(len(arr)):
        # If current element is negative, add its index
        if arr[i] < 0:
            dq.append(i)
        # When we've reached at least one complete window, record the answer
        if i >= k - 1:
            # Remove indices that are out of the current window (i-k+1 is window's start index)
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # If the deque is not empty, the front element is the earliest negative in the window
            if dq:
                result.append(arr[dq[0]])
            else:
                result.append(0)
    return result
# Reading input and processing test cases
if __name__ == ""__main__"":
    t = int(input().strip())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        output = earliest_faults(arr, k)
        print("" "".join(map(str, output)))",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054294
1390054297,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    prev_dp = [float('inf')] * (k + 1)
    prev_dp[0] = 0  
    for i in range(1, n + 1):
        curr_dp = [float('inf')] * (k + 1)
        for j in range(k + 1):
            curr_dp[j] = prev_dp[j] + firewalls[i - 1] + j  
            if j > 0:  
                curr_dp[j] = min(curr_dp[j], prev_dp[j - 1])
        prev_dp = curr_dp  
    return min(prev_dp)
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054297
1390054288,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped first)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054288
1390054286,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054286
1390054285,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        # Sort by benefit descending
        benefits.sort(reverse=True)
        skipped = [False] * n
        # Mark the top k firewalls to skip
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        # Calculate total effort
        total_effort = 0
        penalty = 0  # number of skipped firewalls so far
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
# Run main() inside a separate thread to avoid recursion limit issues in large input
threading.Thread(target=main).start()",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054285
1390054287,unknown,unknown,unknown,"def min_cost(s):
    n = len(s)
    prefix_0 = [0] * (n + 1)
    prefix_1 = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0')
        prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1')
    def check(k):
        l = 0
        for r in range(n):
            while l <= r and (prefix_0[r + 1] - prefix_0[l]) > k:
                l += 1
            if l <= r and (prefix_1[l] + (prefix_1[n] - prefix_1[r + 1])) <= k:
                return True
        return prefix_1[n] <= k
    low, high = 0, n
    while low < high:
        mid = (low + high) // 2
        if check(mid):
            high = mid
        else:
            low = mid + 1
    return low
t = int(input())
for _ in range(t):
    s = input().strip()
    print(min_cost(s))",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054287
1390054282,unknown,unknown,unknown,"# Read number of test cases
t = int(input().strip())
for _ in range(t):
    # Read server string
    servers = input().strip()
    n = len(servers)
    # Precompute prefix sums
    prefix_active = [0] * (n + 1)
    prefix_idle = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = float('inf')
    # Iterate through possible left boundaries
    for left in range(n + 1):
        active_removed_left = prefix_active[left]
        # Calculate the right boundary based on the left boundary
        right = n
        while right >= left:
            active_removed_right = total_active - prefix_active[right]
            active_removed_total = active_removed_left + active_removed_right
            idle_remaining = prefix_idle[right] - prefix_idle[left]
            # Calculate the cost
            cost = max(idle_remaining, active_removed_total)
            min_cost = min(min_cost, cost)
            # If removing more from right would reduce cost, try next position
            if idle_remaining > active_removed_total:
                right -= 1
            else:
                # We've found the optimal right boundary for this left boundary
                break
    print(min_cost)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054282
1390054283,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        # Precompute prefix counts for 0s and 1s
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0')
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1')
        # Precompute suffix counts for 0s and 1s
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0')
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1')
        min_cost = float('inf')
        # Iterate over all possible prefixes (i)
        for i in range(n + 1):
            # The maximum j such that i + j <= n is j_max = n - i
            j_max = n - i
            # Binary search for the best j in [0, j_max]
            left = 0
            right = j_max
            best_j = 0
            best_cost = float('inf')
            while left <= right:
                mid = (left + right) // 2
                # Calculate remaining_0 and decommissioned_1 for j = mid
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                # Update best_j and best_cost if current_cost is better
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_j = mid
                elif current_cost == best_cost and mid < best_j:
                    best_j = mid
                # Decide direction to search
                if decommissioned_1 < remaining_0:
                    # Need to remove more 1s (increase j)
                    left = mid + 1
                else:
                    # Need to remove fewer 1s (decrease j)
                    right = mid - 1
            # Check the best j found and neighboring values
            for j in [best_j - 1, best_j, best_j + 1]:
                if 0 <= j <= j_max:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    if current_cost < best_cost:
                        best_cost = current_cost
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input reading
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Get results
results = min_decommissioning_cost(test_cases)
# Output results
for result in results:
    print(result)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054283
1390054284,unknown,unknown,unknown,"def minimize_effort(n, k, a):
    if k >= n:  # If we can skip all firewalls, the total effort is 0.
        return 0
    # Initial total effort without skipping
    total_effort = sum(a)
    # Sort the firewall strengths in descending order
    a.sort(reverse=True)
    # Reduce the effort by skipping the k strongest firewalls
    effort_saved = sum(a[:k])
    # Compute the penalty correctly: skipping `k` firewalls increases others
    penalty = k * (k + 1) // 2  # Sum of first k natural numbers
    # Final minimized effort
    min_effort = total_effort - effort_saved + penalty
    return min_effort
# Driver code to handle multiple test cases
T = int(input().strip())
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    result = minimize_effort(n, k, a)
    print(result)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054284
1390054279,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    return min(dp[n])
T = int(input()) 
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))  
    print(min_effort(n, k, firewalls))",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054279
1390054281,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054281
1390054280,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # Get indices of active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # Define the check function
        def check(X):
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                while j < m and A[j] - A[i] <= X:
                    j += 1
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == ""__main__"":
    solve()",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054280
1390054278,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054278
1390054275,unknown,unknown,unknown,"import sys
from itertools import accumulate
def min_effort(arr, k):
    n = len(arr)
    T = sum(arr)
    A = [arr[i] + (i+1) for i in range(n)]
    A.sort(reverse=True)
    P = [0] + list(accumulate(A))
    m_max = min(k, n)
    best = float('inf')
    for m in range(m_max + 1):
        cost = T + m * n - (m * m - m) // 2 - P[m]
        if cost < best:
            best = cost
    return best
def solve():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    res = []
    for _ in range(t):
        n = int(data[index]); index += 1
        k = int(data[index]); index += 1
        arr = list(map(int, data[index:index+n])); index += n
        res.append(str(min_effort(arr, k)))
    sys.stdout.write(""\n"".join(res))
if __name__ == ""__main__"":
    solve()",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054275
1390054277,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054277
1390054276,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054276
1390054273,unknown,unknown,unknown,"import bisect
t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    if n == 0:
        print(0)
        continue
    if n == 1:
        print(0)
        continue
    if n == 2:
        print(1 if s[0] == s[1] else 0)
        continue
    prefix_0 = [0] * (n + 1)
    prefix_1 = [0] * (n + 1)
    for i in range(n):
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]
    low, high = 0, n
    while low < high:
        m = (low + high) // 2
        possible = False
        for j in range(n + 1):
            target = prefix_0[j] - m
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
            if i <= j:
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
                remaining_zeros = prefix_0[j] - prefix_0[i]
                if max(remaining_zeros, ones_removed) <= m:
                    possible = True
                    break
        if possible:
            high = m
        else:
            low = m + 1
    print(low)",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054273
1390054271,unknown,unknown,unknown,"def min_decommissioning_cost(s):
    n = len(s)
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')
    total_ones = prefix_ones[n]
    min_cost = n
    for length in range(n + 1):
        if length == 0:
            min_cost = min(min_cost, total_ones)
            continue
        best_pos_cost = n
        for start in range(n - length + 1):
            end = start + length
            ones_remaining = prefix_ones[end] - prefix_ones[start]
            ones_removed = total_ones - ones_remaining
            zeros_remaining = length - ones_remaining
            cost = max(zeros_remaining, ones_removed)
            best_pos_cost = min(best_pos_cost, cost)
        min_cost = min(min_cost, best_pos_cost)
    return min_cost
import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_decommissioning_cost(server_rack))",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054271
1390054274,unknown,unknown,unknown,"from collections import deque
def FSR(arr,k):
    dq,result=deque(),[]
    for i in range(len(arr)):
        if dq and dq[0]<i-k+1:
            dq.popleft()
        if arr[i]<0:
            dq.append(i)
        if i>=k-1:
            result.append(arr[dq[0]]if dq else 0)
    return result
t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))
    print(*FSR(arr,k))
        ",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054274
1390054265,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        fault_found = False
        for reading in batch:
            if reading < 0:
                result.append(reading)
                fault_found = True
                break
        if not fault_found:
            result.append(0)
    return result
if __name__ ==""__main__"" :
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        output = find_earliest_faults(arr, k)
        print(*output)",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054265
1390054269,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        # Compute a[i] + i (0-based)
        values = [a[i] + i for i in range(n)]
        # Sort in descending order
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        # Compute the result
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
if __name__ == ""__main__"":
    main()",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054269
1390054270,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommissioningCorrected {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        while (t-- > 0) {
            String servers = scanner.nextLine();
            int minCost = solveCorrected(servers);
            System.out.println(minCost);
        }
        scanner.close();
    }
    private static int solveCorrected(String servers) {
        int n = servers.length();
        int minCost = Integer.MAX_VALUE;
        for (int i = 0; i <= n; i++) { // Decommission from the beginning
            for (int j = 0; j <= n - i; j++) { // Decommission from the end
                String remaining = servers.substring(i, n - j);
                int idleCount = 0;
                int activeDecommissioned = 0;
                // Count idle servers in the remaining string
                for (int k = 0; k < remaining.length(); k++) {
                    if (remaining.charAt(k) == '0') {
                        idleCount++;
                    }
                }
                // Count active servers decommissioned from the beginning
                for (int k = 0; k < i; k++) {
                    if (servers.charAt(k) == '1') {
                        activeDecommissioned++;
                    }
                }
                // Count active servers decommissioned from the end
                for (int k = 0; k < j; k++) {
                    if (servers.charAt(n - 1 - k) == '1') {
                        activeDecommissioned++;
                    }
                }
                minCost = Math.min(minCost, Math.max(idleCount, activeDecommissioned));
            }
        }
        return minCost;
    }
}",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054270
1390054264,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        output = []
        dq = deque()
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        output.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            if dq and dq[0] <= i - k:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            output.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, output)))
    return ""\n"".join(results)
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
print(earliest_faulty_readings(test_cases))",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054264
1390054251,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054251
1390054258,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054258
1390054259,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;
int solve(vector<int>&arr, int i, int skip, int inc,vector<vector<int>>&dp) {
    int n = arr.size();
    if(i==n){
        return 0;
    }
    if(dp[i][skip]!=-1)return dp[i][skip];
    //skip
    int ans = INT_MAX;
    if(skip) {
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
    }
    //no skip
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc,dp));
    return dp[i][skip]= ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--) {
        int n,skip;
        cin>>n>>skip;
        vector<int>arr;
        vector<vector<int>>dp(n,vector<int>(n+1,-1));
        while(n--) {
            int a;
            cin>>a;
            arr.push_back(a);
        }
        cout<<solve(arr,0,skip,0,dp)<<endl;
    }
    return 0;
}",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054259
1390054243,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
long long calculateMinEffort(vector<int>& a, int k) {
    int n = a.size();
    // Use a max-heap to find the k largest elements
    priority_queue<int> maxHeap;
    for (int i = 0; i < n; ++i) {
        maxHeap.push(a[i]);
    }
    // Extract the k largest elements
    vector<int> skipped;
    for (int i = 0; i < k; ++i) {
        skipped.push_back(maxHeap.top());
        maxHeap.pop();
    }
    // Calculate the total effort
    long long totalEffort = 0;
    int increase = 0; // Tracks the number of skipped firewalls so far
    for (int i = 0; i < n; ++i) {
        if (find(skipped.begin(), skipped.end(), a[i]) != skipped.end() && increase < k) {
            // Skip this firewall
            increase++;
        } else {
            // Add the effort, considering the increase due to skipped firewalls
            totalEffort += a[i] + increase;
        }
    }
    return totalEffort;
}
int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }
        // If k >= n, we can skip all firewalls
        if (k >= n) {
            cout << 0 << endl;
            continue;
        }
        // Otherwise, calculate the minimum effort
        long long minEffort = calculateMinEffort(a, k);
        cout << minEffort << endl;
    }
    return 0;
}",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054243
1390054246,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n - j]
            idle_count = remaining.count('0')
            active_removed = s[:i].count('1') + s[n - j:].count('1')
            min_cost = min(min_cost, max(idle_count, active_removed))
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054246
1390054249,unknown,unknown,unknown,"test_case = int(input())
for _ in range(test_case):
    a,b = list(map(int,input().split("" "")))
    arr = list(map(int,input().split("" "")))
    arr.sort()
    temp_sum = 0
    for i in range(a-b):
        temp_sum+=arr[i]
    if a-b>0:
        print(temp_sum+b)
    else:
        print(temp_sum)",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054249
1390054233,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]  
        firewalls = test_cases[t][1] 
        sorted_indices = sorted(range(n), key=lambda i: -firewalls[i])
        skipped = set(sorted_indices[:k])
        total_effort = 0
        increment = 0 
        for i in range(n):
            if i in skipped:
                increment += 1
            else:
                total_effort += firewalls[i] + increment
        results.append(total_effort)
    return results
T = int(input().strip())  
test_cases = []
for _ in range(T):
    n, k = map(int, input().strip().split())  
    firewalls = list(map(int, input().strip().split()))  
    test_cases.append(((n, k), firewalls))
output = min_effort_to_breach(T, test_cases)
for res in output:
    print(res)",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054233
1390054234,unknown,unknown,unknown,"def min_eff(t,test_cases):
    res = []
    for case in test_cases:
        n , k , firewalls = case
        firewalls.sort() #sort skit weakest
        #compute effort
        tot_effort = sum(firewall[k:1]) if k<n else 0
        res.append(tot_effort)
    return res
#input handling
t = int(input()) #no of testcases
test_cases = []
for",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054234
1390054239,unknown,unknown,unknown,"import itertools
def findMinEffort():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for skip_count in range(min(k, n) + 1):
        for skip_indices in itertools.combinations(range(n), skip_count):
            current_arr = a[:]
            for skip_index in sorted(skip_indices):
                for j in range(skip_index + 1, n):
                    current_arr[j] += 1    
            effort = 0
            for i in range(n):
                if i not in skip_indices:
                    effort += current_arr[i]
            min_effort = min(min_effort, effort)         
    print(min_effort)
t = int(input())
for _ in range(t):
    findMinEffort()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054239
1390054232,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    n = len(server_rack)
    total_ones = server_rack.count('1')
    min_cost = float('inf')
    left = 0
    zeros_in_window = 0
    for right in range(n):
        if server_rack[right] == '0':
            zeros_in_window += 1
        ones_in_window = (right - left + 1) - zeros_in_window
        ones_removed = total_ones - ones_in_window
        cost = max(zeros_in_window, ones_removed)
        if cost < min_cost:
            min_cost = cost
        while zeros_in_window > ones_removed and left <= right:
            if server_rack[left] == '0':
                zeros_in_window -= 1
            left += 1
            ones_in_window = (right - left + 1) - zeros_in_window
            ones_removed = total_ones - ones_in_window
            cost = max(zeros_in_window, ones_removed)
            if cost < min_cost:
                min_cost = cost
    return min_cost
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(min_decommission_cost(server_rack))",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054232
1390054224,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054224
1390054225,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            String s = sc.next();
            int n = s.length();
            int[] prefixOnes = new int[n + 1];
            int[] suffixZeros = new int[n + 1];
            // Precompute prefix sum of ones
            for (int i = 0; i < n; i++) {
                prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
            }
            // Precompute suffix sum of zeros
            for (int i = n - 1; i >= 0; i--) {
                suffixZeros[n - i] = suffixZeros[n - i - 1] + (s.charAt(i) == '0' ? 1 : 0);
            }
            int minCost = Integer.MAX_VALUE;
            // Try removing i characters from start, j characters from end
            for (int i = 0; i <= n; i++) { // prefix removals
                for (int j = 0; j <= n - i; j++) { // suffix removals
                    int onesRemoved = prefixOnes[i] + (prefixOnes[n] - prefixOnes[n - j]);
                    int zerosRemaining = 0;
                    // Count zeros between
                    for (int k = i; k < n - j; k++) {
                        if (s.charAt(k) == '0') zerosRemaining++;
                    }
                    minCost = Math.min(minCost, Math.max(zerosRemaining, onesRemoved));
                }
            }
            System.out.println(minCost);
        }
    }
}",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054225
1390054229,unknown,unknown,unknown,"def min_effort_to_breach(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        firewalls.sort()
        effort = sum(firewalls[:n - k])  # Regular effort
        for i in range(n - k, n):  # Apply security increase for skipped firewalls
            effort += firewalls[i] + (i - (n - k))
        results.append(str(effort))
    print(""\n"".join(results))
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
min_effort_to_breach(test_cases)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054229
1390054220,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054220
1390054223,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_0 = servers.count('0')
        total_1 = n - total_0
        # Precompute prefix counts for 0s and 1s
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(1, n + 1):
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0')
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1')
        # Precompute suffix counts for 0s and 1s
        suffix_0 = [0] * (n + 1)
        suffix_1 = [0] * (n + 1)
        for j in range(1, n + 1):
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0')
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1')
        min_cost = float('inf')
        # Iterate over all possible prefixes (i)
        for i in range(n + 1):
            # The maximum j such that i + j <= n is j_max = n - i
            j_max = n - i
            # Binary search for the best j in [0, j_max]
            left = 0
            right = j_max
            best_j = 0
            best_cost = float('inf')
            while left <= right:
                mid = (left + right) // 2
                # Calculate remaining_0 and decommissioned_1 for j = mid
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
                current_cost = max(remaining_0, decommissioned_1)
                # Update best_j and best_cost if current_cost is better
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_j = mid
                elif current_cost == best_cost and mid < best_j:
                    best_j = mid
                # Decide direction to search
                if decommissioned_1 < remaining_0:
                    # Need to remove more 1s (increase j)
                    left = mid + 1
                else:
                    # Need to remove fewer 1s (decrease j)
                    right = mid - 1
            # Check the best j found and neighboring values
            for j in [best_j - 1, best_j, best_j + 1]:
                if 0 <= j <= j_max:
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
                    current_cost = max(remaining_0, decommissioned_1)
                    if current_cost < best_cost:
                        best_cost = current_cost
            min_cost = min(min_cost, best_cost)
        results.append(min_cost)
    return results
# Input reading
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Get results
results = min_decommissioning_cost(test_cases)
# Output results
for result in results:
    print(result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054223
1390054222,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            decommissioned_ones = 0
            remaining_zeros = 0
            # Decommission from the beginning
            decommissioned_ones += s[:i].count('1')
            # Decommission from the end
            decommissioned_ones += s[n - j:].count('1')
            # Remaining string after decommissioning
            remaining_string = s[i:n - j]
            remaining_zeros = remaining_string.count('0')
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054222
1390054214,unknown,unknown,unknown,"import sys
from itertools import accumulate
def min_effort(arr, k):
    n = len(arr)
    T = sum(arr)
    A = [arr[i] + (i+1) for i in range(n)]
    A.sort(reverse=True)
    P = [0] + list(accumulate(A))
    m_max = min(k, n)
    best = float('inf')
    for m in range(m_max + 1):
        cost = T + m * n - (m * m - m) // 2 - P[m]
        if cost < best:
            best = cost
    return best
def solve():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    res = []
    for _ in range(t):
        n = int(data[index]); index += 1
        k = int(data[index]); index += 1
        arr = list(map(int, data[index:index+n])); index += n
        res.append(str(min_effort(arr, k)))
    sys.stdout.write(""\n"".join(res))
if __name__ == ""__main__"":
    solve()",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054214
1390054217,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054217
1390054218,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054218
1390054211,unknown,unknown,unknown,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <cmath>
#define int long long int
#define pb push_back
/*---------------------------------------------------------------------------------------------------------------------------------*/
/*ASCII small case-> a-97 to z-122
upper case-> A-65 to Z-90*/
#define nl ""\n""
#define mp map<int, int>
#define all(v) v.begin(), v.end()
#define F first
#define S second
#define ump unordered_map<long long, int, custom_hash>
#define mstpi multiset<pair<int, int> >
#define mst multiset<int>
#define vec vector<int>
#define pi pair<int, int>
#define ld long double
#define vep vector<pair<int, int>>
#define ul unsigned long long
#define loop1 for (int i = 0; i < n; i++)
#define REP(i, a, b) for (int i = a; i <= b; i++)
#define NO cout << ""NO"" << endl
#define YES cout << ""YES"" << endl
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
/*---------------------------------------------------------------------------------------------------------------------------------*/
const double PI = 3.1415926535;
const int inf = 1e18;
const int mod = 1000000007;
/*---------------------------------------------------------------------------------------------------------------------------------*/
int modmul(int a, int b, int m)
{
    a %= m;
    b %= m;
    return (a * b) % m;
}
int modexp(int n, int x)
{
    int ans = 1;
    while (n > 0)
    {
        if (n & 1)
        {
            ans = (ans * x) % mod;
        }
        n >>= 1;
        x = (x * x) % mod;
    }
    return ans;
}
/*---------------------------------------------------------------------------------------------------------------------------------*/
string add(string a, string b)
{
    string ans = """";
    int carry = 0;
    while (!a.empty() || !b.empty() || carry > 0)
    {
        int digitA = a.empty() ? 0 : a.back() - '0';
        int digitB = b.empty() ? 0 : b.back() - '0';
        int sum = digitA + digitB + carry;
        ans = to_string(sum % 10) + ans;
        carry = sum / 10;
        if (!a.empty())
            a.pop_back();
        if (!b.empty())
            b.pop_back();
    }
    return ans;
}
string ministrnum(string a, string b)
{
    if (a.length() > b.length())
        return b;
    else if (b.length() > a.length())
        return a;
    else
    {
        int n = a.length();
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i])
                return b;
            else if (a[i] < b[i])
                return a;
        }
    }
    return a;
}
vector<int> sieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    if(n >= 0) isPrime[0] = false;
    if(n >= 1) isPrime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}
class SegmentTree {
public:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(arr, 0, n - 1, 0);
    }
    void build(const std::vector<int>& arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, start, mid, 2 * index + 1);
        build(arr, mid + 1, end, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
    int queryRange(int start, int end, int l, int r, int index = 0) {
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if (start > r || end < l)
            return 0;
        if (start >= l && end <= r)
            return tree[index];
        int mid = (start + end) / 2;
        return queryRange(start, mid, l, r, 2 * index + 1) +
               queryRange(mid + 1, end, l, r, 2 * index + 2);
    }
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
        if(lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];
            if(start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }
            lazy[index] = 0;
        }
        if(start > r || end < l)
            return;
        if(start >= l && end <= r) {
            tree[index] += (end - start + 1) * diff;
            if(start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }
            return;
        }
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, diff, 2 * index + 1);
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
};
class DSU {
public:
    std::vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY)
            return false;
        if (rank[rootX] < rank[rootY])
            parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY])
            parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int val;
    int weight, size;
    Node *left, *right;
    bool rev = false;
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
};
ostream &operator<<(ostream &os, Node *n) {
    if(!n) return os;
    os << n -> left;
    os << n -> val;
    os << n -> right;
    return os;
}
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
void push(Node* Treap) {
    if(!Treap) return;
    if(Treap -> rev) {
        Treap -> rev = false;
        swap(Treap->left, Treap->right);
        if(Treap -> left) Treap->left->rev ^= true;
        if(Treap -> right) Treap->right->rev ^= true;
    }
}
void pull(Node *Treap) {
    if(!Treap) return;
    push(Treap -> left), push(Treap -> right);
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
    return;
}
void split(Node *Treap, Node *&left, Node *&right, int val) {
    if(!Treap) {
        left = right = NULL;
        return;
    }
    push(Treap);
    if(size(Treap -> left) < val) {
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
        left = Treap;
    }
    else {
        split(Treap -> left, left, Treap -> left, val);
        right = Treap;
    }
    pull(Treap);
}
void merge(Node *&Treap, Node *left, Node *right) {
    push(left), push(right);
    if(left == NULL) {
        Treap = right;
        return;
    }
    if(right == NULL) {
        Treap = left;
        return;
    }
    if(left -> weight < right -> weight) {
        merge(right -> left, left, right -> left);
        Treap = right;
    }
    else {
        merge(left->right, left->right, right);
        Treap = left;
    }
    pull(Treap);
}
void inOrder(Node *curr, vector<int> &res) {
    if(curr == NULL) return;
    push(curr);
    inOrder(curr->left, res);
    res.pb(curr->val);
    inOrder(curr->right, res);
    pull(curr);
}
struct Treap {
    Node *root = nullptr;
    void insert(int i, int val) {
        Node *l, *r;
        split(root, l, r, i);
        Node *v = new Node(val);
        merge(l, l, v);
        merge(root, l, r);
    }
    void del(int i) {
        Node *l, *r;
        split(root, l, r, i);
        split(r, root, r, 1);
        merge(root, l, r);
    }
    void update(int l, int r, function<void(Node *)> f) {
        Node *a, *b, *c;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        if(b) {f(b);}
        merge(root, a, b);
        merge(root, root, c);
    }
    vector<int> allPr() {
        vector<int> res;
        inOrder(root, res);
        return res;
    }
    void cycShft(int l, int r) {
        Node *a, *b, *c, *d;
        split(root, a, b, l-1);
        split(b, b, c, r-l+1);
        split(b, b, d, r-l);
        merge(root, a, d);
        merge(root, root, b);
        merge(root, root, c);
    }
};
vector<int> computePrefix(const string &pattern) {
    int n = pattern.size();
    vector<int> prefix(n, 0);
    for (int i = 1, j = 0; i < n; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = prefix[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        prefix[i] = j;
    }
    return prefix;
}
vector<int> KMPSearch(const string &text, const string &pattern) {
    vector<int> prefix = computePrefix(pattern);
    vector<int> occurrences;
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
        while (j > 0 && text[i] != pattern[j])
            j = prefix[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == (int)pattern.size()) {
            occurrences.push_back(i - j + 1);
            j = prefix[j - 1];
        }
    }
    return occurrences;
}
void solve()
{
    int n, ans = 1e9;
    string s;
    cin>>s;
    n = s.size();
    vector<int> pref(n, 0);
    for(int i = 0; i<n; i++) {
        pref[i] = s[i] == '1';
        if(i) pref[i] += pref[i - 1];
    }
    for(int i = 0; i<n; i++) {
        for(int j = i; j<n; j++) {
            int cnt1 = (i?pref[i-1]:0) + pref[n-1] - (j!=n-1?pref[j+1]:pref[n-1]), cnt0 = (j - i + 1) - (pref[j] - (i?pref[i-1]:0));
            ans = min(ans, max(cnt1, cnt0)); 
        }
    }
    cout<<ans<<'\n';
}
int32_t main()
{
    ios_base ::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--)
        solve();
}",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054211
1390054207,unknown,unknown,unknown,"def min_decommission_cost(s):
    n = len(s)
    first_one = s.find('1')
    last_one = s.rfind('1')
    if first_one == -1:
        return 0  
    trimmed = s[first_one:last_one+1]
    remaining_zeros = trimmed.count('0')
    min_cost = remaining_zeros
    ones_removed = 0
    for i in range(first_one, last_one + 1):
        if s[i] == '1':
            ones_removed += 1
        else:
            remaining_zeros -= 1
        min_cost = min(min_cost, max(remaining_zeros, ones_removed))
    return min_cost
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_decommission_cost(s))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054207
1390054209,unknown,unknown,unknown,"def min_effort_to_breach(t, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        firewalls.sort()
        # Skip the k weakest firewalls (if possible)
        remaining_effort = sum(firewalls[:max(0, n - k)])
        results.append(str(remaining_effort))
    return ""\n"".join(results)
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(t, test_cases))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054209
1390054210,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054210
1390054202,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            System.out.println(minEffort(n, k, arr));
        }
        sc.close();
    }
    static int minEffort(int n, int k, int[] arr) {
        int[] curr = new int[k + 1];
        int[] next = new int[k + 1];
        Arrays.fill(curr, Integer.MAX_VALUE);
        Arrays.fill(next, Integer.MAX_VALUE);
        Arrays.fill(next, 0);
        for (int i = n - 1; i >= 0; i--) {
            for (int skip = 0; skip <= k; skip++) {
                int take = arr[i] + skip;
                if (i + 1 < n) {
                    if (next[skip] != Integer.MAX_VALUE) {
                        take += next[skip];
                    }
                }
                int leave = Integer.MAX_VALUE;
                if (skip < k && i + 1 <= n) {
                    leave = next[skip + 1];
                }
                curr[skip] = Math.min(take, leave);
            }
            int[] temp = next;
            next = curr;
            curr = temp;
            Arrays.fill(curr, Integer.MAX_VALUE);
        }
        return next[0];
    }
}",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054202
1390054203,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        # Sort by benefit descending
        benefits.sort(reverse=True)
        skipped = [False] * n
        # Mark the top k firewalls to skip
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        # Calculate total effort
        total_effort = 0
        penalty = 0  # number of skipped firewalls so far
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
# Run main() inside a separate thread to avoid recursion limit issues in large input
threading.Thread(target=main).start()",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054203
1390054204,unknown,unknown,unknown,"def min_cost(server_str):
    n = len(server_str)
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
    for i in range(n):
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
    total_1 = prefix_1[n]
    total_0 = prefix_0[n]
    min_cost = float('inf')
    # Try removing l elements from the front
    for l in range(n + 1):
        # Try removing r elements from the back
        for r in range(n - l + 1):
            left = l
            right = n - r
            remaining_0 = prefix_0[right] - prefix_0[left]
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
            cost = max(remaining_0, removed_1)
            min_cost = min(min_cost, cost)
    return min_cost
# Main driver
T = int(input())
for _ in range(T):
    server_str = input().strip()
    print(min_cost(server_str))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054204
1390054194,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <climits>
#include <algorithm>
using namespace std;
int minDecommissioningCost(const string& serverRack) {
    int n = serverRack.size();
    int minCost = INT_MAX;
    // Try all possible prefix and suffix removals
    for (int i = 0; i <= n; ++i) {  // i = prefix length to remove
        for (int j = 0; j <= n - i; ++j) {  // j = suffix length to remove
            if (i + j > n) continue;
            string remaining = serverRack.substr(i, n - i - j);
            if (remaining.empty()) continue;
            int idleRemaining = count(remaining.begin(), remaining.end(), '0');
            int activeRemoved = count(serverRack.begin(), serverRack.begin() + i, '1') +
                                count(serverRack.end() - j, serverRack.end(), '1');
            int cost = max(idleRemaining, activeRemoved);
            minCost = min(minCost, cost);
        }
    }
    return minCost;
}
void solve() {
    int t;
    cin >> t;
    while (t--) {
        string serverRack;
        cin >> serverRack;
        cout << minDecommissioningCost(serverRack) << endl;
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054194
1390054196,unknown,unknown,unknown,"def minimize_breach_effort(num_firewalls, max_skips, security_strengths):
    effort_table = [[float('inf')] * (max_skips + 1) for _ in range(num_firewalls + 1)]
    effort_table[0][0] = 0  
    for firewall in range(1, num_firewalls + 1):
        for skips_used in range(max_skips + 1):
            effort_table[firewall][skips_used] = (
                effort_table[firewall - 1][skips_used] + security_strengths[firewall - 1] + skips_used
            )
            if skips_used > 0:
                effort_table[firewall][skips_used] = min(
                    effort_table[firewall][skips_used], effort_table[firewall - 1][skips_used - 1]
                )
    return min(effort_table[num_firewalls])
test_cases = int(input())
for _ in range(test_cases):
    num_firewalls, max_skips = map(int, input().split())
    security_strengths = list(map(int, input().split()))
    print(minimize_breach_effort(num_firewalls, max_skips, security_strengths))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054196
1390054200,unknown,unknown,unknown,"import sys
def minimum_effort(test_cases):
    results = []
    for n, k, a in test_cases:
        if k >= n:
            results.append(0)
            continue
        # Sorting indices of firewalls based on strength in descending order
        sorted_indices = sorted(range(n), key=lambda i: a[i], reverse=True)
        # Try skipping different firewalls and calculate minimum effort
        min_effort = float('inf')
        for skip_index in sorted_indices[:k]:  # Only consider skipping the top 'k' strongest firewalls
            effort = 0
            security_cost = 0
            for i in range(n):
                if i == skip_index:
                    security_cost += 1  # Every skipped firewall increases security cost
                else:
                    effort += a[i] + security_cost  # Firewall strength + accumulated security cost
            min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
def main():
    input_data = sys.stdin.read().split()
    it = iter(input_data)
    T = int(next(it))
    test_cases = []
    for _ in range(T):
        n = int(next(it))
        k = int(next(it))
        a = [int(next(it)) for _ in range(n)]
        test_cases.append((n, k, a))
    results = minimum_effort(test_cases)
    print(""\n"".join(map(str, results)))
if __name__ == ""__main__"":
    main()",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054200
1390054192,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    # Special case: If we can skip all firewalls, the effort is 0
    if k >= n:
        return 0
    # Try all possible subsets of firewalls to skip
    min_effort = float('inf')
    # Generate all possible subsets of k or fewer indices to skip
    # Instead of trying all combinations, we can use a greedy approach
    # We'll calculate the impact of skipping each firewall and choose the best ones
    # Calculate the impact of skipping each firewall
    impact = []
    for i, val in enumerate(firewalls):
        # Impact = (value of firewall) - (penalty to remaining firewalls)
        # Penalty to remaining firewalls = (n - i - 1)
        impact_val = val - (n - i - 1)
        impact.append((impact_val, i))
    # Sort by impact (descending)
    impact.sort(reverse=True)
    # Try skipping 0 to k firewalls
    for skip_count in range(k + 1):
        # Get the indices of firewalls to skip
        skip_indices = set(impact[j][1] for j in range(skip_count))
        # Calculate the effort for this configuration
        effort = 0
        penalty = 0
        for i in range(n):
            if i in skip_indices:
                penalty += 1  # Increase penalty for subsequent firewalls
            else:
                effort += firewalls[i] + penalty  # Add effort with penalty
        min_effort = min(min_effort, effort)
    return min_effort
# Read input
t = int(input().strip())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054192
1390054185,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            if (arr[i] < 0) {
                deque.offer(i);
            }
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054185
1390054186,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054186
1390054190,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, n, k):
    result = []
    q = deque()  
    for i in range(k):
        if arr[i] < 0:
            q.append(i)
    if q:
        result.append(arr[q[0]])
    else:
        result.append(0)
    for i in range(k, n):
        while q and q[0] <= i - k:
            q.popleft()
        if arr[i] < 0:
            q.append(i)
        if q:
            result.append(arr[q[0]])
        else:
            result.append(0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    ans = earliest_faulty_readings(arr, n, k)
    print(*ans)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054190
1390054181,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    queue = deque()
    # Process first k elements
    for i in range(k):
        if arr[i] < 0:
            queue.append(i)
    # Add the first faulty element or 0 if none found
    result.append(arr[queue[0]] if queue else 0)
    # Process the rest of the array
    for i in range(k, len(arr)):
        # Remove elements that are out of the window
        if queue and queue[0] < i - k + 1:
            queue.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            queue.append(i)
        # Add the first faulty element or 0
        result.append(arr[queue[0]] if queue else 0)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054181
1390054183,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int arr[] = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            ArrayList<Integer> list = new ArrayList<>();
            Queue<Integer> queue = new LinkedList<>(); 
            int i = 0, j = 0;
            while (j < n) {
                if (arr[j] < 0) {
                    queue.add(arr[j]);
                }
                if (j - i + 1 == k) {
                    if (!queue.isEmpty()) {
                        list.add(queue.peek());
                    } else {
                        list.add(0); 
                    }
                    if (!queue.isEmpty() && queue.peek() == arr[i]) {
                        queue.poll();
                    }
                    i++; 
                }
                j++; 
            }
            for (int l = 0; l < list.size(); l++) {
                System.out.print(list.get(l) + "" "");
            }
            System.out.println(); 
        }
        sc.close();
    }
}",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054183
1390054182,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054182
1390054176,unknown,unknown,unknown,"for _ in range(int(input())):
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    output = []
    for j in range(n - k + 1):
        window = nums[j:j + k]
        first_negative = next((num for num in window if num < 0), 0)
        output.append(first_negative)
    print(*output)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054176
1390054180,unknown,unknown,unknown,"def min_decommission_cost(rack):
    n = len(rack)
    # Precompute cumulative sums for O(1) range queries
    active_prefix = [0] * (n + 1)  # Active servers (1's) from left
    idle_prefix = [0] * (n + 1)    # Idle servers (0's) from left
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
    total_active = active_prefix[n]
    total_idle = idle_prefix[n]
    min_cost = float('inf')
    # We need to find i and j where:
    # i = number of servers to remove from beginning
    # j = number of servers to remove from end
    for i in range(n + 1):
        for j in range(n + 1 - i):  # Ensure we don't remove more than n servers
            # Active servers removed from beginning and end
            removed_active = active_prefix[i] + (active_prefix[n] - active_prefix[n - j])
            # Idle servers remaining in the middle
            remaining_idle = idle_prefix[n - j] - idle_prefix[i]
            cost = max(remaining_idle, removed_active)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        rack = input().strip()
        result = min_decommission_cost(rack)
        print(result)
if __name__ == ""__main__"":
    main()",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054180
1390054174,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054174
1390054173,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear)  arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054173
1390054170,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    a = [0] * (n + 1)
    for i in range(n):
        a[i + 1] = a[i] + (s[i] == ""1"")
    c = float(""inf"")
    for i in range(n + 1):
        b = a[i]
        for j in range(n + 1 - i):
            d = a[n] - a[n - j]
            e = max((n - i - j) - (a[n] - b - d), b + d)
            c = min(c, e)
    print(c)",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054170
1390054168,unknown,unknown,unknown,"def breach_effort(num_walls, max_skips, wall_strengths):
    dp = [[float('inf')] * (max_skips + 1) for _ in range(num_walls + 1)]
    for skips in range(max_skips + 1):
        dp[0][skips] = 0
    for wall in range(1, num_walls + 1):
        for skips in range(max_skips + 1):
            if skips > 0:
                dp[wall][skips] = dp[wall-1][skips-1]
            strength = wall_strengths[wall-1] + skips
            dp[wall][skips] = min(dp[wall][skips], dp[wall-1][skips] + strength)
    return min(dp[num_walls])
def process_cases():
    test_cases = int(input())
    results = []
    for _ in range(test_cases):
        num_walls, max_skips = map(int, input().split())
        wall_strengths = list(map(int, input().split()))
        results.append(breach_effort(num_walls, max_skips, wall_strengths))
    print(""\n"".join(map(str, results)))
process_cases()",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054168
1390054171,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054171
1390054165,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while(T--) {
        int n, k;
        cin >> n >> k;
        vector<long long> a(n);
        long long total = 0;
        for (int i = 0; i < n; i++) {
            cin >> a[i];
            total += a[i];
        }
        // Build vector v[i] = a[i] + i + 1
        vector<long long> v(n);
        for (int i = 0; i < n; i++) {
            v[i] = a[i] + i + 1;
        }
        // Sort v in descending order
        sort(v.begin(), v.end(), greater<long long>());
        // Precompute prefix sums of v (for the best s indices to skip)
        vector<long long> prefix(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix[i+1] = prefix[i] + v[i];
        }
        long long ans = total; // s=0: no skip
        // Try s=1 to k (s = number of skipped firewalls)
        for (int s = 1; s <= k; s++) {
            // Cost = total + s*n - (s*(s-1))/2 - (sum of top s values)
            long long cost = total + (long long)s * n - ((long long)s * (s - 1)) / 2 - prefix[s];
            ans = min(ans, cost);
        }
        cout << ans << endl;
    }
    return 0;
}",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054165
1390054166,unknown,unknown,unknown,"def min_server_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        # Find the first and last occurrence of '1'
        first_one = s.find('1')
        last_one = s.rfind('1')
        # If there are no active servers, cost is 0
        if first_one == -1:
            results.append(0)
            continue
        # Trim the string from first '1' to last '1'
        trimmed = s[first_one:last_one + 1]
        # Count remaining '0's in the trimmed string
        idle_servers_remaining = trimmed.count('0')
        # Count removed '1's (total '1's - '1's in the trimmed portion)
        active_servers_removed = s.count('1') - trimmed.count('1')
        # The final cost is the maximum of both values
        results.append(max(idle_servers_remaining, active_servers_removed))
    # Print all results for each test case
    print(""\n"".join(map(str, results)))
# Read input
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
# Run function
min_server_decommissioning_cost(test_cases)",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054166
1390054167,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    total_effort = sum(strengths)
    if k == n:
        return 0
    min_effort = total_effort
    for i in range(n):
        skipped = 0
        new_effort = 0
        for j in range(n):
            if j == i and skipped < k:
                skipped += 1
                continue
            new_effort += strengths[j] + skipped
        min_effort = min(min_effort, new_effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort(n, k, strengths))",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054167
1390054163,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    min_effort = float('inf')
    for skip_mask in range(1 << n):
        if bin(skip_mask).count('1') != k:
            continue
        effort = 0
        increased_strengths = strengths[:]
        for i in range(n):
            if skip_mask & (1 << i):
                for j in range(i + 1, n):
                    increased_strengths[j] += 1
            else:
                effort += increased_strengths[i]
        min_effort = min(min_effort, effort)
    return min_effort
t = int(input().strip())
for _ in range(t):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort(n, k, strengths))",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054163
1390054156,unknown,unknown,unknown,"# Read number of test cases
t = int(input().strip())
for _ in range(t):
    # Read server string
    servers = input().strip()
    n = len(servers)
    # Precompute prefix sums
    prefix_active = [0] * (n + 1)
    prefix_idle = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = float('inf')
    # Key insight: For each left position, there exists at most one optimal right position
    for left in range(n + 1):
        active_removed_left = prefix_active[left]
        # For each left boundary, the right boundary should be as far right as possible
        # while keeping the idle_remaining below or equal to active_removed_total
        right = n
        while right >= left:
            active_removed_right = total_active - prefix_active[right]
            active_removed_total = active_removed_left + active_removed_right
            idle_remaining = prefix_idle[right] - prefix_idle[left]
            # Check if this is a better solution
            cost = max(idle_remaining, active_removed_total)
            min_cost = min(min_cost, cost)
            # If removing more from right would reduce cost, try next position
            if idle_remaining > active_removed_total:
                right -= 1
            else:
                # We've found the optimal right boundary for this left boundary
                break
    print(min_cost)",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054156
1390054147,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of this window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054147
1390054152,unknown,unknown,unknown,"def find_earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i+k]
        fault = 0
        for num in batch:
            if num < 0:
                fault = num
                break
        result.append(fault)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    output = find_earliest_fault(arr, k)
    print(' '.join(map(str, output)))",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054152
1390054155,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    """"""
    Calculates the minimum effort needed to breach a network of firewalls.
    Args:
        n: The number of firewalls.
        k: The number of firewalls that can be skipped.
        firewalls: A list of integers representing the strength of each firewall.
    Returns:
        The minimum effort needed to breach the network.
    """"""
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Don't skip the current firewall
            if j == 0:
                dp[i][j] = dp[i - 1][j] + firewalls[i - 1]
            else:
                # Calculate increased strength due to previous skips
                increased_strength = 0
                for skip in range(1, j + 1):
                    if i - skip - 1 >= 0:
                        increased_strength += 1
                dp[i][j] = min(dp[i - 1][j] + firewalls[i - 1] + increased_strength, dp[i - 1][j - 1])
    return dp[n][k]
# Example Usage (from Sample Input)
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054155
1390054142,unknown,unknown,unknown,"import sys
def process_data(input_data):
    lines = input_data.strip().split(""\n"")
    t = int(lines[0])
    index = 1
    output = []
    for _ in range(t):
        n, k = map(int, lines[index].split())
        arr = list(map(int, lines[index + 1].split()))
        index += 2  # Move to next test case
        res = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            faulty = next((val for val in batch if val < 0), 0)
            res.append(faulty)
        output.append("" "".join(map(str, res)))
    print(""\n"".join(output))
if __name__ == ""__main__"":
    input_data = sys.stdin.read()
    process_data(input_data)",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054142
1390054143,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = effort + dp[i + 1][j]  # Proceed without skipping
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = min(dp[i][j], dp[i + 1][j + 1])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054143
1390054144,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input().strip())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054144
1390054138,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        sc.nextLine();
        while (t-- > 0) {
            String s = sc.nextLine();
            System.out.println(minCost(s));
        }
    }
    public static int minCost(String s) {
        int n = s.length();
        int totalOnes = 0, totalZeros = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1') totalOnes++;
            else totalZeros++;
        }
        int minCost = Integer.MAX_VALUE;
        int onesLeft = 0, zerosLeft = 0;
        for (int i = 0; i <= n; i++) {
            int onesRemoved = onesLeft + (totalOnes - onesLeft); 
            int zerosRemaining = totalZeros - zerosLeft; 
            int cost = Math.max(zerosRemaining, onesRemoved);
            minCost = Math.min(minCost, cost);
            if (i < n) {
                if (s.charAt(i) == '1') onesLeft++;
                else zerosLeft++;
            }
        }
        return minCost;
    }
}",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054138
1390054139,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while (T-- > 0) {
            String s = sc.next(); 
            System.out.println(minDecommissionCost(s));
        }
        sc.close();
    }
    private static int minDecommissionCost(String s) {
        char[] chars = s.toCharArray();
        int n = chars.length;
        int totalOnes = 0;
        for (char c : chars) {
            if (c == '1') totalOnes++;
        }
        int minCost = totalOnes; 
        int zerosInSegment = 0;
        int onesInSegment = 0;
        for (int start = 0; start < n; start++) {
            zerosInSegment = 0;
            onesInSegment = 0;
            for (int end = start; end < n; end++) {
                if (chars[end] == '0') {
                    zerosInSegment++;
                } else {
                    onesInSegment++;
                }
                int onesRemoved = totalOnes - onesInSegment;
                int cost = Math.max(zerosInSegment, onesRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054139
1390054140,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054140
1390054136,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054136
1390054133,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054133
1390054135,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    """"""
    Finds the earliest faulty reading for each consecutive batch of size k.
    Args:
        arr: A list of sensor readings (integers).
        k: The batch size.
    Returns:
        A list of earliest faulty readings for each batch.
    """"""
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        earliest_fault = 0
        for j, reading in enumerate(batch):
            if reading < 0:
                earliest_fault = reading
                break
        result.append(earliest_fault)
    return result
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = find_earliest_faults(arr, k)
        print(*result)
solve()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054135
1390054134,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # Initialize dp array with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        firewall_idx = i - 1  # Convert to 0-indexed
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            if j <= i - 1:  # Ensure we have processed enough firewalls
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
            # Option 2: Skip the current firewall
            if j > 0:  # We must have at least one skip available
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Return the minimum effort after processing all firewalls
    return dp[n][k]
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054134
1390054129,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054129
1390054130,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        first_faulty = 0  
        for num in batch:
            if num < 0:
                first_faulty = num
                break  
        result.append(first_faulty)
    print(*result)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054130
1390054132,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        result = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            earliest_fault = 0
            for num in batch:
                if num < 0:
                    earliest_fault = num
                    break
            result.append(earliest_fault)
        results.append(result)
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute results
results = earliest_faulty_readings(test_cases)
# Output results
for result in results:
    print(' '.join(map(str, result)) + ' ')",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054132
1390054124,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]  # Read n and k
        firewalls = test_cases[t][1]  # Read firewall strengths
        # Sort indices of firewalls by their strength in descending order
        sorted_indices = sorted(range(n), key=lambda i: -firewalls[i])
        # Store indices of the `k` firewalls to skip
        skipped = set(sorted_indices[:k])
        total_effort = 0
        increment = 0  # This keeps track of the number of skipped firewalls before each one
        for i in range(n):
            if i in skipped:
                increment += 1  # Each skip increases later firewalls' strength
            else:
                total_effort += firewalls[i] + increment  # Add effort with increments
        results.append(total_effort)
    return results
# Reading input
T = int(input().strip())  
test_cases = []
for _ in range(T):
    n, k = map(int, input().strip().split())  
    firewalls = list(map(int, input().strip().split()))  
    test_cases.append(((n, k), firewalls))
# Get results
output = min_effort_to_breach(T, test_cases)
# Print results
for res in output:
    print(res)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054124
1390054127,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054127
1390054128,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    # Process the first batch of size k
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process remaining batches
    for i in range(n - k + 1):
        # Append earliest faulty reading or 0 if none
        result.append(arr[dq[0]] if dq else 0)
        # Remove elements that are out of this window
        if dq and dq[0] == i:
            dq.popleft()
            printvtdr",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054128
1390054123,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054123
1390054116,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        # Identify the first and last active server (1)
        first_active = servers.find('1')
        last_active = servers.rfind('1')
        # If there are no active servers, the cost is 0
        if first_active == -1:
            results.append(0)
            continue
        # Extract the relevant segment of servers
        trimmed_servers = servers[first_active:last_active + 1]
        # Count idle servers (0's) that remain
        idle_remaining = trimmed_servers.count('0')
        # Count active servers (1's) that need to be removed
        active_removed = servers[:first_active].count('1') + servers[last_active + 1:].count('1')
        # Compute the cost
        cost = max(idle_remaining, active_removed)
        results.append(str(cost))
    return results
# Read input
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
# Compute and print results
print(""\n"".join(min_decommissioning_cost(test_cases)))",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054116
1390054118,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        benefits.sort(reverse=True)
        skipped = [False] * n
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        total_effort = 0
        penalty = 0 
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
threading.Thread(target=main).start()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054118
1390054120,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if _name_ == ""_main_"":
    main()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054120
1390054110,unknown,unknown,unknown,"import java.util.*;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        while (T-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            if (k >= n) {
                System.out.println(0);
                continue;
            }
            long totalEffort = 0;
            for (int value : a) {
                totalEffort += value;
            }
            if (k == 0) {
                System.out.println(totalEffort);
                continue;
            }
            long[] netReduction = new long[n];
            for (int i = 0; i < n; i++) {
                netReduction[i] = a[i] - (n - i - 1);
            }
            Arrays.sort(netReduction);
            long maxReduction = 0;
            for (int i = 0; i < k; i++) {
                maxReduction += netReduction[n - 1 - i];
            }
            long minEffort = totalEffort - maxReduction;
            System.out.println(minEffort);
        }
        scanner.close();
    }
}",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054110
1390054111,unknown,unknown,unknown,"import java.util.*;
public class DataCenterOptimization {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = Integer.parseInt(sc.nextLine());
        while (T-- > 0) {
            String s = sc.nextLine();
            int n = s.length();
            int totalActive = 0, totalIdle = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') totalActive++;
                else totalIdle++;
            }
            int[] prefixActive = new int[n + 1];
            int[] prefixIdle = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixActive[i + 1] = prefixActive[i] + (s.charAt(i) == '1' ? 1 : 0);
                prefixIdle[i + 1] = prefixIdle[i] + (s.charAt(i) == '0' ? 1 : 0);
            }
            int minCost = Integer.MAX_VALUE;
            // Try all possible (l, r) subarrays to keep
            for (int l = 0; l <= n; l++) {
                for (int r = l; r <= n; r++) {
                    int idleLeft = prefixIdle[r] - prefixIdle[l];
                    int activeRemoved = prefixActive[l] + (totalActive - prefixActive[r]);
                    int cost = Math.max(idleLeft, activeRemoved);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054111
1390054114,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if _name_ == ""_main_"":
    main()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054114
1390054101,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    skipped_indices = set()
    remaining_indices = set(range(n))
    current_effort = sum(a)
    min_effort = current_effort
    for _ in range(k):
        best_skip_index = -1
        max_benefit = -float('inf')
        for i in list(remaining_indices):
            benefit = a[i]
            increase = 0
            for j in remaining_indices:
                if j > i:
                    increase += 1
            current_benefit = benefit - increase
            if current_benefit > max_benefit:
                max_benefit = current_benefit
                best_skip_index = i
        if best_skip_index != -1 and max_benefit > 0:
            skipped_indices.add(best_skip_index)
            remaining_indices.remove(best_skip_index)
            current_effort -= max_benefit
            min_effort = min(min_effort, current_effort)
        else:
            break
    final_effort = 0
    skipped_list = sorted(list(skipped_indices))
    for i in range(n):
        if i not in skipped_indices:
            strength_increase = 0
            for skipped_index in skipped_list:
                if skipped_index < i:
                    strength_increase += 1
            final_effort += a[i] + strength_increase
    min_effort = min(min_effort, final_effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054101
1390054104,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054104
1390054106,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054106
1390054100,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054100
1390054094,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054094
1390054099,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        batch_results = []
        for i in range(n - k + 1):
            # Extract the current batch
            batch = arr[i:i + k]
            # Find the first negative number in the batch
            earliest_fault = 0
            for num in batch:
                if num < 0:
                    earliest_fault = num
                    break
            batch_results.append(earliest_fault)
        results.append(batch_results)
    return results
# Input reading
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])  # Number of test cases
    idx += 1
    test_cases = []
    for _ in range(t):
        n = int(data[idx])  # Size of the array
        k = int(data[idx + 1])  # Batch size
        idx += 2
        arr = list(map(int, data[idx:idx + n]))  # Array of sensor readings
        idx += n
        test_cases.append((n, k, arr))
    # Compute results
    results = earliest_faulty_readings(test_cases)
    # Output results
    for result in results:
        print("" "".join(map(str, result)))
if __name__ == ""__main__"":
    main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054099
1390054095,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    # Iterate from left
    left_ones = 0
    for i in range(n + 1):
        remaining = s[i:]
        idle_count = remaining.count('0')
        min_cost = min(min_cost, max(idle_count, left_ones))
        if i < n and s[i] == '1':
            left_ones += 1
    # Iterate from right
    right_ones = 0
    for i in range(n, -1, -1):
        remaining = s[:i]
        idle_count = remaining.count('0')
        min_cost = min(min_cost, max(idle_count, right_ones))
        if i > 0 and s[i - 1] == '1':
            right_ones += 1
    #Combine Iterations
    for i in range(n+1):
      left_ones = s[:i].count('1')
      right_ones = s[n:].count('1')
      remaining = s[i:]
      for j in range(len(remaining)+1):
        remaining_sub = remaining[:len(remaining)-j]
        right_ones = s[n-j:].count('1')
        idle_count = remaining_sub.count('0')
        min_cost = min(min_cost, max(idle_count, left_ones+right_ones))
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054095
1390054091,unknown,unknown,unknown,"def min_decommission_cost(rack):
    n = len(rack)
    # Initialize minimum cost to a high value
    min_cost = float('inf')
    # Try all possible combinations of removing from start and end
    for start in range(n + 1):
        for end in range(n + 1):
            # Skip invalid configurations
            if start + end > n:
                continue
            # Calculate the remaining rack after decommissioning
            remaining = rack[start:n-end]
            if not remaining:
                # If we removed everything, cost is just removed active servers
                removed_active = rack[:start].count('1') + rack[n-end:].count('1')
                cost = removed_active
            else:
                # Calculate remaining idle servers
                remaining_idle = remaining.count('0')
                # Calculate decommissioned active servers
                removed_active = rack[:start].count('1') + rack[n-end:].count('1')
                # Cost is the maximum of the two
                cost = max(remaining_idle, removed_active)
            # Update minimum cost
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        rack = input().strip()
        result = min_decommission_cost(rack)
        print(result)
if __name__ == ""__main__"":
    main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054091
1390054090,unknown,unknown,unknown,"def find_earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):  # Iterate through all possible windows
        found = False
        # Scan the window to find the first negative number
        for j in range(i, i + k):
            if arr[j] < 0:
                result.append(arr[j])
                found = True
                break  # Stop when the first negative number is found
        if not found:
            result.append(0)  # If no negative number is found, add 0
    return result
# Input handling
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    result = find_earliest_fault(arr, k)
    print(*result)
    ",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054090
1390054088,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054088
1390054087,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054087
1390054089,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if _name_ == ""_main_"":
    main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054089
1390054085,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        values = [a[i] + i for i in range(n)]
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054085
1390054082,unknown,unknown,unknown,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class ServerPruning {
    public static int minPruningCost(String serverRack) {
        int n = serverRack.length();
        int left = 0, right = n - 1;
        // Remove leading idle servers (0s)
        while (left <= right && serverRack.charAt(left) == '0') {
            left++;
        }
        // Remove trailing idle servers (0s)
        while (right >= left && serverRack.charAt(right) == '0') {
            right--;
        }
        // If no active servers remain
        if (left > right) return 0;
        // Count remaining idle servers
        int idleCount = 0;
        for (int i = left; i <= right; i++) {
            if (serverRack.charAt(i) == '0') {
                idleCount++;
            }
        }
        // Active servers removed
        int activeRemoved = left + (n - 1 - right);
        return Math.max(idleCount, activeRemoved);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine().trim());
        StringBuilder output = new StringBuilder();
        while (T-- > 0) {
            String serverRack = br.readLine().trim();
            output.append(minPruningCost(serverRack)).append(""\n"");
        }
        System.out.print(output);
    }
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054082
1390054083,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process the rest of the array
    for i in range(len(arr) - k + 1):
        # Append the earliest faulty reading
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of this window
        if dq and dq[0] == i:
            dq.popleft()
        # Add the next element if it is faulty
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
def process_test_cases(test_cases):
    results = []
    for n, k, arr in test_cases:
        results.append("" "".join(map(str, earliest_faults(arr, k))))
    return ""\n"".join(results)
# Example test cases for debugging
test_cases = [
    (5, 2, [-8, 2, 3, -6, 10]),
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
]
# Running test cases
print(process_test_cases(test_cases))",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054083
1390054084,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active servers and total idle servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative counts of active servers from left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible starting positions for the remaining servers
    for left in range(n + 1):
        # For each possible ending position
        for right in range(left, n + 1):
            # Active servers in the remaining segment
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active and idle servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case cost
    # For each possible remaining substring (from i to j-1)
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in remaining substring
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (from left and right)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054084
1390054078,unknown,unknown,unknown,"def min_cost(servers):
    n = len(servers)
    # Remove leading and trailing 0s
    start, end = 0, n - 1
    while start < n and servers[start] == '0':
        start += 1
    while end >= 0 and servers[end] == '0':
        end -= 1
    if start > end:  # If only 0s exist, no cost is needed
        return 0
    core = servers[start:end + 1]  # Core segment without leading/trailing 0s
    total_ones = core.count('1')
    total_zeros = core.count('0')
    min_cost = max(total_zeros, 0)  # Removing no 1s initially
    removed_ones = 0
    for ch in core:
        if ch == '1':
            removed_ones += 1
        else:
            total_zeros -= 1  # Decrease remaining 0s
        # Cost = max(remaining 0s, removed 1s)
        min_cost = min(min_cost, max(total_zeros, removed_ones))
    return min_cost
# Reading input
T = int(input())  # Number of test cases
for _ in range(T):
    servers = input().strip()
    print(min_cost(servers))",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054078
1390054080,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054080
1390054081,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054081
1390054075,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if _name_ == ""_main_"":
    main()",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054075
1390054076,unknown,unknown,unknown,"def earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        # Check each batch of size k
        batch = arr[i:i+k]
        fault_found = False
        # Find the earliest fault in the current batch
        for num in batch:
            if num < 0:
                result.append(num)
                fault_found = True
                break
        # If no fault is found in the batch, append 0
        if not fault_found:
            result.append(0)
    return result
# Process the input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))  # Array elements
    result = earliest_fault(arr, k)
    print(*result)  # Print the result",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054076
1390054077,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // wtf ,  check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054077
1390054074,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            System.out.println(minEffort(n, k, arr));
        }
        sc.close();
    }
    static int minEffort(int n, int k, int[] arr) {
        int[][] dp = new int[n + 1][k + 1];
        for (int i = n - 1; i >= 0; i--) {
            for (int skip = 0; skip <= k; skip++) {
                int take = arr[i] + skip;
                if (i + 1 < n) take += dp[i + 1][skip];
                int leave = Integer.MAX_VALUE;
                if (skip < k && i + 1 <= n) leave = dp[i + 1][skip + 1];
                dp[i][skip] = Math.min(take, leave);
            }
        }
        return dp[0][0];
    }
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054074
1390054061,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j  
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054061
1390054066,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054066
1390054071,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # We'll use a more memory-efficient approach that avoids potential
    # runtime errors with large inputs
    # For each firewall, calculate the ""gain"" from skipping it
    # Gain = firewall strength - penalty to subsequent firewalls
    gains = []
    for i in range(n):
        # Original cost of the firewall
        original_cost = firewalls[i]
        # Penalty to subsequent firewalls if we skip this one
        penalty = n - i - 1
        # Gain = what we save by skipping this firewall
        gain = original_cost - penalty
        gains.append((gain, i))
    # Sort by gain in descending order
    gains.sort(reverse=True)
    # Mark the firewalls to skip (the k firewalls with highest gain)
    to_skip = set()
    for i in range(min(k, n)):
        if i < len(gains) and gains[i][0] > 0:  # Only skip if gain is positive
            to_skip.add(gains[i][1])
    # Calculate the total effort
    skipped_so_far = 0
    total_effort = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            skipped_so_far += 1
        else:
            # Pay the cost of this firewall (including penalties)
            total_effort += firewalls[i] + skipped_so_far
    return total_effort
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054071
1390054054,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054054
1390054055,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k);
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054055
1390054058,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    n = len(server_rack)
    total_active = server_rack.count('1')
    min_cost = float('inf')
    for prefix in range(n + 1):  
        for suffix in range(n + 1 - prefix):  # Servers to remove from end
            remaining = server_rack[prefix:n-suffix]
            if not remaining:  
                continue
            active_remaining = remaining.count('1')
            idle_remaining = len(remaining) - active_remaining
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve_test_cases():
    t = int(input())  
    for _ in range(t):
        server_rack = input().strip()
        print(min_decommission_cost(server_rack))
if __name__ == ""__main__"":
    test_cases = [
        ""101110110"",
        ""1001001001001"",
        ""0000111111""
    ]
    for rack in test_cases:
        cost = min_decommission_cost(rack)
        print(cost)",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054058
1390054052,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(min(i, k) + 1):
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
            if dp[i-1][j] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
    return min(dp[n])
def solve():
    t = int(input().strip())
    results = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        strengths = list(map(int, input().strip().split()))
        results.append(str(min_effort_to_breach(n, k, strengths)))
    print(""\n"".join(results))
solve()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054052
1390054053,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    l, r = 0, n - 1
    while l < n and s[l] == ""0"":
        l += 1
    while r >= 0 and s[r] == ""0"":
        r -= 1
    if l > r:
        print(0)
        continue
    s = s[l:r + 1]
    n = len(s)
    ones = s.count(""1"")
    zeros = s.count(""0"")
    c = min(ones, zeros)
    x = 0
    for i in s:
        if i == ""1"":
            x += 1
        else:
            zeros -= 1
        c = min(c, max(x, zeros))
    print(c)",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054053
1390054051,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054051
1390054050,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    total_effort = sum(strengths)
    if k == n:
        return 0
    min_effort = total_effort
    for i in range(n):
        skipped = min(k, i + 1) 
        effort = sum(strengths[:i]) + sum(strengths[i + 1:]) + (n - i - 1) * skipped
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort(n, k, strengths))",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054050
1390054045,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        # Identify the first and last active server (1)
        first_active = servers.find('1')
        last_active = servers.rfind('1')
        # If there are no active servers, the cost is 0
        if first_active == -1:
            results.append(0)
            continue
        # Extract the relevant segment of servers
        trimmed_servers = servers[first_active:last_active + 1]
        # Count idle servers (0's) that remain
        idle_remaining = trimmed_servers.count('0')
        # Count active servers (1's) that need to be removed
        active_removed = servers[:first_active].count('1') + servers[last_active + 1:].count('1')
        # Compute the cost
        cost = max(idle_remaining, active_removed)
        results.append(cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute and print results
for result in min_decommissioning_cost(test_cases):
    print(result)",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054045
1390054047,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        remaining = s[i:]
        idle_count = remaining.count('0')
        active_removed = s[:i].count('1')
        min_cost = min(min_cost, max(idle_count, active_removed))
    for j in range(n + 1):
        remaining = s[:n-j]
        idle_count = remaining.count('0')
        active_removed = s[n-j:].count('1')
        min_cost = min(min_cost, max(idle_count, active_removed))
    for i in range(n+1):
        for j in range(n-i+1):
            remaining = s[i:n-j]
            idle_count = remaining.count('0')
            active_removed = s[:i].count('1') + s[n-j:].count('1')
            min_cost = min(min_cost, max(idle_count, active_removed))
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054047
1390054048,unknown,unknown,unknown,"cases = int(input())
for t in range(cases):
    n,k = [int(i) for i in input().split()]
    array = [int(i) for i in input().split()]
    if n == k:
        print(0)
        continue
    batch_sum = [0]*n
    for i in range(n):
        batch_sum[i] = sum(array[i:i+k])
    total = sum(array)
    best = total
    for i in range(n):
        best = min(best, total -batch_sum[i] + n-i-k)
    print(best)
    ",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054048
1390054039,unknown,unknown,unknown,"def min_cost_to_decommission(rack):
    length = len(rack)
    min_cost = float('inf')
    for prefix in range(length + 1):
        for suffix in range(length + 1 - prefix):
            remaining = rack[prefix:length - suffix]
            if not remaining:
                continue
            idle_count = remaining.count('0')
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
            cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
cases = int(input().strip())
results = []
for _ in range(cases):
    rack = input().strip()
    results.append(min_cost_to_decommission(rack))
print(""\n"".join(map(str, results)))",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054039
1390054042,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054042
1390054044,unknown,unknown,unknown,"def minimum_pruning_cost(rack):
    n = len(rack)
    prefix_active = [0] * (n + 1)
    for i in range(n):
        prefix_active[i+1] = prefix_active[i] + (1 if rack[i] == '1' else 0)
    min_cost = float('inf')
    for left in range(n): 
        for right in range(n):  
            if left + right >= n:
                continue
            if left == 0 and right == 0:
                continue
            active_left = prefix_active[left]
            active_right = prefix_active[n] - prefix_active[n-right]
            active_decommissioned = active_left + active_right
            remaining_start = left
            remaining_end = n - right
            remaining_total = remaining_end - remaining_start
            remaining_active = prefix_active[remaining_end] - prefix_active[remaining_start]
            remaining_idle = remaining_total - remaining_active
            cost = max(remaining_idle, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input().strip())
    for _ in range(t):
        server_rack = input().strip()
        print(minimum_pruning_cost(server_rack))
if __name__ == ""__main__"":
    solve()",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054044
1390054035,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;
int solve(vector<int>&arr, int i, int skip, int inc) {
    int n = arr.size();
    if(i==n){
        return 0;
    }
    //skip
    int ans = INT_MAX;
    if(skip) {
        ans = min(ans,solve(arr,i+1,skip-1,inc+1));
    }
    //no skip
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc));
    return ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--) {
        int n,skip;
        cin>>n>>skip;
        vector<int>arr;
        while(n--) {
            int a;
            cin>>a;
            arr.push_back(a);
        }
        cout<<solve(arr,0,skip,0)<<endl;
    }
    return 0;
}",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054035
1390054036,unknown,unknown,unknown,"def main():
    import sys
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054036
1390054038,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054038
1390054034,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int t = input.nextInt();  // Number of test cases
        while (t-- > 0) {
            int N = input.nextInt();  // Array size
            int K = input.nextInt();  // Batch size
            int[] arr = new int[N];
            for (int i = 0; i < N; i++) {
                arr[i] = input.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, K);
            // Print the result for this test case
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        input.close();
    }
    public static List<Integer> findEarliestFaults(int[] arr, int K) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();  // Stores indices of negative numbers
        int n = arr.length;
        // Process first window of size K
        for (int i = 0; i < K; i++) {
            if (arr[i] < 0) {
                deque.addLast(i);
            }
        }
        // Process remaining elements
        for (int i = K; i <= n; i++) {
            // If deque is not empty, the first element is the earliest fault
            if (!deque.isEmpty()) {
                result.add(arr[deque.peekFirst()]);
            } else {
                result.add(0);
            }
            // Remove elements that are out of the current window
            if (!deque.isEmpty() && deque.peekFirst() <= i - K) {
                deque.pollFirst();
            }
            // Add next element (if negative)
            if (i < n && arr[i] < 0) {
                deque.addLast(i);
            }
        }
        return result;
    }
}",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054034
1390054029,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerPruning {
    public static int minPruningCost(String serverRack) {
        int n = serverRack.length();
        int minCost = n + 1; // Initialize with a value larger than any possible cost
        for (int leftRemoveCount = 0; leftRemoveCount <= n; ++leftRemoveCount) {
            for (int rightRemoveCount = 0; rightRemoveCount <= n - leftRemoveCount; ++rightRemoveCount) {
                int idleRemaining = 0;
                int activeRemoved = 0;
                // Calculate active_removed
                for (int i = 0; i < leftRemoveCount; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        activeRemoved++;
                    }
                }
                for (int i = n - rightRemoveCount; i < n; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        activeRemoved++;
                    }
                }
                // Calculate idle_remaining
                for (int i = leftRemoveCount; i < n - rightRemoveCount; ++i) {
                    if (serverRack.charAt(i) == '0') {
                        idleRemaining++;
                    }
                }
                int cost = Math.max(idleRemaining, activeRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = Integer.parseInt(sc.nextLine().trim());
        while (T-- > 0) {
            String serverRack = sc.nextLine().trim();
            System.out.println(minPruningCost(serverRack));
        }
        sc.close();
    }
}",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054029
1390054031,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054031
1390054032,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;
int minEffortToBreach(int n, int k, vector<int>& strengths) {
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));
    // Base case: No firewalls, no effort
    for (int j = 0; j <= k; ++j) {
        dp[0][j] = 0;
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            // Option 1: Skip current firewall (if skips are available)
            if (j > 0) {
                dp[i][j] = dp[i - 1][j - 1];
            }
            // Option 2: Don't skip current firewall
            int currentStrength = strengths[i - 1] + j; // Strength increases due to previous skips
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + currentStrength);
        }
    }
    // Return minimum effort among all possible ways to use up to k skips
    return *min_element(dp[n].begin(), dp[n].end());
}
void solve() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> strengths(n);
        for (int i = 0; i < n; ++i) {
            cin >> strengths[i];
        }
        cout << minEffortToBreach(n, k, strengths) << endl;
    }
}
int main() {
    solve();
    return 0;
}",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054032
1390054018,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054018
1390054020,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054020
1390054022,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    n = len(server_rack)
    total_ones = server_rack.count('1')
    min_cost = float('inf')
    prefix_ones = [0] * (n + 1)
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
    for left in range(n + 1):
        for right in range(left, n + 1):
            ones_in_substring = prefix_ones[right] - prefix_ones[left]
            zeros_in_substring = prefix_zeros[right] - prefix_zeros[left]
            ones_removed = total_ones - ones_in_substring
            cost = max(zeros_in_substring, ones_removed)
            if cost < min_cost:
                min_cost = cost
    return min_cost
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(min_decommission_cost(server_rack))",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054022
1390054014,unknown,unknown,unknown,"def min_cost_server_optimization(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n + 1 - i): 
            if i + j > n:
                continue
            remaining = server_rack[i:n-j]
            if not remaining:  
                continue
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    results = []
    for _ in range(t):
        server_rack = input().strip()
        results.append(min_cost_server_optimization(server_rack))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054014
1390054016,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(n):
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            if i >= k - 1:
                res.append(arr[dq[0]] if dq else 0)
        results.append(res)
    return results
# Reading input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing and output
for result in earliest_faulty_readings(test_cases):
    print(*result)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054016
1390054013,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for s in test_cases:
        first_one = s.find('1')
        last_one = s.rfind('1')
        if first_one == -1:  # If there are no '1's, return 0
            results.append(0)
            continue
        # Trim the string to only consider the section between the first and last '1'
        trimmed = s[first_one:last_one + 1]
        # Count the number of idle servers ('0's) remaining in the trimmed section
        idle_servers_remaining = trimmed.count('0')
        # Count the number of active servers ('1's) removed from the start and end
        active_servers_removed = first_one + (len(s) - 1 - last_one)
        # The cost is the maximum of these two values
        results.append(max(idle_servers_remaining, active_servers_removed))
    return results
# Read input
T = int(input().strip())
test_cases = [input().strip() for _ in range(T)]
# Get results and print them
for res in min_decommissioning_cost(test_cases):
    print(res)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054013
1390054012,unknown,unknown,unknown,"import java.util.*;
public class ServerDecommissioning {
    public static int minDecommissionCost(String servers) {
        int firstActive = servers.indexOf('1');
        int lastActive = servers.lastIndexOf('1');
        if (firstActive == -1) return 0; // No active servers
        String relevantPart = servers.substring(firstActive, lastActive + 1);
        int idleCount = 0, activeRemoved = 0;
        for (char c : relevantPart.toCharArray()) {
            if (c == '0') idleCount++;
            else activeRemoved++;
        }
        return Math.min(activeRemoved, idleCount);
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        while (t-- > 0) {
            String servers = scanner.nextLine();
            System.out.println(minDecommissionCost(servers));
        }
        scanner.close();
    }
}",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054012
1390054010,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    if k == n:
        return 0
    if k == 0:
        return sum(firewalls)
    min_effort = float('inf')
    for i in range(n):
        skipped = 0
        effort = 0
        for j in range(n):
            if skipped < k and j >= i:
                skipped += 1
            else:
                effort += firewalls[j] + skipped
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input().strip())
results = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    results.append(min_effort(n, k, firewalls))
for res in results:
    print(res)",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054010
1390054011,unknown,unknown,unknown,"def earliest_faulty_readings(t, testcases):
    results = []
    for case in testcases:
        n, k, arr = case
        faults = []
        for i in range(n - k + 1):  # Iterate over all possible batches
            batch = arr[i:i + k]  # Extract the current batch
            earliest_fault = 0  # Default to 0 if no faulty component is found
            for num in batch:  # Check each number in the batch
                if num < 0:  # If it's faulty, take it as the earliest
                    earliest_fault = num
                    break  # Exit the loop as we found the earliest fault
            faults.append(earliest_fault)  # Add result for this batch
        results.append(faults)  # Collect results for this test case
    return results
# Read input
t = int(input())
testcases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    testcases.append((n, k, arr))
# Solve and print the results
outputs = earliest_faulty_readings(t, testcases)
for output in outputs:
    print(' '.join(map(str, output)))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054011
1390054008,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active servers and total idle servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative counts of active servers from left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible starting positions for the remaining servers
    for left in range(n + 1):
        # For each possible ending position
        for right in range(left, n + 1):
            # Active servers in the remaining segment
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active and idle servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case cost
    # For each possible remaining substring (from i to j-1)
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in remaining substring
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (from left and right)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054008
1390054004,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    # Process the first batch
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the earliest faulty reading of the first batch
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining batches
    for i in range(k, len(arr)):
        # Remove elements that are out of the current batch
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it's faulty
        if arr[i] < 0:
            dq.append(i)
        # Store the earliest faulty reading of the current batch
        result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print("" "".join(map(str, earliest_faults(arr, k))))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054004
1390054003,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054003
1390054005,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054005
1390053998,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # Get indices of active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # Define the check function
        def check(X):
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                while j < m and A[j] - A[i] <= X:
                    j += 1
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == ""__main__"":
    solve()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053998
1390053999,unknown,unknown,unknown,"def earliest_fault(arr,k):
    result=[]
    neg=[]
    for i in range(len(arr)):
        while neg and neg[0]<i-k+1:
            neg.pop(0)
        if arr[i]<0:
            neg.append(i)
        if i>=k-1:
            result.append(arr[neg[0]] if neg else 0)
    return result
t= int(input())
for _ in range(t):
    n,k=map(int, input().split())
    arr= list(map(int,input().split()))
    print("" "".join(map(str,earliest_fault(arr,k))))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053999
1390054001,unknown,unknown,unknown,"def min_decommission_cost(s):
    total_ones = s.count('1')
    if total_ones == 0:
        return 0  # No active servers, cost is 0
    # Find first and last '1' in the string
    first_one = s.find('1')
    last_one = s.rfind('1')
    # Consider the segment between first_one and last_one
    min_cost = total_ones  # Worst case: remove all ones
    for start in range(first_one, last_one + 1):
        for end in range(start, last_one + 1):
            segment = s[start:end+1]
            ones_in_segment = segment.count('1')
            zeros_in_segment = segment.count('0')
            removed_ones = total_ones - ones_in_segment
            cost = max(zeros_in_segment, removed_ones)
            min_cost = min(min_cost, cost)
    return min_cost
# Read input
t = int(input().strip())
for _ in range(t):
    s = input().strip()
    print(min_decommission_cost(s))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054001
1390053997,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053997
1390053994,unknown,unknown,unknown,"# Read number of test cases
t = int(input().strip())
for _ in range(t):
    servers = input().strip()
    n = len(servers)
    # Track active and idle counts with 1D arrays
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (1 if servers[i] == '1' else 0)
        idle_prefix[i + 1] = idle_prefix[i] + (1 if servers[i] == '0' else 0)
    total_active = active_prefix[n]
    total_idle = idle_prefix[n]
    min_cost = n  # Start with worst possible cost
    # For each possible middle segment [left, right)
    for left in range(n + 1):
        # Instead of trying all rights, use two pointers technique
        right = left
        while right <= n:
            # Calculate metrics
            active_removed = active_prefix[left] + (total_active - active_prefix[right])
            idle_remaining = idle_prefix[right] - idle_prefix[left]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
            # If active_removed > idle_remaining, increasing right might help
            # If active_removed < idle_remaining, we need to increase left
            if active_removed > idle_remaining and right < n:
                right += 1
            else:
                break
    print(min_cost)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053994
1390053995,unknown,unknown,unknown,"def min_effort_to_breach(t, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        # Sort firewalls in ascending order
        firewalls.sort()
        # Increase the strength of the remaining firewalls
        total_effort = 0
        for i in range(k, n):
            total_effort += firewalls[i] + k  # Since we skipped k firewalls, each gets +k
        results.append(total_effort)
    return results
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Get results
output = min_effort_to_breach(t, test_cases)
# Print results
for res in output:
    print(res)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053995
1390053997,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053997
1390053990,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053990
1390053992,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
void solve() {
    int n, k;
    cin >> n >> k;
    vector<ll> arr(n);
    ll total = 0;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
        total += arr[i];
    }
    vector<ll> benefits(n);
    for (int j = 0; j < n; j++){
        benefits[j] = arr[j] - (n - 1 - j);
    }
    sort(benefits.begin(), benefits.end(), greater<ll>());
    ll best = total;
    ll sumb = 0;
    int m = min(k, n);
    for (int i = 0; i < m; i++){
        if (benefits[i] < 0) {
        }
        sumb += benefits[i];
        int skips = i + 1;
        ll candidate = total - sumb - (skips * (skips - 1LL)) / 2LL;
        best = min(best, candidate);
    }
    cout << best << ""\n"";
}
int main() {
    int t; cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053992
1390053993,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053993
1390053987,unknown,unknown,unknown,"import sys
import threading
def main():
    T = int(sys.stdin.readline())
    for _ in range(T):
        n, k = map(int, sys.stdin.readline().split())
        a = list(map(int, sys.stdin.readline().split()))
        # We calculate the ""gain"" of skipping a firewall:
        # Skipping it saves a[i], but increases the cost of subsequent firewalls by 1.
        # So we rank the firewalls by how beneficial it is to skip them.
        # We sort by a[i] - (n - i - 1), because skipping early firewalls increases cost of more firewalls.
        # The higher this value, the better it is to skip.
        benefits = []
        for i in range(n):
            benefit = a[i] - (n - i - 1)
            benefits.append((benefit, i))
        # Sort by benefit descending
        benefits.sort(reverse=True)
        skipped = [False] * n
        # Mark the top k firewalls to skip
        for i in range(k):
            _, idx = benefits[i]
            skipped[idx] = True
        # Calculate total effort
        total_effort = 0
        penalty = 0  # number of skipped firewalls so far
        for i in range(n):
            if skipped[i]:
                penalty += 1
            else:
                total_effort += a[i] + penalty
        print(total_effort)
# Run main() inside a separate thread to avoid recursion limit issues in large input
threading.Thread(target=main).start()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053987
1390053988,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    skipped_indices = set()
    current_effort = 0
    for i in range(n):
        current_effort += a[i]
    min_effort = current_effort
    for _ in range(k):
        best_reduction = 0
        best_skip_index = -1
        for i in range(n):
            if i not in skipped_indices:
                reduction = a[i]
                increase = 0
                for j in range(i + 1, n):
                    if j not in skipped_indices:
                        increase += 1
                current_reduction = reduction - increase
                if current_reduction > best_reduction:
                    best_reduction = current_reduction
                    best_skip_index = i
        if best_skip_index != -1 and best_reduction > 0:
            skipped_indices.add(best_skip_index)
            current_effort -= best_reduction
            min_effort = min(min_effort, current_effort)
        else:
            break
    final_effort = 0
    for i in range(n):
        if i not in skipped_indices:
            strength_increase = 0
            for skipped_index in skipped_indices:
                if skipped_index < i:
                    strength_increase += 1
            final_effort += a[i] + strength_increase
    min_effort = min(min_effort, final_effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053988
1390053989,unknown,unknown,unknown,"import bisect
t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    if n == 0:
        print(0)
        continue
    if n == 1:
        print(0)
        continue
    if n == 2:
        print(1 if s[0] == s[1] else 0)
        continue
    prefix_0 = [0] * (n + 1)
    prefix_1 = [0] * (n + 1)
    for i in range(n):
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]
    low, high = 0, n
    while low < high:
        m = (low + high) // 2
        possible = False
        for j in range(n + 1):
            target = prefix_0[j] - m
            i = bisect.bisect_left(prefix_0, target)
            if i <= j:
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
                if ones_removed <= m:
                    possible = True
                    break
        if possible:
            high = m
        else:
            low = m + 1
    print(low)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053989
1390053985,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process first k elements (first window)
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process rest of the array
    for i in range(n - k + 1):
        # Add earliest faulty reading or 0 if none
        result.append(arr[dq[0]] if dq else 0)
        # Remove elements out of the window
        if dq and dq[0] == i:
            dq.popleft()
        # Add new element to the window
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input().strip())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053985
1390053977,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053977
1390053983,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if _name_ == '_main_':
    solve()",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053983
1390053984,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    a = [0] * (n + 1)
    for i in range(n):
        a[i + 1] = a[i] + (1 if s[i] == ""1"" else 0)
    c = float(""inf"")
    for i in range(n + 1):
        b = a[i]
        l, r = 0, n - i
        while l <= r:
            j = (l + r) // 2
            x = n - i - j
            y = a[n] - a[i] - (a[n] - a[n - j])
            z = x - y
            d = b + (a[n] - a[n - j])
            e = max(z, d)
            c = min(c, e)
            if z > d:
                l = j + 1
            else:
                r = j - 1
    print(c)",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053984
1390053972,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(t-->0){
            int n=sc.nextInt();
            int k=sc.nextInt();
            int arr[]=new int[n];
            for(int i=0;i<n;i++){
                arr[i]=sc.nextInt();
            }
            ArrayList<Integer> ans=new ArrayList<>();
            for(int i=0;i<=n-k;i++){
                boolean flag=false;
                for(int j=i;j<i+k;j++){
                    if(arr[j]<0){
                        flag=true;
                        ans.add(arr[j]);
                        break;
                    }
                }
                if(flag==false){
                    ans.add(0);
                }
            }
            int ans1[]=new int[ans.size()];
            int j=0;
            for(int i=0;i<ans.size();i++){
                ans1[j++]=ans.get(i);
            }
            for(int i=0;i<ans.size();i++){
                System.out.print(ans.get(i)+"" "");
            }
            System.out.println();
        }
    }
}",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053972
1390053975,unknown,unknown,unknown,"def minimum_decommission_cost(server_rack):
    n = len(server_rack)
    total_ones = server_rack.count('1')
    minimum_cost = float('inf')
    prefix_ones = [0] * (n + 1)
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
    for left in range(n + 1):
        for right in range(left, n + 1):
            ones_in_substring = prefix_ones[right] - prefix_ones[left]
            zeros_in_substring = prefix_zeros[right] - prefix_zeros[left]
            ones_removed = total_ones - ones_in_substring
            cost = max(zeros_in_substring, ones_removed)
            if cost < minimum_cost:
                minimum_cost = cost
    return minimum_cost
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(minimum_decommission_cost(server_rack))",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053975
1390053971,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053971
1390053968,unknown,unknown,unknown,"def minimize_effort(n, k, a):
    if k == n:  # If we can skip all firewalls, the total effort is 0.
        return 0
    total_effort = sum(a)  # Initial total effort without skipping
    min_effort = total_effort  # Start with the worst case
    # Try skipping each subset of `k` firewalls and find the minimum effort
    for i in range(n):
        if i + k > n:  # If skipping `k` firewalls goes out of bounds, stop.
            break
        # Calculate new effort after skipping a[i:i+k]
        effort = sum(a[:i]) + sum(a[i + k:])  # Remove the skipped firewalls
        # Apply penalty for skipping `k` firewalls
        penalty = sum(range(1, k + 1))
        effort += penalty
        # Track the minimum effort found
        min_effort = min(min_effort, effort)
    return min_effort
# Driver code to handle multiple test cases
T = int(input().strip())
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    result = minimize_effort(n, k, a)
    print(result)",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053968
1390053969,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n - j]
            idle_count = remaining.count('0')
            active_removed = s[:i].count('1') + s[n - j:].count('1')
            min_cost = min(min_cost, max(idle_count, active_removed))
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053969
1390053970,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); 
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053970
1390053966,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053966
1390053963,unknown,unknown,unknown,"# Read number of test cases
t = int(input().strip())
for _ in range(t):
    servers = input().strip()
    n = len(servers)
    # Precompute prefix sums
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (1 if servers[i] == '1' else 0)
        idle_prefix[i + 1] = idle_prefix[i] + (1 if servers[i] == '0' else 0)
    total_active = active_prefix[n]
    min_cost = n  # Initialize with worst case
    # Try all possible combinations of left and right cuts
    # But do it efficiently by only computing each value once
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Active servers removed
            active_removed = active_prefix[left] + (total_active - active_prefix[right])
            # Idle servers remaining
            idle_remaining = idle_prefix[right] - idle_prefix[left]
            # Calculate cost
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053963
1390053964,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053964
1390053965,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); // Consume the newline after T
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            // Calculate totalOnes and maxConsecutiveOnes
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            // Handle cases where the cost is trivially 0
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            // Binary search for the minimal possible cost
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    // Helper function to calculate maximum ones in any window with at most k zeros
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            // Shrink the window if zeros exceed k
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            // Calculate current number of ones in the window
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053965
1390053957,unknown,unknown,unknown,"t = int(input())  
while t > 0:
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    neg = []
    for i in range(n - k + 1):  
        found = 0  
        for j in range(i, i + k):  
            if arr[j] < 0:
                neg.append(arr[j])  
                found = 1
                break
        if not found:
            neg.append(0) 
    print(*neg)  
    t -= 1 
        ",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053957
1390053958,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            decommissioned_ones = 0
            remaining_zeros = 0
            # Decommission from the beginning
            decommissioned_ones += s[:i].count('1')
            # Decommission from the end
            decommissioned_ones += s[n - j:].count('1')
            # Remaining string after decommissioning
            remaining_string = s[i:n - j]
            remaining_zeros = remaining_string.count('0')
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053958
1390053959,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        sc.nextLine(); 
        while (t-- > 0) {
            String s = sc.nextLine();
            System.out.println(minCost(s));
        }
    }
    public static int minCost(String s) {
        int n = s.length();
        int[] prefixOnes = new int[n + 1];
        int[] suffixZeros = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
        }
        for (int i = n - 1; i >= 0; i--) {
            suffixZeros[i] = suffixZeros[i + 1] + (s.charAt(i) == '0' ? 1 : 0);
        }
        int minCost = Integer.MAX_VALUE;
        for (int left = 0; left <= n; left++) {
            for (int right = 0; right <= n - left; right++) {
                int onesRemoved = prefixOnes[left] + (prefixOnes[n] - prefixOnes[n - right]);
                int zerosLeft = suffixZeros[left] - suffixZeros[n - right];
                int cost = Math.max(zerosLeft, onesRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053959
1390053948,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # Get indices of active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # Define the check function
        def check(X):
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                while j < m and A[j] - A[i] <= X:
                    j += 1
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == ""__main__"":
    solve()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053948
1390053950,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] strengths = new int[n];
            for (int i = 0; i < n; i++) {
                strengths[i] = sc.nextInt();
            }
            long totalEffort = 0;
            for (int i = 0; i < n; i++) {
                totalEffort += strengths[i];
            }
            if (k == 0 || k >= n) {
                System.out.println(k >= n ? 0 : totalEffort);
                continue;
            }
            long[] prefixSum = new long[n - k + 1];
            for (int i = 0; i < k; i++) {
                prefixSum[0] += strengths[i];
            }
            for (int i = 1; i <= n - k; i++) {
                prefixSum[i] = prefixSum[i-1] - strengths[i-1] + strengths[i+k-1];
            }
            long maxSkipSum = 0;
            int bestSkipIndex = 0;
            for (int i = 0; i <= n - k; i++) {
                long benefitOfSkipping = prefixSum[i] - (long)(n - i - k) * k;
                if (benefitOfSkipping > maxSkipSum) {
                    maxSkipSum = benefitOfSkipping;
                    bestSkipIndex = i;
                }
            }
            long minEffort = totalEffort - maxSkipSum;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053950
1390053949,unknown,unknown,unknown,"def min_effort_to_breach(n, firewalls):
    total_effort = sum(firewalls)  
    min_effort = total_effort  
    for i in range(n):
        skipped_effort = total_effort - firewalls[i]
        min_effort = min(min_effort, skipped_effort)  
    return min_effort",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053949
1390053947,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j 
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t): 
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053947
1390053943,unknown,unknown,unknown,"import java.util.*;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int testCases = scanner.nextInt();
        while (testCases-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt(); 
            int[] firewalls = new int[n];
            long totalEffort = 0; 
            for (int i = 0; i < n; i++) {
                firewalls[i] = scanner.nextInt();
                totalEffort += firewalls[i];
            }
            if (k >= n) {
                System.out.println(0);
                continue;
            }
            long[] reductionValues = new long[n];
            for (int i = 0; i < n; i++) {
                reductionValues[i] = firewalls[i] - (n - i - 1);
            }
            Arrays.sort(reductionValues);
            long maxReduction = 0;
            for (int i = 0; i < k; i++) {
                maxReduction += reductionValues[n - 1 - i];
            }
            System.out.println(totalEffort - maxReduction);
        }
        scanner.close();
    }
}",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053943
1390053944,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    // Optimized function to compute the minimum decommission cost for a test case
    public static int minDecommissionCostOptimized(String testCase) {
        int n = testCase.length();
        int[] prefix0 = new int[n + 1];
        int[] prefix1 = new int[n + 1];
        // Build prefix sum arrays for '0's and '1's
        for (int i = 0; i < n; i++) {
            char ch = testCase.charAt(i);
            prefix0[i + 1] = prefix0[i] + (ch == '0' ? 1 : 0);
            prefix1[i + 1] = prefix1[i] + (ch == '1' ? 1 : 0);
        }
        int totalOnes = prefix1[n];
        int minCost = Integer.MAX_VALUE;
        // For each possible starting index i for the remaining segment
        for (int i = 0; i <= n; i++) {
            // Compute the ideal candidate j using the derived formula
            int candidate = i + totalOnes;
            if (candidate > n) {
                candidate = n;
            }
            // Check candidate j as well as neighboring indices to ensure optimal cost
            for (int j : new int[]{candidate, candidate - 1, candidate + 1}) {
                if (j < i || j > n) continue;
                int zerosKept = prefix0[j] - prefix0[i];
                int onesRemoved = prefix1[i] + (totalOnes - prefix1[j]);
                int cost = Math.max(zerosKept, onesRemoved);
                if (cost < minCost) {
                    minCost = cost;
                }
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        scanner.nextLine(); // Consume the newline
        // Process each test case
        for (int t = 0; t < T; t++) {
            String testCase = scanner.nextLine().trim();
            int result = minDecommissionCostOptimized(testCase);
            System.out.println(result);
        }
        scanner.close();
    }
}",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053944
1390053945,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053945
1390053938,unknown,unknown,unknown,,109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053938
1390053941,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053941
1390053937,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053937
1390053934,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        for i in range(n):
            if arr[i] < 0:
                dq.append(i)
            if i >= k - 1:
                while dq and dq[0] < i - k + 1:
                    dq.popleft()
                result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute and print results
for res in earliest_faulty_readings(t, test_cases):
    print(res)",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053934
1390053935,unknown,unknown,unknown,"def min_effort(arr, k):
    n = len(arr)
    if k >= n:
        return 0
    dp = [0] + [float('inf')] * k
    for i in range(n):
        for j in range(min(k, i), -1, -1):
            cost_if_used = dp[j] + arr[i] + j
            if j < k:
                dp[j+1] = min(dp[j+1], dp[j])
            dp[j] = cost_if_used
    return min(dp)
def solve():
    import sys
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    index = 1
    res = []
    for _ in range(t):
        n = int(data[index])
        index += 1
        k = int(data[index])
        index += 1
        arr = list(map(int, data[index:index+n]))
        index += n
        res.append(str(min_effort(arr, k)))
    sys.stdout.write(""\n"".join(res))
if __name__ == ""__main__"":
    solve()",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053935
1390053936,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053936
1390053933,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053933
1390053931,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input().strip())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053931
1390053930,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    a = [0] * (n + 1)
    for i in range(n):
        a[i + 1] = a[i] + (1 if s[i] == ""1"" else 0)
    c = float(""inf"")
    b = a[n]
    for i in range(n + 1):
        d = a[i]
        for j in range(n + 1 - i):
            e = b - a[n - j]
            f = d + e
            g = n - i - j
            h = b - f
            k = g - h
            c = min(c, max(k, f))
    print(c)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053930
1390053932,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <deque>
using namespace std;
void findeqfault(vector<int>& arr, int k) {
    deque<int> dq;
    int n = arr.size();
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0)
            dq.push_back(i);
    }
    for (int i = k; i <= n; i++) {
        if (!dq.empty())
            cout << arr[dq.front()] << "" "";
        else
            cout << ""0 "";
        while (!dq.empty() && dq.front() <= i - k)
            dq.pop_front();
        if (i < n && arr[i] < 0)
            dq.push_back(i);
    }
    cout << endl;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        findeqfault(arr, k);
    }
    return 0;
}",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053932
1390053919,unknown,unknown,unknown,"def min_cost_to_decommission(rack):
    length = len(rack)
    min_cost = float('inf')
    for prefix in range(length + 1):
        for suffix in range(length + 1 - prefix):
            if prefix + suffix > length:
                continue
            remaining = rack[prefix:length - suffix]
            if not remaining:
                continue
            idle_count = remaining.count('0')
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
            cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
cases = int(input())
results = []
for _ in range(cases):
    rack = input().strip()
    results.append(min_cost_to_decommission(rack))
for res in results:
    print(res)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053919
1390053925,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    if k >= n:  
        print(0)
        continue
    min_effort = sum(firewalls)  
    for i in range(n - k + 1):  
        effort = 0
        skipped = 0
        for j in range(n):
            if i <= j < i + k: 
                skipped += 1
                continue
            effort += firewalls[j] + skipped  
        min_effort = min(min_effort, effort)  
    print(min_effort)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053925
1390053926,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053926
1390053912,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;
int minEffortToBreach(int n, int k, vector<int>& strengths) {
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));
    // Base case: No firewalls, no effort
    for (int j = 0; j <= k; ++j) {
        dp[0][j] = 0;
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= k; ++j) {
            // Option 1: Skip current firewall (if skips are available)
            if (j > 0) {
                dp[i][j] = dp[i - 1][j - 1];
            }
            // Option 2: Don't skip current firewall
            int currentStrength = strengths[i - 1] + j; // Strength increases due to previous skips
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + currentStrength);
        }
    }
    // Return minimum effort among all possible ways to use up to k skips
    return *min_element(dp[n].begin(), dp[n].end());
}
void solve() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> strengths(n);
        for (int i = 0; i < n; ++i) {
            cin >> strengths[i];
        }
        cout << minEffortToBreach(n, k, strengths) << endl;
    }
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    solve();
    return 0;
}",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053912
1390053914,unknown,unknown,unknown,"def min_effort(T, test_cases):
    results = []
    for n, k, strengths in test_cases:
        if k == n:
            results.append(""0"")
            continue
        total_effort = sum(strengths)  
        min_effort = total_effort 
        for i in range(n):  
            skipped_effort = total_effort - strengths[i] + 1  
            min_effort = min(min_effort, skipped_effort)
        results.append(str(min_effort))
    print(""\n"".join(results))
T = int(input().strip())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    test_cases.append((n, k, strengths))
min_effort(T, test_cases)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053914
1390053913,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        queue = deque()
        result = []
        for i in range(n):
            # Add current element to the queue if it's faulty
            if arr[i] < 0:
                queue.append(arr[i])
            # Remove elements out of the current batch from the queue
            if i >= k and arr[i - k] < 0:
                queue.popleft()
            # Add the earliest fault in the current batch to the result
            if i >= k - 1:
                if queue:
                    result.append(queue[0])
                else:
                    result.append(0)
        results.append(result)
    return results
# Input Reading
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Output
output = earliest_faulty_readings(test_cases)
for res in output:
    print(*res)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053913
1390053910,unknown,unknown,unknown,"# Read number of test cases
t = int(input().strip())
for _ in range(t):
    servers = input().strip()
    n = len(servers)
    # Count total active and idle
    total_active = servers.count('1')
    total_idle = servers.count('0')
    min_cost = min(total_active, total_idle)  # Initialize with removing all active or all idle
    # Calculate prefix arrays
    active_prefix = [0]
    idle_prefix = [0]
    for server in servers:
        active_prefix.append(active_prefix[-1] + (1 if server == '1' else 0))
        idle_prefix.append(idle_prefix[-1] + (1 if server == '0' else 0))
    # Try all possible middle segments efficiently
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Calculate active servers removed
            active_removed = active_prefix[left] + (total_active - active_prefix[right])
            # Calculate idle servers remaining
            idle_remaining = idle_prefix[right] - idle_prefix[left]
            # Update minimum cost
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053910
1390053907,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process rest of the array
    for i in range(k, len(arr) + 1):
        # Append the earliest faulty reading
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements not in the window
        if dq and dq[0] == i - k:
            dq.popleft()
        # Add the next element if it is faulty
        if i < len(arr) and arr[i] < 0:
            dq.append(i)
    return result
def process_test_cases(test_cases):
    results = []
    for n, k, arr in test_cases:
        results.append("" "".join(map(str, earliest_faults(arr, k))))
    return ""\n"".join(results)
# Example test cases for debugging
test_cases = [
    (5, 2, [-8, 2, 3, -6, 10]),
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
]
# Running test cases
print(process_test_cases(test_cases))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053907
1390053908,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053908
1390053909,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_count = 0
            for char in remaining:
                if char == '0':
                    idle_count += 1
            removed_count = 0
            for char in s[:i]:
                if char == '1':
                    removed_count += 1
            for char in s[n-j:]:
                if char == '1':
                    removed_count += 1
            cost = max(idle_count, removed_count)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053909
1390053901,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
   public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        for (int tc = 0; tc < t; tc++) {
            int n = scanner.nextInt(); // Size of array
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int fault : result) {
                System.out.print(fault + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i <= arr.length - k; i++) {
            int earliestFault = 0; // when no faults
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    earliestFault = arr[j];
                    break; 
                }
            }
            result.add(earliestFault);
        }
        return result;
    }
}",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053901
1390053902,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_eff= float('inf')
    for i in range(1 << n):
        skip = []
        effort = 0
        current_a = a[:] 
        skip_count = 0
        for j in range(n):
            if (i >> j) & 1:
                skip.append(j)
                skip_count += 1
        if skip_count <= k:
            skip.sort()
            skip_index = 0
            for j in range(n):
                if skip_index < len(skip) and skip[skip_index] == j:
                  for index in range(j+1,n):
                    current_a[index] +=1
                  skip_index += 1
                else:
                    effort += current_a[j]
            min_eff = min(min_eff, effort)
    print(min_eff)
t = int(input())
for _ in range(t):
    solve()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053902
1390053904,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first k elements
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    # Compute and print results
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053904
1390053897,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    total_active = server_rack.count('1')
    total_idle = server_rack.count('0')
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
    left, right = 0, len(server_rack) - 1
    removed_active = 0
    removed_idle = 0
    # Try decommissioning from both ends
    while left <= right:
        if server_rack[left] == '0':
            removed_idle += 1
            left += 1
        elif server_rack[right] == '0':
            removed_idle += 1
            right -= 1
        elif server_rack[left] == '1':
            removed_active += 1
            left += 1
        elif server_rack[right] == '1':
            removed_active += 1
            right -= 1
        remaining_idle = total_idle - removed_idle
        min_cost = min(min_cost, max(remaining_idle, removed_active))
    return min_cost
# Read input
T = int(input())  # Number of test cases
results = []
for _ in range(T):
    server_rack = input().strip()
    results.append(min_decommission_cost(server_rack))
# Print results
for res in results:
    print(res)",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053897
1390053899,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while(T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }
            if(k >= n) {
                System.out.println(0);
                continue;
            }
            long INF = Long.MAX_VALUE / 2;
            long[] dp = new long[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;
            for (int i = 0; i < n; i++) {
                int lim = Math.min(i+1, k); 
                long[] newdp = new long[k+1];
                Arrays.fill(newdp, INF);
                .
                for (int j = lim; j >= 0; j--) {
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
                    if(j < k) {
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
                    }
                }
                dp = newdp;
            }
            long ans = INF;
            for (int j = 0; j <= k; j++) {
                ans = Math.min(ans, dp[j]);
            }
            System.out.println(ans);
        }
        sc.close();
    }
}",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053899
1390053898,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    # Special case: If we can skip all firewalls, the effort is 0
    if k >= n:
        return 0
    # Try all possible combinations of skipping 0 to k firewalls
    firewalls_sorted = sorted(firewalls)  # Sort to prioritize skipping stronger firewalls
    min_effort = float('inf')
    # Try skipping 0 to k firewalls
    for skipped in range(k + 1):
        # Skip the strongest firewalls
        remaining = firewalls_sorted[:n-skipped]
        # Calculate the total effort with penalty
        effort = sum(remaining) + skipped
        min_effort = min(min_effort, effort)
    return min_effort
# Read input
t = int(input().strip())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053898
1390053896,unknown,unknown,unknown,"def minimum_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        if k >= n:
            results.append(0)
            continue
        total = sum(a)
        # Create list of (a[i] + i, i, a[i])
        candidates = [(a[i] + i, i, a[i]) for i in range(n)]
        # Sort candidates in descending order of (a[i] + i)
        candidates.sort(reverse=True, key=lambda x: x[0])
        # Select top k candidates
        selected = candidates[:k]
        # Sort selected by their i in ascending order
        selected.sort(key=lambda x: x[1])
        sum_skipped = sum(x[2] for x in selected)
        added = 0
        for j in range(k):
            i = selected[j][1]
            # Number of non-skipped firewalls after i
            non_skipped_after = (n - i - 1) - (k - j - 1)
            added += non_skipped_after
        min_effort = total - sum_skipped + added
        results.append(min_effort)
    return results
def main():
    import sys
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    test_cases = []
    for _ in range(T):
        n = int(input[idx])
        k = int(input[idx+1])
        idx += 2
        a = list(map(int, input[idx:idx+n]))
        idx += n
        test_cases.append((n, k, a))
    res = minimum_effort(test_cases)
    for r in res:
        print(r)
if __name__ == ""__main__"":
    main()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053896
1390053889,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053889
1390053893,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    total_effort = sum(strengths)
    if k == n:
        return 0  # If we can skip all firewalls, minimum effort is 0
    # Finding the minimum effort by skipping one firewall
    min_effort = min(total_effort - strength for strength in strengths)
    return min_effort
# Read input
T = int(input())  
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort(n, k, strengths))",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053893
1390053888,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053888
1390053883,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053883
1390053885,unknown,unknown,unknown,"t=int(input())
for _ in range(t):
    n,k=list(map(int,input().split()))
    arr=list(map(int,input().split()))
    dp=[[float('inf')]*(k+1) for _ in range(n+1)]
    for j in range(k+1):dp[0][j]=0
    for i in range(1,n+1):
        for j in range(k+1):
            if j:dp[i][j]=min(dp[i][j],dp[i-1][j-1])
            dp[i][j]=min(dp[i][j],dp[i-1][j]+arr[i-1]+(j*1))
    print(min(dp[n]))",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053885
1390053887,unknown,unknown,unknown,"from collections import deque
def earliest_faults_in_batches(test_cases):
    results = []
    for n, k, arr in test_cases:
        faults = []
        dq = deque()
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        faults.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            if dq and dq[0] <= i - k:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            faults.append(arr[dq[0]] if dq else 0)
        results.append(faults)
    return results
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
for result in earliest_faults_in_batches(test_cases):
    print(*result)",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053887
1390053881,unknown,unknown,unknown,"import java.util.*;
public class FirewallMinEffort {
    public static long minimizeEffort(int n, int k, int[] firewalls) {
        long totalEffort = 0;
        // Create a list of pairs (value + index, index)
        List<int[]> skipValue = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            skipValue.add(new int[]{firewalls[i] + i, i});
        }
        // Sort by descending benefit to skip
        skipValue.sort((a, b) -> Integer.compare(b[0], a[0]));
        // Mark which firewalls to skip
        boolean[] skipped = new boolean[n];
        for (int i = 0; i < k; i++) {
            skipped[skipValue.get(i)[1]] = true;
        }
        // Calculate final effort
        long effort = 0;
        int penalty = 0;
        for (int i = 0; i < n; i++) {
            if (skipped[i]) {
                penalty++;
            } else {
                effort += firewalls[i] + penalty;
            }
        }
        return effort;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minimizeEffort(n, k, firewalls));
        }
        sc.close();
    }
}",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053881
1390053880,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053880
1390053882,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053882
1390053879,unknown,unknown,unknown,"import itertools
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for num_skips in range(k + 1):
        indices_to_skip_combinations = itertools.combinations(range(n), num_skips)
        for skip_indices_tuple in indices_to_skip_combinations:
            skip_indices = set(skip_indices_tuple)
            current_effort = 0
            for i in range(n):
                if i not in skip_indices:
                    strength_increase = 0
                    for skipped_index in skip_indices:
                        if skipped_index < i:
                            strength_increase += 1
                    current_effort += a[i] + strength_increase
            min_effort = min(min_effort, current_effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053879
1390053874,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = []
        efforts = []
        for j in range(n):
            if (i >> j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped) <= k:
            current_effort = 0
            skipped_count = 0
            for j in range(n):
                if j in skipped:
                    skipped_count += 1
                else:
                    current_effort += a[j] + skipped_count
            min_effort = min(min_effort, current_effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053874
1390053875,unknown,unknown,unknown,"import bisect
t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    if n == 0:
        print(0)
        continue
    if s == ""0"" or s == ""1"":
        print(0)
        continue
    if s == ""00"" or s == ""11"":
        print(1)
        continue
    prefix_0 = [0] * (n + 1)
    prefix_1 = [0] * (n + 1)
    for i in range(n):
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]
    low, high = 0, n
    while low < high:
        m = (low + high) // 2
        possible = False
        for j in range(n + 1):
            target = prefix_0[j] - m
            i = bisect.bisect_left(prefix_0, target)
            if i <= j:
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
                if ones_removed <= m:
                    possible = True
                    break
        if possible:
            high = m
        else:
            low = m + 1
    print(low)",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053875
1390053877,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            String s = sc.next(); 
            System.out.println(minDecommissionCost(s));
        }
        sc.close();
    }
    private static int minDecommissionCost(String s) {
        int n = s.length();
        int totalOnes = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1') totalOnes++;
        }
        int minCost = Integer.MAX_VALUE;
        for (int i = 0; i <= n; i++) {
            int prefixOnes = 0;
            for (int j = 0; j < i; j++) {
                if (s.charAt(j) == '1') prefixOnes++;
            }
            for (int j = 0; j <= n - i; j++) {
                int suffixOnes = 0;
                for (int k = n - j; k < n; k++) {
                    if (s.charAt(k) == '1') suffixOnes++;
                }
                int keptOnes = totalOnes - prefixOnes - suffixOnes;
                int keptLength = n - i - j;
                int keptZeros = keptLength - keptOnes;
                int removedOnes = prefixOnes + suffixOnes;
                int cost = Math.max(keptZeros, removedOnes);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053877
1390053867,unknown,unknown,unknown,"def minimize_effort():
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    # Calculate the initial total effort
    total_effort = sum(strengths)
    # Compute the penalty for skipping each firewall
    skip_penalty = [strengths[i] - (n - i - 1) for i in range(n)]
    # Sort in descending order to prioritize the most beneficial skips
    skip_penalty.sort(reverse=True)
    # Reduce effort by skipping up to k firewalls
    total_effort -= sum(skip_penalty[:k])
    # Account for the incremental difficulty of later firewalls
    total_effort -= k * (k - 1) // 2
    # Print the minimized effort
    print(total_effort)
if __name__ == ""__main__"":
    test_cases = int(input())
    for _ in range(test_cases):
        minimize_effort()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053867
1390053872,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # Get indices of active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # Define the check function
        def check(X):
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                while j < m and A[j] - A[i] <= X:
                    j += 1
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == ""__main__"":
    solve()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053872
1390053870,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerPruning {
    public static int minPruningCost(String serverRack) {
        int n = serverRack.length();
        int left = 0, right = n - 1;
        // Remove leading idle servers (0s)
        while (left <= right && serverRack.charAt(left) == '0') {
            left++;
        }
        // Remove trailing idle servers (0s)
        while (right >= left && serverRack.charAt(right) == '0') {
            right--;
        }
        // If no active servers remain
        if (left > right) return 0;
        // Count remaining idle servers
        int idleCount = 0;
        for (int i = left; i <= right; i++) {
            if (serverRack.charAt(i) == '0') {
                idleCount++;
            }
        }
        // Active servers removed
        int activeRemoved = left + (n - 1 - right);
        return Math.max(idleCount, activeRemoved);
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = Integer.parseInt(sc.nextLine().trim());
        while (T-- > 0) {
            String serverRack = sc.nextLine().trim();
            System.out.println(minPruningCost(serverRack));
        }
        sc.close();
    }
}",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053870
1390053860,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        sc.nextLine(); 
        while (T-- > 0) {
            String s = sc.nextLine().trim();
            int n = s.length();
            int totalOnes = 0;
            int maxConsecutiveOnes = 0;
            int currentConsecutiveOnes = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') {
                    currentConsecutiveOnes++;
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
                    totalOnes++;
                } else {
                    currentConsecutiveOnes = 0;
                }
            }
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            if (maxConsecutiveOnes == totalOnes) {
                System.out.println(0);
                continue;
            }
            int totalZeros = n - totalOnes;
            int low = 0;
            int high = Math.max(totalOnes, totalZeros);
            int answer = high;
            while (low <= high) {
                int mid = (low + high) / 2;
                int requiredOnes = Math.max(0, totalOnes - mid);
                if (requiredOnes == 0) {
                    answer = mid;
                    high = mid - 1;
                    continue;
                }
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
                if (maxOnes >= requiredOnes) {
                    answer = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            System.out.println(answer);
        }
        sc.close();
    }
    private static int maxOnesWithAtMostKZeros(String s, int k) {
        int left = 0;
        int zeros = 0;
        int maxOnes = 0;
        int n = s.length();
        for (int right = 0; right < n; right++) {
            if (s.charAt(right) == '0') {
                zeros++;
            }
            while (zeros > k) {
                if (s.charAt(left) == '0') {
                    zeros--;
                }
                left++;
            }
            int currentOnes = (right - left + 1) - zeros;
            maxOnes = Math.max(maxOnes, currentOnes);
        }
        return maxOnes;
    }
}",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053860
1390053861,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    if k >= n:
        return 0
    return min(sum(firewalls[:i] + firewalls[i + k:]) + sum(range(1, k + 1)) * (n - i - k) for i in range(n - k + 1))
# Test cases
for _ in range(int(input())):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053861
1390053866,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053866
1390053859,unknown,unknown,unknown,"def optimize_server_decommissioning(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for start in range(n + 1):
        for end in range(n + 1):
            if start + end <= n:
                remaining = server_rack[start:n-end]
                idle_remaining = remaining.count('0')
                active_removed = 0
                for i in range(start):
                    if server_rack[i] == '1':
                        active_removed += 1
                for i in range(n-end, n):
                    if server_rack[i] == '1':
                        active_removed += 1
                cost = max(idle_remaining, active_removed)
                min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input())
    for _ in range(t):
        server_rack = input().strip()
        result = optimize_server_decommissioning(server_rack)
        print(result)
if __name__ == ""__main__"":
    main()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053859
1390053857,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053857
1390053858,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053858
1390053856,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053856
1390053849,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    # Precompute cumulative counts of '1's from the beginning
    cumulative_ones = [0] * (n + 1)
    for i in range(n):
        cumulative_ones[i + 1] = cumulative_ones[i] + (1 if s[i] == '1' else 0)
    for i in range(n + 1):
        for j in range(i, n + 1):
            zeros_remaining = 0
            for k in range(i, j):
                if s[k] == '0':
                    zeros_remaining += 1
            ones_removed = cumulative_ones[i] + (cumulative_ones[n] - cumulative_ones[j])
            ans = min(ans, max(zeros_remaining, ones_removed))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053849
1390053850,unknown,unknown,unknown,"def minimize_effort(n, k, a):
    total_effort = sum(a)  # initial total effort without skipping
    benefits = []
    # Calculate the benefit of skipping each firewall:
    # benefit = a[i] - (n - i - 1)
    for i in range(n):
        benefit = a[i] - (n - i - 1)
        benefits.append(benefit)
    # Sort benefits in descending order to pick best k skips
    benefits.sort(reverse=True)
    # Reduce the effort by skipping the firewalls with highest benefits
    for i in range(k):
        total_effort -= benefits[i]
    # Add the penalty: skipping k firewalls increases strength of remaining by 1, 2, ..., k
    # The total penalty is the sum of first k natural numbers: k * (k - 1) // 2
    penalty = k * (k - 1) // 2
    total_effort += penalty
    return total_effort
# Driver code to handle multiple test cases
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    result = minimize_effort(n, k, a)
    print(result)",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053850
1390053852,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053852
1390053846,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053846
1390053847,unknown,unknown,unknown,"# Read number of test cases
t = int(input().strip())
for _ in range(t):
    # Read server string
    servers = input().strip()
    n = len(servers)
    # Precompute prefix and suffix sums
    prefix_active = [0] * (n + 1)  # active[0:i]
    prefix_idle = [0] * (n + 1)    # idle[0:i]
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = n  # Initialize with worst case
    # For each possible left cut point
    for left in range(n + 1):
        # Calculate active servers removed from left
        active_removed_left = prefix_active[left]
        # Find the optimal right cut point for this left cut
        # Key insight: As we move the right boundary left, we:
        # 1. Remove more active servers from the right
        # 2. Reduce the number of idle servers remaining
        # Binary search to find optimal right point would be ideal,
        # but we can solve this in O(n) by checking each right point
        for right in range(n, left - 1, -1):
            active_removed_right = total_active - prefix_active[right]
            active_removed_total = active_removed_left + active_removed_right
            idle_remaining = prefix_idle[right] - prefix_idle[left]
            cost = max(idle_remaining, active_removed_total)
            min_cost = min(min_cost, cost)
            # Important optimization: If removing more from right increases cost,
            # no need to continue checking more right cuts for this left cut
            if active_removed_right >= idle_remaining:
                break
    print(min_cost)",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053847
1390053848,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        # Compute a[i] + i (0-based)
        values = [a[i] + i for i in range(n)]
        # Sort in descending order
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        # Compute the result
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
main()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053848
1390053843,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    skipped = [False] * n
    temp_a = a[:]
    for _ in range(k):
        max_val = -1
        max_idx = -1
        for i in range(n):
            if not skipped[i] and temp_a[i] > max_val:
                max_val = temp_a[i]
                max_idx = i
        if max_idx != -1:
            skipped[max_idx] = True
            temp_a[max_idx] = -1
    if k == n:
        print(0)
        return
    effort = 0
    skipped_count = 0
    for i in range(n):
        if skipped[i]:
            skipped_count += 1
        else:
            effort += a[i] + skipped_count
    print(effort)
t = int(input())
for _ in range(t):
    solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053843
1390053837,unknown,unknown,unknown,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            String serverRack = br.readLine().trim();
            pw.println(minPruningCost(serverRack));
        }
        pw.close();
        br.close();
    }
    public static int minPruningCost(String serverRack) {
        int n = serverRack.length();
        int minCost = n + 1; // Initialize with a value larger than any possible cost
        for (int leftRemoveCount = 0; leftRemoveCount <= n; ++leftRemoveCount) {
            for (int rightRemoveCount = 0; rightRemoveCount <= n - leftRemoveCount; ++rightRemoveCount) {
                int idleRemaining = 0;
                int activeRemoved = 0;
                // Calculate activeRemoved servers
                for (int i = 0; i < leftRemoveCount; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        activeRemoved++;
                    }
                }
                for (int i = n - rightRemoveCount; i < n; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        activeRemoved++;
                    }
                }
                // Calculate idleRemaining servers
                for (int i = leftRemoveCount; i < n - rightRemoveCount; ++i) {
                    if (serverRack.charAt(i) == '0') {
                        idleRemaining++;
                    }
                }
                int cost = Math.max(idleRemaining, activeRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
}",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053837
1390053839,unknown,unknown,unknown,"def bf(arr, k):
    if k==0:
        return sum(arr)
    elif k >= len(arr):
        return 0
    else:
        arr.sort(reverse=True)
        return sum(arr[k:])+1
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(bf(arr, k))",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053839
1390053842,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
     public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int testCases = input.nextInt();
        while (testCases-- > 0) {
            int size = input.nextInt();
            int limit = input.nextInt();
            int[] elements = new int[size];
            long totalSum = 0;
            for (int i = 0; i < size; i++) {
                elements[i] = input.nextInt();
                totalSum += elements[i];
            }
            List<Long> adjustedValues = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                long value = elements[i] - (size - i - 1L);
                adjustedValues.add(value);
            }
            adjustedValues.sort((a, b) -> Long.compare(b, a));
            long[] prefixSum = new long[size + 1];
            for (int i = 1; i <= size; i++) {
                prefixSum[i] = prefixSum[i - 1] + adjustedValues.get(i - 1);
            }
            int maxOperations = Math.min(limit, size);
            long highestSum = Long.MIN_VALUE;
            for (int ops = 0; ops <= maxOperations; ops++) {
                long currentSum = prefixSum[ops] + ((long) ops * (ops - 1)) / 2;
                if (currentSum > highestSum) {
                    highestSum = currentSum;
                }
            }
            long minEffort = totalSum - highestSum;
            System.out.println(minEffort);
        }
        input.close();
    }
}",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053842
1390053833,unknown,unknown,unknown,"def min_decommissioning_cost(t, test_cases):
    results = []
    for s in test_cases:
        # Find the first and last occurrence of '1'
        first_one = s.find('1')
        last_one = s.rfind('1')
        # If there are no '1's, we can remove everything
        if first_one == -1:
            results.append(0)
            continue
        # Extract the relevant portion of the string
        trimmed = s[first_one:last_one+1]
        # Count remaining idle (0's) and removed active (1's)
        idle_remaining = trimmed.count('0')
        active_removed = first_one + (len(s) - 1 - last_one)
        # Compute minimum cost
        results.append(max(idle_remaining, active_removed))
    return results
# Read input
t = int(input().strip())
test_cases = [input().strip() for _ in range(t)]
# Compute and print results
for res in min_decommissioning_cost(t, test_cases):
    print(res)",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053833
1390053835,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053835
1390053834,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_count = remaining.count('0')
            removed_count = s[:i].count('1') + s[n-j:].count('1')
            cost = max(idle_count, removed_count)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053834
1390053827,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053827
1390053829,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    skip_value = []
    for i in range(n):
        skip_value.append((firewalls[i] + i, i))
    skip_value.sort(reverse=True)
    skipped = [0] * n
    for i in range(k):
        _, idx = skip_value[i]
        skipped[idx] = 1
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053829
1390053832,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053832
1390053826,unknown,unknown,unknown,"def min_decommission_cost(T, test_cases):
    results = []
    for binary_string in test_cases:
        # Find the first and last occurrence of '1'
        first_one = binary_string.find('1')
        last_one = binary_string.rfind('1')
        if first_one == -1:  # No '1's in the string (only idle servers)
            results.append(""0"")
            continue
        # Extract the core section between the first and last '1'
        trimmed_section = binary_string[first_one:last_one + 1]
        # Count idle servers (0s) left inside the active range
        idle_servers_left = trimmed_section.count('0')
        # Count active servers (1s) removed before first and after last '1'
        active_servers_removed = binary_string[:first_one].count('1') + binary_string[last_one + 1:].count('1')
        # The final cost is max(idle servers left, active servers removed)
        results.append(str(max(idle_servers_left, active_servers_removed)))
    print(""\n"".join(results))
# Read input
T = int(input().strip())  # Number of test cases
test_cases = [input().strip() for _ in range(T)]  # Read all test cases
# Run the function
min_decommission_cost(T, test_cases)",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053826
1390053822,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053822
1390053824,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053824
1390053825,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053825
1390053814,unknown,unknown,unknown,"import java.util.*;
public class FirewallMinEffort {
    public static long minimizeEffort(int n, int k, int[] firewalls) {
        long totalEffort = 0;
        // Create a list of pairs (value + index, index)
        List<int[]> skipValue = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            skipValue.add(new int[]{firewalls[i] + i, i});
        }
        // Sort by descending benefit to skip
        skipValue.sort((a, b) -> Integer.compare(b[0], a[0]));
        // Mark which firewalls to skip
        boolean[] skipped = new boolean[n];
        for (int i = 0; i < k; i++) {
            skipped[skipValue.get(i)[1]] = true;
        }
        // Calculate final effort
        long effort = 0;
        int penalty = 0;
        for (int i = 0; i < n; i++) {
            if (skipped[i]) {
                penalty++;
            } else {
                effort += firewalls[i] + penalty;
            }
        }
        return effort;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minimizeEffort(n, k, firewalls));
        }
        sc.close();
    }
}",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053814
1390053816,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if _name_ == '_main_':
    solve()",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053816
1390053815,unknown,unknown,unknown,"def min_decommission_cost(s):
    n = len(s)
    start, end = 0, n - 1
    while start < n and s[start] == '0':
        start += 1
    while end >= 0 and s[end] == '0':
        end -= 1
    if start > end:
        return 0
    trimmed = s[start:end+1]
    remaining_idle = trimmed.count('0')
    min_cost = remaining_idle
    ones_removed = 0
    for i in range(start, end + 1):
        if s[i] == '1':
            ones_removed += 1
        else:
            remaining_idle -= 1
        cost = max(remaining_idle, ones_removed)
        min_cost = min(min_cost, cost)
    return min_cost
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_decommission_cost(s))",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053815
1390053810,unknown,unknown,unknown,"def minimum_decommission_cost(server_rack):
    n = len(server_rack)
    total_ones = server_rack.count('1')
    minimum_cost = float('inf')
    prefix_ones = [0] * (n + 1)
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
    for left in range(n + 1):
        for right in range(left, n + 1):
            ones_in_substring = prefix_ones[right] - prefix_ones[left]
            zeros_in_substring = prefix_zeros[right] - prefix_zeros[left]
            ones_removed = total_ones - ones_in_substring
            cost = max(zeros_in_substring, ones_removed)
            if cost < minimum_cost:
                minimum_cost = cost
    return minimum_cost
T = int(input())
for _ in range(T):
    server_rack = input().strip()
    print(minimum_decommission_cost(server_rack))",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053810
1390053811,unknown,unknown,unknown,"#include <iostream>
#include <vector>
using namespace std;
vector<int> findEarliestFaultyReadings(const vector<int>& arr, int k) {
    vector<int> result;
    int n = arr.size();
    for (int i = 0; i <= n - k; ++i) {
        bool foundFault = false;
        for (int j = i; j < i + k; ++j) {
            if (arr[j] < 0) {
                result.push_back(arr[j]);
                foundFault = true;
                break;
            }
        }
        if (!foundFault) {
            result.push_back(0);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; ++i) {
            cin >> arr[i];
        }
        vector<int> result = findEarliestFaultyReadings(arr, k);
        for (int val : result) {
            cout << val << "" "";
        }
        cout << endl;
    }
    return 0;
}",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053811
1390053813,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    a = [0] * (n + 1)
    for i in range(n):
        a[i + 1] = a[i] + (1 if s[i] == ""1"" else 0)
    c = float(""inf"")
    for i in range(n + 1):
        b = a[i]
        l, r = 0, n - i
        while l <= r:
            j = (l + r) // 2
            x = n - i - j
            y = a[n] - a[i] - (a[n] - a[n - j])
            z = x - y
            d = b + (a[n] - a[n - j])
            e = max(z, d)
            c = min(c, e)
            if z > d:
                l = j + 1
            else:
                r = j - 1
    print(c)",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053813
1390053809,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input()) 
    for _ in range(t):
        n, k = map(int, input().split())  
        arr = list(map(int, input().split()))
        output = earliest_faulty_readings(arr, k)
        print("" "".join(map(str, output)))
if __name__ == ""__main__"":
    main()",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053809
1390053801,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    if k >= n:
        return 0
    min_effort = sum(firewalls)
    for i in range(n):
        temp_firewalls = firewalls[:]
        temp_firewalls[i] = 0
        for j in range(i + 1, n):
            temp_firewalls[j] += 1
        min_effort = min(min_effort, sum(temp_firewalls))
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053801
1390053806,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053806
1390053808,unknown,unknown,unknown,"import java.util.*;
public class FirewallEffort {
    public static int findMinimumEffort(int[] arr, int k) {
        int totalEffort = Arrays.stream(arr).sum();
        int minEffort = totalEffort;
        int windowSum = 0;
        for (int i = 0; i < k; i++) {
            windowSum += arr[i];
        }
        minEffort = Math.min(minEffort, totalEffort - windowSum);
        for (int i = k; i < arr.length; i++) {
            windowSum += arr[i] - arr[i - k];
            minEffort = Math.min(minEffort, totalEffort - windowSum);
        }
        return minEffort;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            System.out.println(findMinimumEffort(arr, k));
        }
        scanner.close();
    }
}",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053808
1390053800,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> ans = findResult(arr, k);
            for (int num : ans) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
    public static List<Integer> findResult(int []arr, int k){
        List<Integer> ans = new ArrayList<Integer>();
        Deque<Integer> deque = new LinkedList<>();
        for(int i =0;i<k;i++){
            if(arr[i]<0){
            deque.addLast(i);
            }
        }
        if(!deque.isEmpty()){
            ans.add(arr[deque.peekFirst()]);
        }else{
            ans.add(0);
        }
        for(int i=k;i<arr.length;i++){
            if(!deque.isEmpty()&&deque.peekFirst()<=i-k){
                deque.pollFirst();
            }
            if(arr[i]<0){
            deque.addLast(i);
            }
            if(!deque.isEmpty()){
                ans.add(arr[deque.peekFirst()]);
            }else{
                ans.add(0);
            }
        }
        return ans;
    }
}",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053800
1390053790,unknown,unknown,unknown,"def f(a, k):
    r = []
    n = len(a)
    for i in range(n - k + 1):
        b = a[i:i + k]
        f = next((x for x in b if x < 0), 0)  # Pick first negative, else 0
        r.append(f)
    return r
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    print(*f(a, k))",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053790
1390053791,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053791
1390053794,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053794
1390053789,unknown,unknown,unknown,"import bisect
t = int(input())
for _ in range(t):
    s = input().strip()
    n = len(s)
    prefix_0 = [0] * (n + 1)  
    prefix_1 = [0] * (n + 1)  
    for i in range(n):
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]  
    low, high = 0, n
    while low < high:
        m = (low + high) // 2  
        possible = False
        for j in range(n + 1):
            target = prefix_0[j] - m
            i = bisect.bisect_left(prefix_0, target)
            if i <= j:
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
                if ones_removed <= m:
                    possible = True
                    break
        if possible:
            high = m  
        else:
            low = m + 1 
    print(low)",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053789
1390053779,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls using exactly j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    # Calculate strength increments for each position based on previous skips
    for i in range(1, n + 1):
        for j in range(k + 1):
            # If we can skip this firewall
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
            # If we don't skip this firewall
            if j <= k:  # We've used j skips so far
                # The strength increases by the number of previous skips
                current_strength = strengths[i-1]
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
    # Find minimum effort among all possible numbers of skips
    return min(dp[n])
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, strengths))",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053779
1390053784,unknown,unknown,unknown,"cases = int(input())
for t in range(cases):
    n,k = [int(i) for i in input().split()]
    array = [int(i) for i in input().split()]
    if n == k:
        print(0)
        continue
    batch_sum = [0]*n
    for i in range(n):
        batch_sum[i] = sum(array[i:i+k])
    total = sum(array)
    best = total
    for i in range(n):
        best = min(best, total -batch_sum[i] + n-i-1)
    print(best)
    ",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053784
1390053780,unknown,unknown,unknown,"def min_server_decommission_cost(binary_str):
    # Step 1: Trim leading and trailing '0's
    trimmed_str = binary_str.strip('0')
    # If there are no '1's left after trimming, cost is 0
    if '1' not in trimmed_str:
        return 0
    # Step 2: Count remaining '0's in between
    idle_servers_left = trimmed_str.count('0')
    # Step 3: Try removing active servers ('1's) optimally
    active_servers_removed = binary_str.count('1') - trimmed_str.count('1')
    # Step 4: Compute minimum possible cost
    return max(idle_servers_left, active_servers_removed)
# Read input
t = int(input().strip())  # Number of test cases
for _ in range(t):
    binary_str = input().strip()
    print(min_server_decommission_cost(binary_str))",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053780
1390053775,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053775
1390053777,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053777
1390053778,unknown,unknown,unknown,"def minimum_effort(test_cases, data):
    results = []
    for case in range(test_cases):
        n, k = data[case][0]
        firewalls = data[case][1]
        total_effort = sum(firewalls)
        if k == n:
            results.append(""0"")
            continue
        min_effort = total_effort
        for i in range(n):
            skipped_effort = total_effort - firewalls[i] + (n - 1) * 1
            min_effort = min(min_effort, skipped_effort)
        results.append(str(min_effort))
    return ""\n"".join(results)
# Reading input
t = int(input())
data = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    data.append(((n, k), firewalls))
# Processing and printing output
print(minimum_effort(t, data))",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053778
1390053767,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    dp = [float('inf')] * (k + 1)
    dp[0] = 0
    for i in range(1, n + 1):
        for j in range(min(k, i), -1, -1):
            if j <= i - 1:
                dp[j] = min(dp[j], dp[j] + strengths[i - 1] + j)
            if j > 0:
                dp[j] = min(dp[j], dp[j - 1])
    return dp[k]
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        if k >= n:
            print(0)
        else:
            print(min_effort_to_breach(n, k, strengths))
solve()",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053767
1390053772,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]  # Read n and k
        firewalls = test_cases[t][1]  # Read firewall strengths
        # Sort firewalls based on strength, keeping track of original indices
        sorted_indices = sorted(range(n), key=lambda i: -firewalls[i])
        # Mark `k` strongest firewalls as skipped
        skipped = set(sorted_indices[:k])
        total_effort = 0
        increment = 0  # Tracks how many times subsequent firewalls increase
        for i in range(n):
            if i in skipped:
                increment += 1  # Since we skipped this firewall, increase effect on next
            else:
                total_effort += firewalls[i] + increment  # Add effort with increments
        results.append(total_effort)
    return results
# Reading input
T = int(input().strip())  
test_cases = []
for _ in range(T):
    n, k = map(int, input().strip().split())  
    firewalls = list(map(int, input().strip().split()))  
    test_cases.append(((n, k), firewalls))
# Get results
output = min_effort_to_breach(T, test_cases)
# Print results
for res in output:
    print(res)",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053772
1390053774,unknown,unknown,unknown,"import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt(); 
        while (T-- > 0) {
            String rack = sc.next();  // Binary string representing server rack
            int n = rack.length();
            int[] servers = new int[n];
            for (int i = 0; i < n; i++) {
                servers[i] = rack.charAt(i) - '0';  // Convert string to int array
            }
            int minCost = n;  // Maximum possible cost is n (if no decommissioning)
            // Try all possible left and right cuts
            for (int left = 0; left <= n; left++) {
                for (int right = 0; left + right <= n; right++) {
                    int remainingIdle = 0;
                    int decommissionedActive = 0;
                    // Count remaining idle servers and decommissioned active servers
                    for (int i = left; i < n - right; i++) {
                        if (servers[i] == 0) remainingIdle++;
                    }
                    for (int i = 0; i < left; i++) {
                        if (servers[i] == 1) decommissionedActive++;
                    }
                    for (int i = n - right; i < n; i++) {
                        if (servers[i] == 1) decommissionedActive++;
                    }
                    // Cost is maximum of remaining idle and decommissioned active
                    int cost = Math.max(remainingIdle, decommissionedActive);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053774
1390053766,unknown,unknown,unknown,"def solve():
    import sys
    input_data = sys.stdin.read().splitlines()
    t = int(input_data[0].strip())
    line = 1
    out_lines = []
    for _ in range(t):
        s = input_data[line].strip()
        line += 1
        n = len(s)
        # get indices for active servers ('1')
        positions = [i for i, ch in enumerate(s) if ch == '1']
        m = len(positions)
        if m == 0:
            out_lines.append(""0"")
            continue
        # Precompute A: A[i] = positions[i] - i
        A = [positions[i] - i for i in range(m)]
        # check(X) returns True if there exists a window in A
        # such that:
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
        # and A[j] - A[i] <= X.
        def check(X):
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
            if m - X <= 0:
                return True
            j = 0
            for i in range(m):
                if j < i:
                    j = i
                # slide j as far as possible while A[j]-A[i] <= X
                while j < m and A[j] - A[i] <= X:
                    j += 1
                # j now is one past the last index satisfying condition, so the window has length (j - i)
                if j - i >= m - X:
                    return True
            return False
        # Binary search for the minimum X
        lo, hi, ans = 0, n, n
        while lo <= hi:
            mid = (lo + hi) // 2
            if check(mid):
                ans = mid
                hi = mid - 1
            else:
                lo = mid + 1
        out_lines.append(str(ans))
    sys.stdout.write(""\n"".join(out_lines))
if __name__ == '__main__':
    solve()",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053766
1390053762,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    # Create list of (value + index) for each firewall
    skip_value = []
    for i in range(n):
        skip_value.append((firewalls[i] + i, i))
    # Sort by descending benefit to skip
    skip_value.sort(reverse=True)
    # Mark which firewalls to skip
    skipped = [0] * n
    for i in range(k):
        _, idx = skip_value[i]
        skipped[idx] = 1
    # Now calculate final effort
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
# Main driver
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053762
1390053763,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        min_cost = float('inf')
        # Iterate over all possible prefixes to remove
        for i in range(n + 1):
            # Iterate over all possible suffixes to remove
            for j in range(n + 1):
                # Calculate the remaining servers after removing i from the start and j from the end
                remaining_servers = servers[i:n-j] if i + j <= n else """"
                # Count remaining idle servers (0's) and decommissioned active servers (1's)
                remaining_idle = remaining_servers.count('0')
                decommissioned_active = (servers[:i].count('1') + servers[n-j:].count('1'))
                # Calculate the cost
                cost = max(remaining_idle, decommissioned_active)
                # Update the minimum cost
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
# Input reading
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Get results
results = min_decommissioning_cost(test_cases)
# Output results
for result in results:
    print(result)",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053763
1390053764,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053764
1390053755,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(n, k, arr):
    dq = deque()  # Stores indices of negative numbers
    res = []
    # Process first batch
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store result for the first batch
    res.append(arr[dq[0]] if dq else 0)
    # Process remaining batches
    for i in range(k, n):
        # Remove elements that are out of the window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store result for the current batch
        res.append(arr[dq[0]] if dq else 0)
    return res
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Process and print output
    print("" "".join(map(str, earliest_faulty_readings(n, k, arr))))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053755
1390053759,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053759
1390053761,unknown,unknown,unknown,"def min_decommissioning_cost(s):
    n = len(s)
    prefix_active = [0] * (n + 1)
    for i in range(n):
        prefix_active[i+1] = prefix_active[i] + (1 if s[i] == '1' else 0)
    total_active = prefix_active[n]
    min_cost = float('inf')
    for start in range(n + 1):
        prefix_removed = prefix_active[start]
        for end in range(start, n + 1):
            if start == end:
                min_cost = min(min_cost, total_active)
                continue
            active_remaining = prefix_active[end] - prefix_active[start]
            active_removed = prefix_removed + (total_active - prefix_active[end])
            idle_remaining = (end - start) - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
import sys
input = sys.stdin.readline
t = int(input())
for _ in range(t):
    server_rack = input().strip()
    print(min_decommissioning_cost(server_rack))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053761
1390053748,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053748
1390053751,unknown,unknown,unknown,"import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            long[] arr = new long[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextLong();
            }
            long totalSum = 0;
            for (long val : arr) {
                totalSum += val;
            }
            long currentWindowSum = 0;
            for (int i = 0; i < k; i++) {
                currentWindowSum += arr[i];
            }
            long maxWindowSum = currentWindowSum;
            for (int i = k; i < n; i++) {
                currentWindowSum = currentWindowSum + arr[i] - arr[i - k];
                maxWindowSum = Math.max(maxWindowSum, currentWindowSum);
            }
            System.out.println(totalSum - maxWindowSum );
        }
        sc.close();
    }
}",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053751
1390053754,unknown,unknown,unknown,"import sys
def min_effort(n, k, firewalls):
    if k >= n:
        return 0  # If we can skip all firewalls, effort is 0.
    total_effort = sum(firewalls)  # Base case: no firewalls skipped
    min_effort = total_effort  # Track the minimum possible effort
    # Precompute prefix sum for efficient range calculations
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + firewalls[i]
    # Try skipping every contiguous k firewalls using a sliding window
    for i in range(n - k + 1):  
        skipped_sum = prefix_sum[i + k] - prefix_sum[i]  # Sum of skipped firewalls
        increased_security = (n - (i + k)) * k  # Strength increase for remaining firewalls
        remaining_effort = total_effort - skipped_sum + increased_security
        min_effort = min(min_effort, remaining_effort)
    return min_effort
# Read input
t = int(sys.stdin.readline().strip())  
output = []
for _ in range(t):
    n, k = map(int, sys.stdin.readline().split())
    firewalls = list(map(int, sys.stdin.readline().split()))
    output.append(str(min_effort(n, k, firewalls)))
# Print final output
sys.stdout.write(""\n"".join(output) + ""\n"")",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053754
1390053747,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):  # Iterate through all possible start positions
        for j in range(i, n + 1):  # Iterate through all possible end positions
            remaining = s[i:j]
            zeros_remaining = remaining.count('0')
            ones_removed = s[:i].count('1') + s[j:].count('1')
            ans = min(ans, max(zeros_remaining, ones_removed))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053747
1390053744,unknown,unknown,unknown,"from collections import deque
def first_negative_in_windows(arr, k):
    dq = deque()
    result = []
    # Process the first window of size k
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Append result for first window
    result.append(arr[dq[0]] if dq else 0)
    # Process remaining windows
    for i in range(k, len(arr)):
        # Remove indices that are out of the current window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # If current element is negative, add its index
        if arr[i] < 0:
            dq.append(i)
        # Append the earliest negative reading for current window if exists, else 0
        result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    import sys
    input_data = sys.stdin.read().strip().split()
    if not input_data:
        return
    t = int(input_data[0])
    index = 1
    outputs = []
    for _ in range(t):
        n = int(input_data[index])
        k = int(input_data[index + 1])
        index += 2
        arr = list(map(int, input_data[index:index+n]))
        index += n
        res = first_negative_in_windows(arr, k)
        outputs.append("" "".join(map(str, res)))
    # Print each test case result on a new line
    print(""\n"".join(outputs))
if __name__ == '__main__':
    main()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053744
1390053737,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            faulty = 0
            for num in batch:
                if num < 0:
                    faulty = num
                    break
            result.append(faulty)
        results.append(result)
    return results
# Read the number of test cases
test_cases = int(input())
results = earliest_faulty_readings(test_cases)
# Print the results
for result in results:
    print(' '.join(map(str, result)) + ' ')",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053737
1390053738,unknown,unknown,unknown,"def min_cost_optimization(servers):
    n = len(servers)
    min_cost = float('inf')
    for prefix in range(n + 1):
        for suffix in range(n + 1 - prefix):
            remaining = servers[prefix:n-suffix]
            idle_servers = remaining.count('0')
            active_servers_removed = servers[:prefix].count('1') + servers[n-suffix:].count('1')
            cost = max(idle_servers, active_servers_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        servers = input().strip()
        result = min_cost_optimization(servers)
        print(result)
if __name__ == ""__main__"":
    solve()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053738
1390053739,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053739
1390053734,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining_s = s[i:n - j]
            idle_count = 0
            for char in remaining_s:
                if char == '0':
                    idle_count += 1
            active_removed = 0
            for k in range(i):
                if s[k] == '1':
                    active_removed += 1
            for k in range(n - j, n):
                if s[k] == '1':
                    active_removed += 1
            cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053734
1390053735,unknown,unknown,unknown,"def min_effort_to_breach_firewalls(test_cases):
    results = []
    for n, k, strengths in test_cases:
        # Sort the strengths to consider the weakest firewalls first
        strengths.sort()
        # Initialize the minimum effort to a large number
        min_effort = float('inf')
        # Iterate over the number of skips
        for skips in range(min(k, n) + 1):
            # Calculate the effort if we skip 'skips' firewalls
            current_effort = 0
            # Calculate the effort for the remaining firewalls after skipping
            for i in range(skips, n):
                current_effort += strengths[i] + skips
            # Update the minimum effort
            min_effort = min(min_effort, current_effort)
        results.append(min_effort)
    return results
# Input reading
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    test_cases.append((n, k, strengths))
# Get results
results = min_effort_to_breach_firewalls(test_cases)
# Output results
for result in results:
    print(result)",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053735
1390053736,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                dp[i][j] = dp[i-1][j-1]
            current_strength = strengths[i-1] + j  
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053736
1390053732,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
void findFaulty(int n, int k, vector<int>& arr) {
    vector<int>reports;
    int i = 0;
    int j = k-1;
    while(i<j && j<n){
        bool neg = false;
        int val = 0;
        for(int x = i; x <= j; x++){
            if(arr[x]<0){
                val = arr[x];
                neg = true;
                break;
            }
        }
        reports.push_back(neg ? val: 0 );
        i++;
        j++;
    }
    for(auto report : reports){
        cout<<report<<"" "";
    }
    cout<<endl;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        findFaulty(n, k, arr);
    }
    return 0;
}",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053732
1390053729,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053729
1390053731,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    res = []
    L, R = 0, k - 1
    while R < n:
        batch = arr[L:R+1]
        isFaulty, value = False, 0
        for i in range(len(batch)):
            if batch[i] < 0:
                isFaulty = True
                value = batch[i]
                break
        if not isFaulty:
            res.append(0)
        else:
            res.append(value)
        L += 1
        R += 1
    print(*res)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053731
1390053730,unknown,unknown,unknown,"def minimum_effort(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]
        arr = test_cases[t][1][:]  # Create a copy of the input array
        if k >= n:
            results.append(0)
            continue
        min_effort = float('inf')
        for i in range(1 << n):
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            if len(skipped_indices) <= k:
                effort = 0
                temp_arr = arr[:]  # Create a copy of the original array for each combination
                skip_count = 0
                for j in range(n):
                    if (i >> j) & 1:
                        skip_count += 1
                        for l in range(j + 1, n):
                            if not (i >> l) & 1:
                                temp_arr[l] += 1
                    else:
                        effort += temp_arr[j]
                min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
# Input reading
T = int(input())
test_cases = []
# Read all test cases
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append([(n, k), arr])
# Get the results and print them
results = minimum_effort(T, test_cases)
for result in results:
    print(result)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053730
1390053722,unknown,unknown,unknown,"import java.util.*;
public class DataCenterOptimization {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = Integer.parseInt(sc.nextLine());
        while (T-- > 0) {
            String s = sc.nextLine();
            int n = s.length();
            int totalActive = 0, totalIdle = 0;
            for (char c : s.toCharArray()) {
                if (c == '1') totalActive++;
                else totalIdle++;
            }
            int[] prefixActive = new int[n + 1];
            int[] prefixIdle = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixActive[i + 1] = prefixActive[i] + (s.charAt(i) == '1' ? 1 : 0);
                prefixIdle[i + 1] = prefixIdle[i] + (s.charAt(i) == '0' ? 1 : 0);
            }
            int minCost = Integer.MAX_VALUE;
            // Try all possible (l, r) subarrays to keep
            for (int l = 0; l <= n; l++) {
                for (int r = l; r <= n; r++) {
                    int idleLeft = prefixIdle[r] - prefixIdle[l];
                    int activeRemoved = prefixActive[l] + (totalActive - prefixActive[r]);
                    int cost = Math.max(idleLeft, activeRemoved);
                    minCost = Math.min(minCost, cost);
                }
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053722
1390053723,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> ans = findResult(arr, k);
            for (int num : ans) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
    public static List<Integer> findResult(int []arr, int k){
        List<Integer> ans = new ArrayList<Integer>();
        Deque<Integer> deque = new LinkedList<>();
        for(int i =0;i<k;i++){
            if(arr[i]<0){
            deque.addLast(i);
            }
        }
        if(!deque.isEmpty()){
            ans.add(arr[deque.peekFirst()]);
        }
        for(int i=k;i<arr.length;i++){
            if(!deque.isEmpty()&&deque.peekFirst()<=i-k){
                deque.pollFirst();
            }
            if(arr[i]<0){
            deque.addLast(i);
            }
            if(!deque.isEmpty()){
                ans.add(arr[deque.peekFirst()]);
            }else{
                ans.add(0);
            }
        }
        return ans;
    }
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053723
1390053728,unknown,unknown,unknown,"#include <stdio.h>
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        // Process each window
        for (int i = 0; i <= n - k; i++) {
            int found = 0;
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    printf(""%d "", arr[j]);
                    found = 1;
                    break;
                }
            }
            if (!found) {
                printf(""0 "");
            }
        }
        printf(""\n"");
    }
    return 0;
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053728
1390053719,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053719
1390053721,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            # Calculate the remaining '0's in the middle
            # Total '0's minus the '0's removed from the left and right
            # Since we are iterating over left, we need to find the right decommissioning point
            # that minimizes the cost
            # We can use binary search to find the optimal right decommissioning point
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053721
1390053718,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 1's
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = (j - i) - (prefix_1[j] - prefix_1[i])  # Optimized calculation of 0s
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053718
1390053712,unknown,unknown,unknown,"from collection import deque 
def early_fault(arr , n , k):
    queue = deque()
    output = []
#Process first k element    
    for i in range (k):
        if arr[i] < 0:
            queue.append(i)
#Iteration
    for i in range(n -k +1):
        #add first faulty
        output.append(arr[queue[0]] if queue else 0)
        if queue and queue[0] ==i:
            queue.popleft()
#add new falut
        if i+k < n and arr[i + k] < 0:
            queue.append(i+k)
    return output
#read test cases
test_cases = int(input().strip())
for _ in range(test_cases):
    size , batch = map(int , input(). strip().split()) #reading n and k 
    reading = list(map(int,input().strip().split()))
    #getting result
    res = early_fault(readings , size , batch)
    print(*res)",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053712
1390053711,unknown,unknown,unknown,"import java.util.*;
public class ServerDecommissioning {
    public static List<Integer> minDecommissionCost(List<String> testCases) {
        List<Integer> results = new ArrayList<>();
        for (String servers : testCases) {
            int n = servers.length();
            int minCost = Integer.MAX_VALUE;
            int[] prefix0 = new int[n + 1];
            int[] prefix1 = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefix0[i + 1] = prefix0[i] + (servers.charAt(i) == '0' ? 1 : 0);
                prefix1[i + 1] = prefix1[i] + (servers.charAt(i) == '1' ? 1 : 0);
            }
            for (int i = 0; i <= n; i++) {
                for (int j = i; j <= n; j++) {
                    int remaining0s = prefix0[j] - prefix0[i]; 
                    int removed1s = prefix1[i] + (prefix1[n] - prefix1[j]);
                    int cost = Math.max(remaining0s, removed1s);
                    minCost = Math.min(minCost, cost);
                }
            }
            results.add(minCost);
        }
        return results;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine();
        List<String> testCases = new ArrayList<>();
        for (int i = 0; i < t; i++) {
            testCases.add(scanner.nextLine().trim());
        }
        List<Integer> results = minDecommissionCost(testCases);
        for (int result : results) {
            System.out.println(result);
        }
        scanner.close();
    }
}",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053711
1390053715,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    dp = [float('inf')] * (k + 1)
    dp[0] = 0
    for i in range(1, n + 1):
        new_dp = dp[:]  # Create a copy to avoid overwriting during iteration
        for j in range(min(k, i), -1, -1):
            if j <= i - 1:
                new_dp[j] = min(new_dp[j], dp[j] + strengths[i - 1] + j)
            if j > 0:
                new_dp[j] = min(new_dp[j], dp[j - 1])
        dp = new_dp
    return dp[k]
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        if k >= n:
            print(0)
        else:
            print(min_effort_to_breach(n, k, strengths))
solve()",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053715
1390053704,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    total_active = server_rack.count('1')
    total_idle = server_rack.count('0')
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
    left, right = 0, len(server_rack) - 1
    removed_active = 0
    removed_idle = 0
    while left <= right:
        while left <= right and server_rack[left] == '0':  # Remove idle from the left
            removed_idle += 1
            left += 1
        while left <= right and server_rack[right] == '0':  # Remove idle from the right
            removed_idle += 1
            right -= 1
        remaining_idle = total_idle - removed_idle
        min_cost = min(min_cost, max(remaining_idle, removed_active))
        if left <= right:
            removed_active += 1  # Remove an active server
            left += 1
            min_cost = min(min_cost, max(total_idle - removed_idle, removed_active))
    return min_cost
# Read input
T = int(input())  # Number of test cases
results = []
for _ in range(T):
    server_rack = input().strip()
    results.append(min_decommission_cost(server_rack))
# Print results
for res in results:
    print(res)",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053704
1390053705,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    // Optimized function to compute the minimum decommission cost for a test case
    public static int minDecommissionCostOptimized(String testCase) {
        int n = testCase.length();
        int[] prefix0 = new int[n + 1];
        int[] prefix1 = new int[n + 1];
        // Build prefix sum arrays for '0's and '1's
        for (int i = 0; i < n; i++) {
            char ch = testCase.charAt(i);
            prefix0[i + 1] = prefix0[i] + (ch == '0' ? 1 : 0);
            prefix1[i + 1] = prefix1[i] + (ch == '1' ? 1 : 0);
        }
        int totalOnes = prefix1[n];
        int minCost = Integer.MAX_VALUE;
        // For each possible starting index i for the remaining segment
        for (int i = 0; i <= n; i++) {
            // Compute the ideal candidate j using the derived formula
            int candidate = i + totalOnes;
            if (candidate > n) {
                candidate = n;
            }
            // Check candidate j as well as neighboring indices to ensure optimal cost
            for (int j : new int[]{candidate, candidate - 1, candidate + 1}) {
                if (j < i || j > n) continue;
                int zerosKept = prefix0[j] - prefix0[i];
                int onesRemoved = prefix1[i] + (totalOnes - prefix1[j]);
                int cost = Math.max(zerosKept, onesRemoved);
                if (cost < minCost) {
                    minCost = cost;
                }
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        scanner.nextLine(); // Consume the newline
        // Process each test case
        for (int t = 0; t < T; t++) {
            String testCase = scanner.nextLine().trim();
            int result = minDecommissionCostOptimized(testCase);
            System.out.println(result);
        }
        scanner.close();
    }
}",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053705
1390053709,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053709
1390053699,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053699
1390053702,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053702
1390053697,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Precompute prefix sums for active and idle servers
    prefix_active = [0] * (n + 1)
    prefix_idle = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = n  # Initialize with worst case (all servers)
    # Try all possible left and right cuts
    for left in range(n + 1):  # Remove servers[0:left]
        for right in range(left, n + 1):  # Keep servers[left:right]
            # Active servers removed = those removed from left + those removed from right
            active_removed_left = prefix_active[left]
            active_removed_right = total_active - prefix_active[right]
            active_removed = active_removed_left + active_removed_right
            # Idle servers remaining = those in the middle section we keep
            idle_remaining = prefix_idle[right] - prefix_idle[left]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    try:
        t = int(input().strip())
        results = []
        for _ in range(t):
            servers = input().strip()
            results.append(str(min_decommissioning_cost(servers)))
        print(""\n"".join(results))
    except Exception as e:
        print(f""Error: {e}"")
if __name__ == ""__main__"":
    main()",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053697
1390053689,unknown,unknown,unknown,"def find_faulty(data_sets):
    results = []
    for data,w_size, s_readings in data_sets:
        output = []
        faulty = [] 
        for i in range(data):
            while faulty and faulty[0] < i - w_size + 1:
                faulty.pop(0)
            if s_readings[i] < 0:
                faulty.append(i)
            if i >= w_size - 1:
                if faulty:
                    output.append(s_readings[faulty[0]])
                else:
                    output.append(0)
        results.append("" "".join(map(str, output)))
    print(""\n"".join(results))
n = int(input())
test_data = []
for _ in range(n):
    length, win = map(int, input().split())
    readings = list(map(int, input().split()))
    test_data.append((length, win, readings))
find_faulty(test_data)",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053689
1390053691,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053691
1390053694,unknown,unknown,unknown,"def minimum_pruning_cost(server_rack):
    n = len(server_rack)
    active_count = server_rack.count('1')
    total_count = len(server_rack)
    idle_count = total_count - active_count
    active_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (1 if server_rack[i] == '1' else 0)
    min_cost = float('inf')
    for left in range(n + 1):  
        for right in range(n + 1 - left):  
            if left + right == 0:
                continue
            if left + right == n:
                continue
            active_decommissioned = active_prefix[left] + (active_prefix[n] - active_prefix[n - right])
            idle_remaining = (n - left - right) - (active_prefix[n - right] - active_prefix[left])
            cost = max(idle_remaining, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input().strip())
    for _ in range(t):
        server_rack = input().strip()
        print(minimum_pruning_cost(server_rack))
if __name__ == ""__main__"":
    solve()",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053694
1390053684,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            System.out.println(minEffort(n, k, arr));
        }
        sc.close();
    }
    static int minEffort(int n, int k, int[] arr) {
        Integer[][] dp = new Integer[n][k + 1];
        return calc(0, 0, n, k, arr, dp);
    }
    static int calc(int i, int skip, int n, int k, int[] arr, Integer[][] dp) {
        if (i == n) return 0;
        if (dp[i][skip] != null) return dp[i][skip];
        int take = arr[i] + skip + calc(i + 1, skip, n, k, arr, dp);
        int leave = (skip < k) ? calc(i + 1, skip + 1, n, k, arr, dp) : Integer.MAX_VALUE;
        return dp[i][skip] = Math.min(take, leave);
    }
}",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053684
1390053687,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053687
1390053688,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine().trim());
        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken()), k = Integer.parseInt(st.nextToken());
            int[] strengths = Arrays.stream(br.readLine().split("" "")).mapToInt(Integer::parseInt).toArray();
            System.out.println(minEffort(n, k, strengths));
        }
    }
    private static long minEffort(int n, int k, int[] strengths) {
        if (k >= n) return 0; 
        long[] dp = new long[k + 1];
        Arrays.fill(dp, Long.MAX_VALUE / 2);
        dp[0] = 0;
        for (int strength : strengths) {
            for (int skips = k; skips >= 0; skips--) {
                dp[skips] = Math.min(dp[skips] + strength + skips, skips > 0 ? dp[skips - 1] : Long.MAX_VALUE);
            }
        }
        return Arrays.stream(dp).min().getAsLong();
    }
}",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053688
1390053681,unknown,unknown,unknown,"import sys
def min_effort(n, k, firewalls):
    if k >= n:
        return 0  # If we can skip all firewalls, effort is 0.
    total_effort = sum(firewalls)  # Baseline effort without skipping
    min_effort = float('inf')  # Start with a very large number
    # Try every possible `k`-firewall skip combination
    for i in range(n - k + 1):  # Sliding window to choose which firewalls to skip
        skipped_sum = sum(firewalls[i:i + k])  # Sum of skipped firewalls
        remaining = firewalls[:i] + firewalls[i + k:]  # Remaining firewalls
        # Increase security for remaining firewalls
        increased_security = sum(remaining[j] + (k if j >= i else 0) for j in range(len(remaining)))
        total_after_skip = increased_security
        min_effort = min(min_effort, total_after_skip)
    return min_effort
# Read input
t = int(sys.stdin.readline())  # Number of test cases
output = []
for _ in range(t):
    n, k = map(int, sys.stdin.readline().split())
    firewalls = list(map(int, sys.stdin.readline().split()))
    output.append(str(min_effort(n, k, firewalls)))
# Print the final output
sys.stdout.write(""\n"".join(output) + ""\n"")",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053681
1390053682,unknown,unknown,unknown,"def f(a):
    b = len(a)
    c = a.count(""1"")
    d = b - c
    e = float(""inf"")
    for i in range(b + 1):
        for j in range(b + 1 - i):
            x = a[:i]
            y = a[b - j:] if j > 0 else """"
            z = a[i:b - j]
            p = x.count(""1"") + y.count(""1"")
            q = z.count(""0"")
            e = min(e, max(q, p))
    return e
t = int(input())
for _ in range(t):
    a = input().strip()
    print(f(a))",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053682
1390053683,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    return min(dp[n])
T = int(input())  
for _ in range(T):
    n, k = map(int, input().split()) 
    firewalls = list(map(int, input().split()))  
    print(min_effort(n, k, firewalls))",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053683
1390053680,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
class Solution {
    public static int min_pruning_cost(String serverRack) {
        int n = serverRack.length();
        int minCost = n + 1;
        for (int leftRemoveCount = 0; leftRemoveCount <= n; ++leftRemoveCount) {
            for (int rightRemoveCount = 0; rightRemoveCount <= n - leftRemoveCount; ++rightRemoveCount) {
                int idleRemaining = 0;
                int activeRemoved = 0;
                // Calculate active_removed
                for (int i = 0; i < leftRemoveCount; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        activeRemoved++;
                    }
                }
                for (int i = n - rightRemoveCount; i < n; ++i) {
                    if (serverRack.charAt(i) == '1') {
                        activeRemoved++;
                    }
                }
                // Calculate idle_remaining
                for (int i = leftRemoveCount; i < n - rightRemoveCount; ++i) {
                    if (serverRack.charAt(i) == '0') {
                        idleRemaining++;
                    }
                }
                int cost = Math.max(idleRemaining, activeRemoved);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // consume newline
        while (t-- > 0) {
            String serverRack = scanner.nextLine();
            System.out.println(min_pruning_cost(serverRack));
        }
    }
}",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053680
1390053671,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minEffort(int[] firewalls, int k) {
        int n = firewalls.length;
        if (k >= n) return 0;
        int[][] dp = new int[n + 1][k + 1];
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= k; j++) {
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
                if (dp[i + 1][j] != Integer.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], firewalls[i] + dp[i + 1][j]);
                }
            }
        }
        return dp[0][0];
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minEffort(firewalls, k));
        }
        sc.close();
    }
}",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053671
1390053677,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        for i in range(n + 1):
            for j in range(i, n + 1):
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
T = int(input())
test_cases = [input().strip() for _ in range(T)]
results = min_decommission_cost(test_cases)
for result in results:
    print(result)",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053677
1390053678,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    skipped = [False] * n  # Track skipped firewalls
    # Greedy selection of k highest firewalls to skip
    temp_a = a[:]
    for _ in range(k):
        max_val = -1
        max_idx = -1
        for i in range(n):
            if not skipped[i] and temp_a[i] > max_val:
                max_val = temp_a[i]
                max_idx = i
        if max_idx != -1:
            skipped[max_idx] = True
            temp_a[max_idx] = -1
    effort = 0
    skipped_count = 0
    for i in range(n):
        if skipped[i]:
            skipped_count += 1
        else:
            effort += a[i] + skipped_count
    print(effort)
t = int(input())
for _ in range(t):
    solve()",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053678
1390053668,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053668
1390053670,unknown,unknown,unknown,"def min_cost(server_str):
    n = len(server_str)
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
    for i in range(n):
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
    total_1 = prefix_1[n]
    total_0 = prefix_0[n]
    min_cost = float('inf')
    # Try removing l elements from the front
    for l in range(n + 1):
        # Try removing r elements from the back
        for r in range(n - l + 1):
            left = l
            right = n - r
            remaining_0 = prefix_0[right] - prefix_0[left]
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
            cost = max(remaining_0, removed_1)
            min_cost = min(min_cost, cost)
    return min_cost
# Main driver
T = int(input())
for _ in range(T):
    server_str = input().strip()
    print(min_cost(server_str))",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053670
1390053658,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053658
1390053664,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053664
1390053656,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
            long[][] dp = new long[n + 1][k + 1];
            for (int i = 0; i <= n; i++) Arrays.fill(dp[i], Long.MAX_VALUE / 2);
            dp[0][0] = 0;
            for (int i = 1; i <= n; i++) {
                for (int j = 0; j <= k; j++) {
                    // Don't skip
                    dp[i][j] = dp[i - 1][j] + arr[i - 1] + j;
                    // Skip
                    if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
            long minEffort = Long.MAX_VALUE;
            for (int j = 0; j <= k; j++) {
                minEffort = Math.min(minEffort, dp[n][j]);
            }
            System.out.println(minEffort);
        }
        sc.close();
    }
}",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053656
1390053654,unknown,unknown,unknown,"def earliest_faulty_reading(test_cases, data):
    results = []
    for case in range(test_cases):
        n, k = data[case][0]
        arr = data[case][1]
        res = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            found = next((num for num in batch if num < 0), 0)
            res.append(found)
        results.append("" "".join(map(str, res)))
    return ""\n"".join(results)
# Reading input
t = int(input())
data = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    data.append(((n, k), arr))
# Processing and printing output
print(earliest_faulty_reading(t, data))",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053654
1390053649,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053649
1390053651,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minEffort(int[] firewalls, int k) {
        int n = firewalls.length;
        if (k >= n) return 0;
        int[][] dp = new int[n + 1][k + 1];
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= k; j++) {
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
                if (dp[i + 1][j] != Integer.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], firewalls[i] + dp[i + 1][j]);
                }
            }
        }
        return dp[0][0];
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minEffort(firewalls, k));
        }
        sc.close();
    }
}",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053651
1390053652,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            decommissioned_ones = 0
            remaining_zeros = 0
            # Decommission from the beginning
            decommissioned_ones += s[:i].count('1')
            # Decommission from the end
            decommissioned_ones += s[n - j:].count('1')
            # Remaining string after decommissioning
            remaining_string = s[i:n - j]
            remaining_zeros = remaining_string.count('0')
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053652
1390053641,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053641
1390053643,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        prefix = s[:i]
        for j in range(n - i + 1):
            suffix = s[n-j:]
            remaining = s[i:n-j]
            zeros_remaining = remaining.count('0')
            ones_removed = prefix.count('1') + suffix.count('1')
            ans = min(ans, max(zeros_remaining, ones_removed))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053643
1390053648,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053648
1390053639,unknown,unknown,unknown,"def faulty_reading(arr, k):
    result = []
    for i in range(0,len(arr) - k + 1):
        for j in range(i,i+k):
            if arr[j] < 0:
                result.append(arr[j])
                break
            if j == i+k-1:
                result.append(0)
    return result
t = int(input())
for _ in range(t):
    n,k = map(int,input().split())
    arr = list(map(int,input().split()))
    print(*faulty_reading(arr,k))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053639
1390053640,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    # Create list of (value + index) for each firewall
    skip_value = []
    for i in range(n):
        skip_value.append((firewalls[i] + i, i))
    # Sort by descending benefit to skip
    skip_value.sort(reverse=True)
    # Mark which firewalls to skip
    skipped = [0] * n
    for i in range(k):
        _, idx = skip_value[i]
        skipped[idx] = 1
    # Now calculate final effort
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
# Main driver
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053640
1390053637,unknown,unknown,unknown,"def minimize_effort(test_cases):
    results = []
    for n, k, strengths in test_cases:
        # Sort the strengths array to prioritize skipping the most costly firewalls
        strengths.sort()
        # Skip up to k strongest firewalls, which are now the last k elements in the sorted list
        total_effort = sum(strengths[:-k]) if k < n else 0
        results.append(total_effort)
    return results
# Input reading
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    test_cases.append((n, k, strengths))
# Get results
results = minimize_effort(test_cases)
# Output results
for res in results:
    print(res)",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053637
1390053636,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053636
1390053632,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        for i in range(n + 1):
            for j in range(i, n + 1):
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
T = int(input())
test_cases = [input().strip() for _ in range(T)]
results = min_decommission_cost(test_cases)
for result in results:
    print(result)",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053632
1390053634,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053634
1390053635,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # If we can skip all firewalls, return 0 effort
    if k >= n:
        return 0
    # Initialize DP array: dp[j] = min effort using at most j skips
    dp = [float('inf')] * (k + 1)
    dp[0] = 0  # Base case: No firewalls, no effort
    for i in range(1, n + 1):
        # Process in **reverse order** to avoid overwriting dp[j-1]
        for j in range(min(k, i), -1, -1):  
            # Case 1: Don't skip this firewall
            if j <= i - 1:
                dp[j] = dp[j] + strengths[i-1] + j
            # Case 2: Skip this firewall (if we have skips left)
            if j > 0:
                dp[j] = min(dp[j], dp[j-1])
    return dp[k]
def solve():
    t = int(input())  # Read number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
        strengths = list(map(int, input().split()))  # Read firewall strengths
        # Special case: If we can skip all firewalls
        if k >= n:
            print(0)
        else:
            print(min_effort_to_breach(n, k, strengths))
# Run the solution
solve()",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053635
1390053626,unknown,unknown,unknown,"def calculate_minimum_effort(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        # Calculate the total effort
        total_effort = sum(firewalls)
        # If k is equal to n, we can skip all firewalls
        if k == n:
            min_effort = 0
        else:
            # Sort the firewalls to find the k largest easily
            firewalls.sort()
            # Sum of the k largest firewalls
            sum_of_k_largest = sum(firewalls[-k:])
            # Minimum effort is total effort minus the sum of the k largest firewalls
            min_effort = total_effort - sum_of_k_largest
        results.append(min_effort)
    return results
def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    index = 0
    T = int(data[index])
    index += 1
    test_cases = []
    for _ in range(T):
        n, k = map(int, data[index].split())
        index += 1
        firewalls = list(map(int, data[index].split()))
        index += 1
        test_cases.append((n, k, firewalls))
    results = calculate_minimum_effort(test_cases)
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053626
1390053627,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        for num in batch:
            if num < 0:
                result.append(num)
                break
        else:
            result.append(0)  
    print(*result)
            ",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053627
1390053631,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Precompute prefix and suffix sums for active and idle servers
    prefix_active = [0] * (n + 1)  # prefix_active[i] = # of active servers in servers[0:i]
    prefix_idle = [0] * (n + 1)    # prefix_idle[i] = # of idle servers in servers[0:i]
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = float('inf')
    # Try all possible left and right cuts
    for left in range(n + 1):  # Remove servers[0:left]
        for right in range(left, n + 1):  # Keep servers[left:right]
            # Active servers removed = those removed from left + those removed from right
            active_removed_left = prefix_active[left]
            active_removed_right = total_active - prefix_active[right]
            active_removed = active_removed_left + active_removed_right
            # Idle servers remaining = those in the middle section we keep
            idle_remaining = prefix_idle[right] - prefix_idle[left]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        servers = input().strip()
        print(min_decommissioning_cost(servers))
if __name__ == ""__main__"":
    main()",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053631
1390053623,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053623
1390053624,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053624
1390053625,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Size of array
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            // Read array elements
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            // Process each batch
            for (int i = 0; i <= n - k; i++) { 
                int found = 0; // Flag to check if negative found
                for (int j = i; j < i + k; j++) { 
                    if (arr[j] < 0) { 
                        System.out.print(arr[j] + "" ""); // Print first negative
                        found = 1;
                        break; // Stop checking this batch
                    }
                }
                if (found == 0) System.out.print(""0 ""); // No negative found
            }
            System.out.println(); // New line for next test case
        }
    }
}",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053625
1390053622,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    prefix_active = [0] * (n + 1)
    prefix_idle = [0] * (n + 1)
    for i in range(n):
        prefix_active[i + 1] = prefix_active[i] + (1 if server_rack[i] == '1' else 0)
        prefix_idle[i + 1] = prefix_idle[i] + (1 if server_rack[i] == '0' else 0)
    total_active = prefix_active[n]
    total_idle = prefix_idle[n]
    min_cost = n
    for prefix in range(n + 1):
        for suffix in range(n + 1 - prefix):
            if prefix + suffix == n:
                cost = total_active
            else:
                active_removed = prefix_active[prefix] + (prefix_active[n] - prefix_active[n - suffix])
                idle_remaining = total_idle - (prefix_idle[prefix] + (prefix_idle[n] - prefix_idle[n - suffix]))
                cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input().strip())
for _ in range(t):
    server_rack = input().strip()
    print(min_decommissioning_cost(server_rack))",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053622
1390053619,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053619
1390053620,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053620
1390053621,unknown,unknown,unknown,"def minimum_effort(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]
        arr = test_cases[t][1][:]
        if k >= n:
            results.append(0)
            continue
        min_effort = float('inf')
        for i in range(1 << n):
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            if len(skipped_indices) <= k:
                effort = 0
                temp_arr = arr[:]
                for j in range(n):
                    if not (i >> j) & 1:
                        effort += temp_arr[j]
                        for l in range(j + 1, n):
                            if (i >> l) & 1:
                                continue
                            temp_arr[l] += 1
                min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
# Input reading
T = int(input())
test_cases = []
# Read all test cases
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append([(n, k), arr])
# Get the results and print them
results = minimum_effort(T, test_cases)
for result in results:
    print(result)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053621
1390053615,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            decommissioned_ones = 0
            remaining_zeros = 0
            # Decommission from the beginning
            decommissioned_ones += s[:i].count('1')
            # Decommission from the end
            decommissioned_ones += s[n - j:].count('1')
            # Remaining string after decommissioning
            remaining_string = s[i:n - j]
            remaining_zeros = remaining_string.count('0')
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053615
1390053618,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active servers and total idle servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative counts of active servers from left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible starting positions for the remaining servers
    for left in range(n + 1):
        # For each possible ending position
        for right in range(left, n + 1):
            # Active servers in the remaining segment
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active and idle servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case cost
    # For each possible remaining substring (from i to j-1)
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in remaining substring
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (from left and right)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053618
1390053614,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    total_active = server_rack.count('1')
    total_idle = server_rack.count('0')
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
    left, right = 0, len(server_rack) - 1
    removed_active = 0
    removed_idle = 0
    # Try decommissioning from both ends
    while left <= right:
        if server_rack[left] == '0':
            removed_idle += 1
            left += 1
        elif server_rack[right] == '0':
            removed_idle += 1
            right -= 1
        elif server_rack[left] == '1':
            removed_active += 1
            left += 1
        elif server_rack[right] == '1':
            removed_active += 1
            right -= 1
        remaining_idle = total_idle - removed_idle
        min_cost = min(min_cost, max(remaining_idle, removed_active))
    return min_cost
# Read input
T = int(input())  # Number of test cases
results = []
for _ in range(T):
    server_rack = input().strip()
    results.append(min_decommission_cost(server_rack))
# Print results
for res in results:
    print(res)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053614
1390053607,unknown,unknown,unknown,"import java.util.*;
import java.io.*;
public class FaultyComponents {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        // Read number of test cases
        int t = Integer.parseInt(reader.readLine().trim());
        StringBuilder output = new StringBuilder();
        for (int testCase = 0; testCase < t; testCase++) {
            // Read n and k
            String[] nk = reader.readLine().trim().split("" "");
            int n = Integer.parseInt(nk[0]);
            int k = Integer.parseInt(nk[1]);
            // Read the array of sensor readings
            String[] arrStr = reader.readLine().trim().split("" "");
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = Integer.parseInt(arrStr[i]);
            }
            ArrayList<Integer> results = findEarliestFaults(n, k, arr);
            // Convert results to a single string line
            for (int i = 0; i < results.size(); i++) {
                if (i > 0) output.append("" "");
                output.append(results.get(i));
            }
            output.append(""\n"");
        }
        System.out.println(output.toString());
    }
    public static ArrayList<Integer> findEarliestFaults(int n, int k, int[] arr) {
        ArrayList<Integer> result = new ArrayList<>();
        Deque<Integer> dq = new ArrayDeque<>();
        // Process the first window
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                dq.addLast(i);
            }
        }
        // Store result for the first window
        if (!dq.isEmpty()) {
            result.add(arr[dq.peek()]);
        } else {
            result.add(0);
        }
        // Process the rest of the array
        for (int i = k; i < n; i++) {
            // Remove elements not within the sliding window
            while (!dq.isEmpty() && dq.peek() <= i - k) {
                dq.poll();
            }
            // Add the current element if it's negative
            if (arr[i] < 0) {
                dq.addLast(i);
            }
            // Append result for the current window
            if (!dq.isEmpty()) {
                result.add(arr[dq.peek()]);
            } else {
                result.add(0);
            }
        }
        return result;
    }
}",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053607
1390053605,unknown,unknown,unknown,"def generate_skip_options(n, k, start=0, current_skips=[], all_skips=[]):
    if len(current_skips) == k:
        all_skips.append(current_skips[:]) 
        return
    for i in range(start, n):
        current_skips.append(i)
        generate_skip_options(n, k, i + 1, current_skips, all_skips)
        current_skips.pop() 
def min_effort_to_breach(n, k, firewalls):
    min_effort = float('inf')
    all_skip_options = []
    generate_skip_options(n, k, 0, [], all_skip_options)
    for skip_indices in all_skip_options:
        effort = 0
        skipped = set(skip_indices)
        security_increase = 0 
        for i in range(n):
            if i in skipped:
                security_increase += 1  
            else:
                effort += firewalls[i] + security_increase  
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input()) 
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053605
1390053613,unknown,unknown,unknown,"def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]  # Extract batch of size k
        found = 0
        for num in batch:
            if num < 0:
                found = num  # First faulty component
                break
        result.append(found)
    return result
# Input handling
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    print(*earliest_faulty_readings(arr, k))  # Print results space-separated",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053613
1390053604,unknown,unknown,unknown,"import bisect
T = int(input())
for _ in range(T):
    s = input().strip()
    n = len(s)
    prefix_0= [0]* (n+1)
    prefix_1 = [0] *(n+1)
    #assign
    for i in range(n):
        prefix_0[i+ 1] =prefix_0[i] +(1 if s[i]== '0' else 0)
        prefix_1[i+ 1] = prefix_1[i]+ (1 if s[i] == '1' else 0)
    total_1 = prefix_1[n]
    def check(m):
        #check
        for j in range(n + 1):
            target = prefix_0[j] - m
            l_j = bisect.bisect_left(prefix_0, target)
            if l_j<=j and prefix_1[l_j]<=m -(total_1-prefix_1[j]):
                return True
        return False
    low,high =0, n
    while low<high:
        mid=(low+high)//2
        if check(mid):
            high=mid
        else:
            low=mid + 1
    print(low)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053604
1390053601,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for n, k, arr in test_cases:
        total_effort = sum(arr)  # Compute total effort without skipping
        if k >= n:  
            results.append(""0"")  # If k >= n, we can skip all firewalls.
            continue
        # Compute the minimum effort after skipping one firewall
        min_effort = float('inf')
        for i in range(n):
            effort_with_skip = (total_effort - arr[i]) + k
            min_effort = min(min_effort, effort_with_skip)
        results.append(str(min_effort))
    return ""\n"".join(results)
# Reading input
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())  # Number of firewalls and penalty
    arr = list(map(int, input().split()))  # Firewall strengths
    test_cases.append((n, k, arr))
# Output results
print(min_effort(test_cases))",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053601
1390053602,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;
int min_pruning_cost(const string& server_rack) {
    int n = server_rack.length();
    int min_cost = n + 1;
    for (int left_remove_count = 0; left_remove_count <= n; ++left_remove_count) {
        for (int right_remove_count = 0; right_remove_count <= n - left_remove_count; ++right_remove_count) {
            int idle_remaining = 0;
            int active_removed = 0;
            // Calculate active_removed
            for (int i = 0; i < left_remove_count; ++i) {
                if (server_rack[i] == '1') {
                    active_removed++;
                }
            }
            for (int i = n - right_remove_count; i < n; ++i) {
                if (server_rack[i] == '1') {
                    active_removed++;
                }
            }
            // Calculate idle_remaining
            for (int i = left_remove_count; i < n - right_remove_count; ++i) {
                if (server_rack[i] == '0') {
                    idle_remaining++;
                }
            }
            int cost = max(idle_remaining, active_removed);
            min_cost = min(min_cost, cost);
        }
    }
    return min_cost;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin >> t;
    while (t--) {
        string server_rack;
        cin >> server_rack;
        cout << min_pruning_cost(server_rack) << endl;
    }
    return 0;
}",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053602
1390053603,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minEffort(int[] firewalls, int k) {
        int n = firewalls.length;
        if (k >= n) return 0;
        int[] dp = new int[k + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = k; j >= 0; j--) {
                if (dp[j] != Integer.MAX_VALUE) {
                    dp[j] += firewalls[i] + j;
                }
                if (j > 0) {
                    dp[j] = Math.min(dp[j], dp[j - 1]);
                }
            }
        }
        return dp[k];
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minEffort(firewalls, k));
        }
        sc.close();
    }
}",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053603
1390053596,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active ('1') and idle ('0') servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative count of active servers from the left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible segments
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Active servers in the selected range
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed (total active - active in range)
            active_removed = total_active - active_remaining
            # Cost is max of idle servers in range or removed active servers
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active ('1') and idle ('0') servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case scenario
    # Iterate through all possible substrings efficiently
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in the selected range
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (total active - active in selected range)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            # Compute cost and update minimum
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053596
1390053597,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Compute the initial total effort if we do NOT skip any firewall
    effort = sum(strengths[i] + i for i in range(n))
    # Create a list of (contribution, index)
    contributions = [(strengths[i] + i, i) for i in range(n)]
    # Sort by contribution (ascending) to skip the weakest k firewalls
    contributions.sort()
    # Remove k weakest firewalls from effort
    for i in range(k):
        effort -= contributions[i][0]
    return effort
def solve():
    t = int(input())  # Read number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
        strengths = list(map(int, input().split()))  # Read firewall strengths
        print(min_effort_to_breach(n, k, strengths))
# Run the solution
solve()",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053597
1390053600,unknown,unknown,unknown,"def min_effort_to_breach(firewalls, n, k):
    total_effort = sum(firewalls)  # Total effort without skipping any firewall
    # If we can skip all firewalls, return 0
    if k == n:
        return 0
    # Sliding window approach to find the minimum effort when skipping up to k firewalls
    min_effort = total_effort
    skipped_effort = sum(firewalls[:k])  # Initial sum of the first k firewalls
    # Try different positions for skipping
    for i in range(k, n):
        min_effort = min(min_effort, total_effort - skipped_effort)
        skipped_effort += firewalls[i] - firewalls[i - k]
    # Final check for the last possible skip window
    min_effort = min(min_effort, total_effort - skipped_effort)
    return min_effort
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Number of firewalls and max skips
    firewalls = list(map(int, input().split()))  # Strength of firewalls
    print(min_effort_to_breach(firewalls, n, k))",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053600
1390053591,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        fault = 0
        for j, val in enumerate(batch):
            if val < 0:
                fault = val
                break
        result.append(fault)
    return result
def solve():
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = find_earliest_faults(arr, k)
    print(*result)
t = int(input())
for _ in range(t):
    solve()",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053591
1390053595,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minEffort(int n, int k, int[] firewalls) {
        int[][] dp = new int[n + 1][k + 1];
        // Initialize DP array with large values
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][0] = 0;
        // DP Computation
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                // Case 1: Don't skip the firewall
                if (dp[i - 1][j] != Integer.MAX_VALUE) {
                    dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j;
                }
                // Case 2: Skip the firewall (if skips available)
                if (j > 0 && dp[i - 1][j - 1] != Integer.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        // Answer is the minimum effort across all skip possibilities
        int minEffort = Integer.MAX_VALUE;
        for (int j = 0; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[n][j]);
        }
        return minEffort;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine().trim()); // Number of test cases
        StringBuilder result = new StringBuilder();
        for (int t = 0; t < T; t++) {
            String[] nk = br.readLine().trim().split("" "");
            int n = Integer.parseInt(nk[0]);
            int k = Integer.parseInt(nk[1]);
            int[] firewalls = new int[n];
            String[] firewallValues = br.readLine().trim().split("" "");
            for (int i = 0; i < n; i++) {
                firewalls[i] = Integer.parseInt(firewallValues[i]);
            }
            result.append(minEffort(n, k, firewalls)).append(""\n"");
        }
        // Print all results in one go (faster output)
        System.out.print(result.toString());
    }
}",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053595
1390053593,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Use dynamic programming to find optimal solution
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Skip current firewall (if we still have skips left)
            if j > 0:
                # If we skip this firewall, all subsequent firewalls increase by 1
                dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip current firewall
            # Current firewall strength may have increased due to previous skips
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
    # Return minimum effort among all possible ways to use up to k skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    for result in results:
        print(result)
solve()",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053593
1390053589,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053589
1390053581,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053581
1390053582,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053582
1390053586,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # Initialize dp array with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        firewall_idx = i - 1  # Convert to 0-indexed
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            if j <= i - 1:  # Ensure we have processed enough firewalls
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
            # Option 2: Skip the current firewall
            if j > 0:  # We must have at least one skip available
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Return the minimum effort after processing all firewalls
    return dp[n][k]
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053586
1390053578,unknown,unknown,unknown,"import java.util.Scanner;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            int minEffort = Integer.MAX_VALUE;
            for (int i = 0; i < (1 << n); i++) {
                int skippedCount = 0;
                int effort = 0;
                int currentSkipCount = 0;
                for (int j = 0; j < n; j++) {
                    if ((i & (1 << j)) != 0) {
                        skippedCount++;
                    }
                }
                if (skippedCount <= k) {
                    for (int j = 0; j < n; j++) {
                        if ((i & (1 << j)) != 0) {
                            currentSkipCount++;
                        } else {
                            effort += a[j] + currentSkipCount;
                        }
                    }
                    minEffort = Math.min(minEffort, effort);
                }
            }
            System.out.println(minEffort);
        }
        scanner.close();
    }
}",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053578
1390053580,unknown,unknown,unknown,"def earliest_faulty_readings(arr, n, k):
    result = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        first_faulty = next((x for x in batch if x < 0), 0)
        result.append(first_faulty)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, n, k))",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053580
1390053577,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    n = len(arr)
    result, dq = [], deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(n - k + 1):
        result.append(arr[dq[0]] if dq else 0)
        if dq and dq[0] == i:
            dq.popleft()
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faults(arr, k))",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053577
1390053571,unknown,unknown,unknown,"def minimum_pruning_cost(server_rack):
    n = len(server_rack)
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
    active_suffix_sum = [0] * (n + 1)
    for i in range(n - 1, -1, -1):
        active_suffix_sum[n - 1 - i] = active_suffix_sum[n - i - 2] if n - i - 2 >= 0 else 0
        active_suffix_sum[n - 1 - i] += (1 if server_rack[i] == '1' else 0)
    min_cost = float('inf')
    for left in range(n + 1):
        for right in range(n + 1 - left):
            if left == 0 and right == 0:
                continue
            active_decommissioned = active_prefix_sum[left] + active_suffix_sum[right]
            remaining_length = n - left - right
            remaining_active = active_prefix_sum[left + remaining_length] - active_prefix_sum[left]
            remaining_idle = remaining_length - remaining_active
            cost = max(remaining_idle, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    results = []
    for _ in range(t):
        server_rack = input().strip()
        results.append(minimum_pruning_cost(server_rack))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053571
1390053572,unknown,unknown,unknown,"import java.util.Scanner;
public class Main {
    // Function to compute the minimum decommission cost for a given test case string
    public static int minDecommissionCost(String testCase) {
        int n = testCase.length();
        int minCost = Integer.MAX_VALUE;
        // Create prefix sum arrays for '0's and '1's of length n+1
        int[] prefix0 = new int[n + 1];
        int[] prefix1 = new int[n + 1];
        // Precompute prefix sums for 0's and 1's
        for (int i = 0; i < n; i++) {
            char ch = testCase.charAt(i);
            prefix0[i + 1] = prefix0[i] + (ch == '0' ? 1 : 0);
            prefix1[i + 1] = prefix1[i] + (ch == '1' ? 1 : 0);
        }
        // Iterate through all possible splits using indices i and j
        // i represents the start index for the ""removed"" section at the beginning,
        // and j represents the end index (exclusive) for the remaining segment.
        for (int i = 0; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                // Count of '0's in the remaining segment [i, j-1]
                int remaining0s = prefix0[j] - prefix0[i];
                // Count of '1's that have been removed: those before i and after j-1
                int removed1s = prefix1[i] + (prefix1[n] - prefix1[j]);
                // The cost for this split is the maximum of the two counts
                int cost = Math.max(remaining0s, removed1s);
                if (cost < minCost) {
                    minCost = cost;
                }
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read the number of test cases
        int T = scanner.nextInt();
        scanner.nextLine();  // Consume the newline
        // Process each test case
        for (int t = 0; t < T; t++) {
            String testCase = scanner.nextLine().trim();
            int result = minDecommissionCost(testCase);
            System.out.println(result);
        }
        scanner.close();
    }
}",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053572
1390053576,unknown,unknown,unknown,"def main():
    import sys
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053576
1390053567,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    total_active = server_rack.count('1')
    total_idle = server_rack.count('0')
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
    left, right = 0, len(server_rack) - 1
    removed_active = 0
    removed_idle = 0
    # Try decommissioning from both ends
    while left <= right:
        if server_rack[left] == '0':
            removed_idle += 1
            left += 1
        elif server_rack[right] == '0':
            removed_idle += 1
            right -= 1
        elif server_rack[left] == '1':
            removed_active += 1
            left += 1
        elif server_rack[right] == '1':
            removed_active += 1
            right -= 1
        remaining_idle = total_idle - removed_idle
        min_cost = min(min_cost, max(remaining_idle, removed_active))
    return min_cost
# Read input
T = int(input())  # Number of test cases
results = []
for _ in range(T):
    server_rack = input().strip()
    results.append(min_decommission_cost(server_rack))
# Print results
for res in results:
    print(res)",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053567
1390053563,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        result = []
        for i in range(n - k + 1):  # Sliding window
            window = arr[i:i + k]
            earliest_fault = 0
            for num in window:
                if num < 0:
                    earliest_fault = num
                    break
            result.append(earliest_fault)
        results.append(result)
    return results
# Input Parsing
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx])  # Number of test cases
    idx += 1
    test_cases = []
    for _ in range(T):
        n = int(data[idx])
        k = int(data[idx + 1])
        idx += 2
        arr = list(map(int, data[idx:idx + n]))
        idx += n
        test_cases.append((n, k, arr))
    # Process and Output
    results = earliest_faulty_readings(test_cases)
    for result in results:
        print("" "".join(map(str, result)) + "" "")
if __name__ == ""__main__"":
    main()",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053563
1390053565,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active servers and total idle servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative counts of active servers from left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible starting positions for the remaining servers
    for left in range(n + 1):
        # For each possible ending position
        for right in range(left, n + 1):
            # Active servers in the remaining segment
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active and idle servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case cost
    # For each possible remaining substring (from i to j-1)
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in remaining substring
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (from left and right)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053565
1390053566,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053566
1390053560,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    # Create list of (value + index) for each firewall
    skip_value = []
    for i in range(n):
        skip_value.append((firewalls[i] + i, i))
    # Sort by descending benefit to skip
    skip_value.sort(reverse=True)
    # Mark which firewalls to skip
    skipped = [0] * n
    for i in range(k):
        _, idx = skip_value[i]
        skipped[idx] = 1
    # Now calculate final effort
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
# Main driver
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053560
1390053561,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T; 
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s; 
        int n = s.length();
        vector<int> prefix_0(n + 1, 0);
        vector<int> prefix_1(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
        }
        auto check = [&](int k) {
            int l = 0;
            for (int r = 0; r < n; r++) {
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
                    l++;
                }
                // If subarray is valid, check number of 1's decommissioned
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
                    return true;
                }
            }
            if (prefix_1[n] <= k) {
                return true;
            }
            return false;
        };
        // Binary search for minimum cost
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        cout << low << endl;
    }
    return 0;
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053561
1390053559,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053559
1390053550,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
void solve(){
    int n,k;
    cin>>n>>k;
    vector<int> v(n);
    for(int i=0; i<n; i++) cin>>v[i];
    vector<int> ans;
    for(int i=0; i<=n-k; i++){
        bool flag = false;
        for(int j=i; j<k+i; j++){
            if(v[j] < 0){
                ans.push_back(v[j]);
                flag = true;
                break;
            }
        }
        if(!flag) ans.push_back(0);
    }
    for(int i=0; i<ans.size(); i++){
        cout<<ans[i]<<"" "";
    } cout<<""\n"";
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t;
    cin>>t;
    while(t--){
        solve();
    }
    return 0;
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053550
1390053549,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int testCases = Integer.parseInt(reader.readLine().trim());
        StringBuilder output = new StringBuilder();
        while (testCases-- > 0) {
            String[] input = reader.readLine().trim().split("" "");
            int arraySize = Integer.parseInt(input[0]);
            int batchSize = Integer.parseInt(input[1]);
            int[] readings = Arrays.stream(reader.readLine().trim().split("" ""))
                                   .mapToInt(Integer::parseInt)
                                   .toArray();
            List<Integer> earliestFaults = getFaultyReadings(readings, arraySize, batchSize);
            for (int fault : earliestFaults) {
                output.append(fault).append("" "");
            }
            output.append(""\n"");
        }
        System.out.print(output);
    }
    public static List<Integer> getFaultyReadings(int[] readings, int size, int batchSize) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> faultIndices = new LinkedList<>(); 
        for (int i = 0; i < batchSize; i++) {
            if (readings[i] < 0) {
                faultIndices.addLast(i);
            }
        }
        for (int i = batchSize; i <= size; i++) {
            result.add(faultIndices.isEmpty() ? 0 : readings[faultIndices.peekFirst()]);
            while (!faultIndices.isEmpty() && faultIndices.peekFirst() < i - batchSize + 1) {
                faultIndices.pollFirst();
            }
            if (i < size && readings[i] < 0) {
                faultIndices.addLast(i);
            }
        }
        return result;
    }
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053549
1390053546,unknown,unknown,unknown,"def find_min_cost(server_rack):
    total_idle_servers = server_rack.count('0')
    total_active_servers = server_rack.count('1')
    # Start scanning from both ends
    start = 0
    end = len(server_rack) - 1
    # Move 'start' forward while there are idle servers at the beginning
    while start < len(server_rack) and server_rack[start] == '0':
        start += 1
    # Move 'end' backward while there are idle servers at the end
    while end >= 0 and server_rack[end] == '0':
        end -= 1
    # After removing leading and trailing idle servers, count remaining idle servers
    if start <= end:
        remaining_idle_servers = server_rack[start:end+1].count('0')
        remaining_active_servers = server_rack[start:end+1].count('1')
    else:
        # If all servers are removed, then no remaining servers
        remaining_idle_servers = 0
        remaining_active_servers = 0
    # Active servers that were removed
    removed_active_servers = total_active_servers - remaining_active_servers
    # The cost is determined by the max of remaining idle servers and removed active servers
    return min(
        max(remaining_idle_servers, removed_active_servers),
        max(total_idle_servers, total_active_servers)
    )
# Read number of test cases
T = int(input(""Enter number of test cases: "").strip())
# Process each test case
for _ in range(T):
    server_rack = input(""Enter server rack binary string: "").strip()
    print(find_min_cost(server_rack))",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053546
1390053547,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053547
1390053548,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # We'll use a more memory-efficient approach that avoids potential
    # runtime errors with large inputs
    # For each firewall, calculate the ""gain"" from skipping it
    # Gain = firewall strength - penalty to subsequent firewalls
    gains = []
    for i in range(n):
        # Original cost of the firewall
        original_cost = firewalls[i]
        # Penalty to subsequent firewalls if we skip this one
        penalty = n - i - 1
        # Gain = what we save by skipping this firewall
        gain = original_cost - penalty
        gains.append((gain, i))
    # Sort by gain in descending order
    gains.sort(reverse=True)
    # Mark the firewalls to skip (the k firewalls with highest gain)
    to_skip = set()
    for i in range(min(k, n)):
        if i < len(gains) and gains[i][0] > 0:  # Only skip if gain is positive
            to_skip.add(gains[i][1])
    # Calculate the total effort
    skipped_so_far = 0
    total_effort = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            skipped_so_far += 1
        else:
            # Pay the cost of this firewall (including penalties)
            total_effort += firewalls[i] + skipped_so_far
    return total_effort
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053548
1390053542,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    min_effort = float('inf')
    def backtrack(start, chosen):
        nonlocal min_effort
        if len(chosen) == k:
            effort = 0
            skipped = set(chosen)
            security_increase = 0
            for i in range(n):
                if i in skipped:
                    security_increase += 1
                else:
                    effort += firewalls[i] + security_increase
            min_effort = min(min_effort, effort)
            return
        for i in range(start, n):
            backtrack(i + 1, chosen + [i])
    backtrack(0, [])
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053542
1390053543,unknown,unknown,unknown,"def min_server_pruning_cost(binary_string):
    # Count total idle (0s) and active (1s) servers
    total_zeros = binary_string.count('0')
    total_ones = binary_string.count('1')
    # Initialize cost to a large value
    min_cost = float('inf')
    # Left and right pointers to remove servers from both ends
    left_zeros = 0
    left_ones = 0
    # Iterate to remove servers from both ends and minimize cost
    for i in range(len(binary_string) + 1):
        # Remaining idle servers in the middle
        remaining_zeros = total_zeros - left_zeros
        # Removed active servers
        removed_ones = left_ones
        # Update minimum cost
        min_cost = min(min_cost, max(remaining_zeros, removed_ones))
        # Expand left boundary (remove one more character from the start)
        if i < len(binary_string):
            if binary_string[i] == '0':
                left_zeros += 1
            else:
                left_ones += 1
    return min_cost
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    binary_string = input().strip()
    print(min_server_pruning_cost(binary_string))",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053543
1390053545,unknown,unknown,unknown,"def find_earliest_faults(t, data):
    results = []
    for case in range(t):
        n, k = data[case][0]
        arr = data[case][1]
        result = []
        # Initialize the deque to store indices of negative numbers
        from collections import deque
        dq = deque()
        # Process the first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # For the first window, append the result
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Process the rest of the windows
        for i in range(k, n):
            # Remove elements that are out of this window
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add new element if it's negative
            if arr[i] < 0:
                dq.append(i)
            # Append the result for the current window
            if dq:
                result.append(arr[dq[0]])
            else:
                result.append(0)
        results.append(result)
    return results
# Test cases as described in the input format
test_cases = [
    ((5, 2), [-8, 2, 3, -6, 10]),
    ((8, 3), [12, -1, -7, 8, -15, 30, 16, 28])
]
# Number of test cases
t = len(test_cases)
# Calling the function
outputs = find_earliest_faults(t, test_cases)
for output in outputs:
    print("" "".join(map(str, output)))",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053545
1390053537,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = 0
        effort = 0
        temp_a = a[:]
        skip_indices = []
        for j in range(n):
          if (i >> j) & 1:
            skipped += 1
            skip_indices.append(j)
        if skipped <= k:
            skip_count = 0
            for j in range(n):
              if j in skip_indices:
                skip_count +=1
              else:
                effort += temp_a[j] + skip_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053537
1390053539,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped = 0
        effort = 0
        temp_a = a[:]
        for j in range(n):
            if (i >> j) & 1:
                skipped += 1
                temp_a[j] = -1
        if skipped <= k:
            skipped_count = 0
            for j in range(n):
                if temp_a[j] == -1:
                    skipped_count+=1
                else:
                    effort += temp_a[j] + skipped_count
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053539
1390053540,unknown,unknown,unknown,"def minimum_effort(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]
        arr = test_cases[t][1][:]  # Create a copy of the input array
        if k >= n:
            results.append(0)
            continue
        min_effort = float('inf')
        for i in range(1 << n):
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            if len(skipped_indices) <= k:
                effort = 0
                temp_arr = arr[:]  # Create a copy of the original array for each combination
                skip_count = 0
                for j in range(n):
                    if (i >> j) & 1:
                        skip_count += 1
                        for l in range(j + 1, n):
                            if not (i >> l) & 1:
                                temp_arr[l] += 1
                    else:
                        effort += temp_arr[j]
                min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
# Input reading
T = int(input())
test_cases = []
# Read all test cases
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append([(n, k), arr])
# Get the results and print them
results = minimum_effort(T, test_cases)
for result in results:
    print(result)",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053540
1390053536,unknown,unknown,unknown,"import sys
def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input efficiently
input_data = sys.stdin.read().split()
if not input_data:  # Check if input is empty
    sys.exit(0)  # Exit gracefully
index = 0
T = int(input_data[index])  # Number of test cases
index += 1
results = []
for _ in range(T):
    if index >= len(input_data):  # Prevent index out of range
        break
    n, k = map(int, input_data[index:index+2])  # Read n and k
    index += 2
    if index + n > len(input_data):  # Check if enough data exists for firewalls
        break
    firewalls = list(map(int, input_data[index:index+n]))  # Firewall strengths
    index += n
    # Compute and store the minimum effort
    results.append(str(min_effort(n, k, firewalls)))
# Print all results at once for efficiency
if results:
    sys.stdout.write(""\n"".join(results) + ""\n"")",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053536
1390053533,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053533
1390053535,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):  
        for j in range(n + 1 - i):  
            if i + j > n:
                continue
            remaining = server_rack[i:n-j]
            if not remaining:
                continue 
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
for result in results:
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053535
1390053532,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;
int min_pruning_cost(const string& server_rack) {
    int n = server_rack.length();
    int min_cost = n + 1; // Initialize with a value larger than any possible cost
    for (int left_remove_count = 0; left_remove_count <= n; ++left_remove_count) {
        for (int right_remove_count = 0; right_remove_count <= n - left_remove_count; ++right_remove_count) {
            string removed_prefix = server_rack.substr(0, left_remove_count);
            string removed_suffix = server_rack.substr(n - right_remove_count);
            string remaining_rack = server_rack.substr(left_remove_count, n - left_remove_count - right_remove_count);
            int idle_remaining = 0;
            for (char c : remaining_rack) {
                if (c == '0') {
                    idle_remaining++;
                }
            }
            int active_removed = 0;
            for (char c : removed_prefix) {
                if (c == '1') {
                    active_removed++;
                }
            }
            for (char c : removed_suffix) {
                if (c == '1') {
                    active_removed++;
                }
            }
            int cost = max(idle_remaining, active_removed);
            min_cost = min(min_cost, cost);
        }
    }
    return min_cost;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        string server_rack;
        cin >> server_rack;
        cout << min_pruning_cost(server_rack) << endl;
    }
    return 0;
}",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053532
1390053530,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        for i in range(n - k + 1):
            if dq:
                res.append(arr[dq[0]])
            else:
                res.append(0)
            if dq and dq[0] == i:
                dq.popleft()
            if i + k < n and arr[i + k] < 0:
                dq.append(i + k)
        results.append("" "".join(map(str, res)))
    return ""\n"".join(results)
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
print(earliest_faulty_readings(test_cases))",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053530
1390053526,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053526
1390053531,unknown,unknown,unknown,"from collections import deque
test_cases = int(input())
for _ in range(test_cases):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    dq = deque()  
    res = []
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(n - k + 1):
        res.append(arr[dq[0]] if dq else 0)
        if dq and dq[0] == i:
            dq.popleft()
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    for i in res:
        print(i,end="" "")
    print()",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053531
1390053520,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053520
1390053521,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    impacts = []
    for i in range(n):
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    impacts.sort(reverse=True)
    to_skip = set(impacts[i][1] for i in range(k))
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            penalty += 1
        else:
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
def main():
    results = solve_test_cases()
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053521
1390053524,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053524
1390053519,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053519
1390053512,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <deque>
#include <bits/stdc++.h>
using namespace std;
vector<int>solve(vector<int>&arr, int k) {
    vector<int>res;
    int n = arr.size();
    deque<int>dq;
    for(int i=0; i<n; i++) {
        while(!dq.empty() && i-dq.front()>=k){
            dq.pop_front();
        }
        if(arr[i]<0)
            dq.push_back(i);
        if(i>=k-1) {
            if(!dq.empty()) {
                res.push_back(arr[dq.front()]);
            }
            else {
                res.push_back(0);
            }
        }
    }
    return res;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--) {
        int n,k;
        vector<int>arr;
        cin>>n>>k;
        while(n--) {
            int a;
            cin>>a;
            arr.push_back(a);
        }
        vector<int>res = solve(arr,k);
        for(int& i: res) {
            cout<<i<<"" "";
        }
        cout<<endl;
    }
    return 0;
}",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053512
1390053513,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for n, k, arr in test_cases:
        total_effort = sum(arr)
        if k >= n:  
            results.append(""0"")  # If k >= n, we can skip all firewalls.
            continue
        # Compute the minimum effort after skipping one firewall
        min_effort = min(total_effort - arr[i] + k for i in range(n))
        results.append(str(min_effort))
    return ""\n"".join(results)
# Reading input
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())  # Number of firewalls and penalty
    arr = list(map(int, input().split()))  # Firewall strengths
    test_cases.append((n, k, arr))
# Output results
print(min_effort(test_cases))",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053513
1390053517,unknown,unknown,unknown,"import java.util.*;
public class SmartFactoryQualityControl {
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>(); // Stores indices of negative elements
        // Process first k elements
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                deque.addLast(i);
            }
        }
        // Iterate over the array in batches
        for (int i = k; i <= arr.length; i++) {
            // If deque is not empty, the first element is the earliest negative number
            result.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
            // Remove elements that are out of this window
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            // Add the next element to the deque if it's negative
            if (i < arr.length && arr[i] < 0) {
                deque.addLast(i);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Size of array
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053517
1390053509,unknown,unknown,unknown,"def earliest_faulty_reading(testcases):
    results = []
    for case in testcases:
        n, k, arr = case
        result = []
        # Process each batch of size k
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            faulty = next((x for x in batch if x < 0), 0)
            result.append(faulty)
        results.append(result)
    return results
# Reading input
t = int(input())  # number of test cases
testcases = []
for _ in range(t):
    n, k = map(int, input().split())  # size of array and batch size
    arr = list(map(int, input().split()))  # the array of sensor readings
    testcases.append((n, k, arr))
# Get the result for each test case
results = earliest_faulty_reading(testcases)
# Output the result
for result in results:
    print("" "".join(map(str, result)))",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053509
1390053511,unknown,unknown,unknown,"def solve_NeelJain():
    n_NeelJain, k_NeelJain = map(int, input().split())
    strengths_NeelJain = list(map(int, input().split()))
    total_NeelJain = sum(strengths_NeelJain)
    skip_NeelJain = [strengths_NeelJain[i] - (n_NeelJain - i - 1) for i in range(n_NeelJain)]
    skip_NeelJain.sort(reverse=True)
    total_NeelJain -= sum(skip_NeelJain[:k_NeelJain])
    total_NeelJain -= k_NeelJain * (k_NeelJain - 1) // 2
    print(total_NeelJain)
if __name__== ""__main__"":
    t_NeelJain = int(input())
    for _ in range(t_NeelJain):
        solve_NeelJain()",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053511
1390053510,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053510
1390053503,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053503
1390053501,unknown,unknown,unknown,"import sys
def min_effort(n, k, firewalls):
    if k >= n:
        return 0  # If we can skip all firewalls, effort is 0.
    total_effort = sum(firewalls)  # Total effort without skipping
    # Try removing k firewalls in different positions and find the minimum effort
    min_effort = total_effort
    for i in range(n - k + 1):  # Sliding window approach
        skipped_sum = sum(firewalls[i:i + k])  # Sum of k consecutive firewalls
        extra_security = k * (n - (i + k))  # Extra security added to remaining firewalls
        remaining_effort = total_effort - skipped_sum + extra_security  # Adjusted total effort
        min_effort = min(min_effort, remaining_effort)
    return min_effort
# Read input
t = int(sys.stdin.readline())  # Number of test cases
output = []
for _ in range(t):
    n, k = map(int, sys.stdin.readline().split())
    firewalls = list(map(int, sys.stdin.readline().split()))
    output.append(str(min_effort(n, k, firewalls)))
# Print the final output
sys.stdout.write(""\n"".join(output) + ""\n"")",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053501
1390053506,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053506
1390053500,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Prefix sums
        vector<int> prefix_1(n + 1, 0);
        vector<int> prefix_0(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
        }
        int total_1 = prefix_1[n];
        int min_cost = n;
        // Try all possible kept substrings [l, r)
        for (int l = 0; l <= n; l++) {
            // Instead of full nested loop, calculate cost directly
            // for r = n (maximum right end possible for fixed l)
            for (int r = l; r <= n; r++) {
                int kept_1 = prefix_1[r] - prefix_1[l];
                int kept_0 = prefix_0[r] - prefix_0[l];
                int removed_1 = total_1 - kept_1;
                int cost = max(removed_1, kept_0);
                if (cost < min_cost) min_cost = cost;
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053500
1390053497,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    min_total_effort = float('inf')
    for mask in range(1 << n):
        skipped = bin(mask).count('1')
        if skipped <= k:
            total_effort = 0
            for i in range(n):
                if mask & (1 << i):
                    continue
                else:
                    additional = 0
                    for j in range(i):
                        if mask & (1 << j):
                            additional += 1
                    total_effort += strengths[i] + additional
            min_total_effort = min(min_total_effort, total_effort)
    return min_total_effort
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        result = min_effort_to_breach(n, k, strengths)
        print(result)
if __name__ == ""__main__"":
    solve()",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053497
1390053499,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    min_effort = float('inf')
    for i in range(n - k + 1):
        effort = sum(firewalls[:i])
        increased_firewalls = [firewalls[j] + (j - i) for j in range(i, n)]
        effort += sum(sorted(increased_firewalls)[:n - i - k])
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053499
1390053496,unknown,unknown,unknown,"for _ in range(int(input())):
    x, y = map(int, input().split())
    arr = list(map(int, input().split()))
    res = []
    for i in range(x - y + 1):
        batch = arr[i:i + y]
        found_negative = False  
        for a in batch:
            if a < 0:
                res.append(a)
                found_negative = True
                break  
        if not found_negative:  
            res.append(0)
    print(*res) ",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053496
1390053491,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053491
1390053493,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053493
1390053495,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    if k == n:
        return 0
    if k == 0:
        return sum(firewalls)
    min_effort = float('inf')
    for i in range(n):
        skipped = 0
        effort = 0
        for j in range(n):
            if skipped < k and j >= i:
                skipped += 1
            else:
                effort += firewalls[j] + skipped
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input().strip())
results = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    results.append(min_effort(n, k, firewalls))
for res in results:
    print(res)",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053495
1390053487,unknown,unknown,unknown,"def find_earliest_faults(t, data):
    results = []
    for case in range(t):
        n, k = data[case][0]
        arr = data[case][1]
        result = []
        # Initialize the deque to store indices of negative numbers
        from collections import deque
        dq = deque()
        # Process the first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # For the first window, append the result
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Process the rest of the windows
        for i in range(k, n):
            # Remove elements that are out of this window
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add new element if it's negative
            if arr[i] < 0:
                dq.append(i)
            # Append the result for the current window
            if dq:
                result.append(arr[dq[0]])
            else:
                result.append(0)
        results.append(result)
    return results
# Test cases as described in the input format
test_cases = [
    ((5, 2), [-8, 2, 3, -6, 10]),
    ((8, 3), [12, -1, -7, 8, -15, 30, 16, 28])
]
# Number of test cases
t = len(test_cases)
# Calling the function
outputs = find_earliest_faults(t, test_cases)
for output in outputs:
    print("" "".join(map(str, output)))",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053487
1390053489,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053489
1390053490,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)  # Effort without skipping any firewalls
    min_effort = total_effort  # Start with this as the baseline
    # Compute initial sum of first 'k' firewalls
    skip_sum = sum(firewalls[:k])
    # Try skipping each block of size k
    for i in range(n - k + 1):
        # Compute the new effort
        effort = total_effort - skip_sum + (n - k)  # Remaining firewalls get +1
        # Update minimum effort
        min_effort = min(min_effort, effort)
        # Slide the window forward (if possible)
        if i + k < n:
            skip_sum = skip_sum - firewalls[i] + firewalls[i + k]
    return min_effort
# Read input
t = int(input().strip())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and max firewalls to skip
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053490
1390053484,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # If we can skip all firewalls, return 0 effort
    if k >= n:
        return 0
    # Initialize DP array: dp[j] = min effort using at most j skips
    dp = [float('inf')] * (k + 1)
    dp[0] = 0  # Base case: No firewalls, no effort
    for i in range(1, n + 1):
        # Process in **reverse order** to avoid overwriting dp[j-1]
        for j in range(min(k, i), -1, -1):  
            # Case 1: Don't skip this firewall
            if j <= i - 1:
                dp[j] = dp[j] + strengths[i-1] + j
            # Case 2: Skip this firewall (if we have skips left)
            if j > 0:
                dp[j] = min(dp[j], dp[j-1])
    return dp[k]
def solve():
    t = int(input())  # Read number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
        strengths = list(map(int, input().split()))  # Read firewall strengths
        # Special case: If we can skip all firewalls
        if k >= n:
            print(0)
        else:
            print(min_effort_to_breach(n, k, strengths))
# Run the solution
solve()",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053484
1390053478,unknown,unknown,unknown,"#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void find_earliest_faulty(int arr[], int n, int k) {
    for (int i = 0; i <= n - k; i++) {
        int earliest_faulty = 0;
        for (int j = i; j < i + k; j++) {
            if (arr[j] < 0) {
                earliest_faulty = arr[j];
                break; // First faulty component found, exit loop
            }
        }
        printf(""%d "", earliest_faulty);
    }
    printf(""\n"");
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int *arr = (int *)malloc(n * sizeof(int));
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        find_earliest_faulty(arr, n, k);
        free(arr);
    }
    return 0;
}",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053478
1390053483,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    """"""
    Finds the earliest faulty reading for each consecutive batch of size k.
    Args:
        arr: A list of sensor readings (integers).
        k: The batch size.
    Returns:
        A list of earliest faulty readings for each batch.
    """"""
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        earliest_fault = 0
        for j, reading in enumerate(batch):
            if reading < 0:
                earliest_fault = reading
                break
        result.append(earliest_fault)
    return result
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = find_earliest_faults(arr, k)
        print(*result)
solve()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053483
1390053476,unknown,unknown,unknown,"def main():
    import sys
    input = sys.stdin.read
    data = input().split(""\n"")
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        strengths = list(map(int, data[index + 1].split()))
        index += 2
        if k >= n:
            results.append(""0"")
            continue
        # Calculate the impact of each firewall: strength + index
        impact = [(strengths[i] + i, i) for i in range(n)]
        # Sort firewalls by impact (higher impact should be skipped)
        impact.sort(reverse=True)
        # Select the top k firewalls to skip
        to_skip = set(idx for _, idx in impact[:k])
        # Compute the minimal effort
        effort = 0
        skipped = 0
        for i in range(n):
            if i in to_skip:
                skipped += 1
            else:
                effort += strengths[i] + skipped
        results.append(str(effort))
    # Print all results at once (faster output handling)
    sys.stdout.write(""\n"".join(results) + ""\n"")
if __name__ == ""__main__"":
    main()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053476
1390053472,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):
        skipped_count = 0
        current_effort = 0
        current_a = a[:]
        skipped_indices = []
        for j in range(n):
            if (i >> j) & 1:
                skipped_count += 1
                skipped_indices.append(j)
        if skipped_count <= k:
            for j in range(n):
                if j in skipped_indices:
                    continue
                else:
                    offset = 0
                    for skipped_index in skipped_indices:
                        if skipped_index < j:
                            offset += 1
                    current_effort += current_a[j] + offset
            min_effort = min(min_effort, current_effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053472
1390053473,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx+1])
        idx +=2
        a = list(map(int, input[idx:idx+n]))
        idx +=n
        sum_a = sum(a)
        v = []
        for i in range(n):
            val = a[i] - (n - i -1)
            v.append(val)
        v.sort(reverse=True)
        prefix = [0] * (n+1)
        for i in range(n):
            prefix[i+1] = prefix[i] + v[i]
        max_sum = 0
        max_t = min(k, n)
        for t in range(0, max_t+1):
            current = prefix[t] + t*(t-1)//2
            if current > max_sum:
                max_sum = current
        print(sum_a - max_sum)
if __name__ == ""__main__"":
    main()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053473
1390053475,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        batch_results = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            earliest_fault = 0
            for num in batch:
                if num < 0:
                    earliest_fault = num
                    break
            batch_results.append(earliest_fault)
        results.append(batch_results)
    return results
# Input reading
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    test_cases = []
    for _ in range(t):
        n = int(data[idx])
        k = int(data[idx + 1])
        idx += 2
        arr = list(map(int, data[idx:idx + n]))
        idx += n
        test_cases.append((n, k, arr))
    # Compute results
    results = earliest_faulty_readings(test_cases)
    # Output results
    for result in results:
        print("" "".join(map(str, result)) + "" "", end="""")
    print()
if __name__ == ""__main__"":
    main()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053475
1390053466,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053466
1390053469,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_remaining = 0
            for char in remaining:
                if char == '0':
                    idle_remaining += 1
            active_removed = 0
            for char in s[:i]:
                if char == '1':
                    active_removed += 1
            for char in s[n-j:]:
                if char == '1':
                    active_removed += 1
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053469
1390053467,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active ('1') and idle ('0') servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative count of active servers from the left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible segments
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Active servers in the selected range
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed (total active - active in range)
            active_removed = total_active - active_remaining
            # Cost is max of idle servers in range or removed active servers
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active ('1') and idle ('0') servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case scenario
    # Iterate through all possible substrings efficiently
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in the selected range
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (total active - active in selected range)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            # Compute cost and update minimum
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053467
1390053463,unknown,unknown,unknown,"def min_cost_to_balance(s):
    n = len(s)
    # Step 1: Build prefix sums
    prefix0 = [0] * (n + 1)
    prefix1 = [0] * (n + 1)
    for i in range(n):
        prefix0[i + 1] = prefix0[i] + (1 if s[i] == '0' else 0)
        prefix1[i + 1] = prefix1[i] + (1 if s[i] == '1' else 0)
    # Step 2: Initialize min_cost with the case of removing everything
    min_cost = prefix1[n]
    # Step 3: Iterate over all possible a and b
    for a in range(n + 1):
        for b in range(a - 1, n):
            # Number of '0's in s[a..b]
            zeros_remaining = prefix0[b + 1] - prefix0[a] if b >= a else 0
            # Number of '1's in prefix s[0..a-1] and suffix s[b+1..n-1]
            ones_removed = prefix1[a] + (prefix1[n] - prefix1[b + 1])
            # Cost for this substring
            cost = max(zeros_remaining, ones_removed)
            # Update minimum cost
            min_cost = min(min_cost, cost)
    return min_cost
# Input handling
T = int(input())
for _ in range(T):
    s = input().strip()
    print(min_cost_to_balance(s))",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053463
1390053459,unknown,unknown,unknown,"def minimum_decommission_cost(servers):
    n = len(servers)
    # Convert the string to a list of integers (0 or 1)
    server_list = [1 if c == '1' else 0 for c in servers]
    # Precompute prefix sums
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
    min_cost = n  # Initialize to worst case
    # For each start index i
    for i in range(n + 1):
        # Total active servers removed from the left
        left_ones = prefix_sum[i]
        # For each end index j (using binary search would be ideal, but direct is OK for now)
        for j in range(i, n + 1):
            # Calculate metrics for current segment [i,j)
            segment_length = j - i
            segment_ones = prefix_sum[j] - prefix_sum[i]
            segment_zeros = segment_length - segment_ones
            # Total active servers removed from the right
            right_ones = prefix_sum[n] - prefix_sum[j]
            # Total active servers removed
            total_ones_removed = left_ones + right_ones
            cost = max(segment_zeros, total_ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def process_input():
    t = int(input().strip())
    results = []
    for _ in range(t):
        servers = input().strip()
        results.append(minimum_decommission_cost(servers))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    process_input()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053459
1390053461,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    total_active = server_rack.count('1')
    for prefix in range(n + 1):
        for suffix in range(n + 1 - prefix):
            if prefix + suffix > n:
                continue
            remaining = server_rack[prefix:n-suffix]
            if not remaining:
                cost = total_active
            else:
                idle_remaining = remaining.count('0')
                active_removed = total_active - remaining.count('1')
                cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def process_test_cases():
    t = int(input().strip())
    results = []
    for _ in range(t):
        server_rack = input().strip()
        results.append(min_decommissioning_cost(server_rack))
    return results
if __name__ == ""__main__"":
    results = process_test_cases()
    for result in results:
        print(result)",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053461
1390053462,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        # Compute a[i] + i (0-based)
        values = [a[i] + i for i in range(n)]
        # Sort in descending order
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        # Compute the result
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
if __name__ == ""__main__"":
    main()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053462
1390053456,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for n, k, arr in test_cases:
        total_effort = sum(arr)
        if k == n:
            results.append(""0"")  # If k == n, we can skip all firewalls
            continue
        # Compute the minimum effort after skipping one firewall
        min_effort = float('inf')
        for i in range(n):
            effort_with_skip = total_effort - arr[i] + k  # Remove arr[i] and add k
            min_effort = min(min_effort, effort_with_skip)
        results.append(str(min_effort))
    return ""\n"".join(results)
# Reading input
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())  # Number of firewalls and penalty
    arr = list(map(int, input().split()))  # Firewall strengths
    test_cases.append((n, k, arr))
# Output results
print(min_effort(test_cases))",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053456
1390053457,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053457
1390053458,unknown,unknown,unknown,"def minimum_pruning_cost(server_rack):
    active_count = server_rack.count('1')
    idle_count = server_rack.count('0')
    min_cost = float('inf')
    for start_servers in range(len(server_rack) + 1):
        for end_servers in range(len(server_rack) + 1 - start_servers):
            if start_servers == 0 and end_servers == 0:
                continue
            remaining = server_rack[start_servers:len(server_rack) - end_servers]
            active_decommissioned = (server_rack[:start_servers].count('1') + 
                                    server_rack[len(server_rack) - end_servers:].count('1'))
            remaining_idle = remaining.count('0')
            cost = max(remaining_idle, active_decommissioned)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    results = []
    for _ in range(t):
        server_rack = input().strip()
        results.append(minimum_pruning_cost(server_rack))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053458
1390053448,unknown,unknown,unknown,"def find_earliest_faults(arr, batch_size):
    results = []
    for i in range(len(arr) - batch_size + 1):
        batch = arr[i:i + batch_size]
        earliest_fault = next((x for x in batch if x < 0), 0)
        results.append(earliest_fault)
    return results
# Test cases
for _ in range(int(input())):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*find_earliest_faults(arr, k))",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053448
1390053449,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053449
1390053454,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        # Compute a[i] + i (0-based)
        values = [a[i] + i for i in range(n)]
        # Sort in descending order
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        # Compute the result
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
main()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053454
1390053446,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    print(*earliest_faulty_readings(arr, k))",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053446
1390053438,unknown,unknown,unknown,"def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    # Read number of test cases
    T = int(data[0])
    index = 1
    # Process each test case
    for _ in range(T):
        s = data[index]
        index += 1
        n = len(s)
        # Compute prefix sums for '0's and '1's
        prefix0 = [0] * (n + 1)  # Number of '0's up to index i
        prefix1 = [0] * (n + 1)  # Number of '1's up to index i
        for i in range(n):
            prefix0[i + 1] = prefix0[i] + (1 if s[i] == '0' else 0)
            prefix1[i + 1] = prefix1[i] + (1 if s[i] == '1' else 0)
        # Initial minimum cost: cost of removing entire string
        min_cost = prefix1[n]
        # Iterate over all possible ending indices b
        for b in range(n):
            # '0's up to b, '1's from b+1 to end
            zeros_up_to_b = prefix0[b + 1]
            ones_after_b = prefix1[n] - prefix1[b + 1]
            # Cost function for a given starting index a
            def cost(a):
                zeros_remaining = zeros_up_to_b - prefix0[a]
                ones_removed = prefix1[a] + ones_after_b
                return max(zeros_remaining, ones_removed)
            # Ternary search to find optimal a for this b
            left, right = 0, b
            while right - left > 2:
                m1 = left + (right - left) // 3
                m2 = right - (right - left) // 3
                if cost(m1) < cost(m2):
                    right = m2
                else:
                    left = m1
            # Check remaining points for minimum cost
            local_min = min(cost(a) for a in range(left, right + 1))
            min_cost = min(min_cost, local_min)
        # Output the minimum cost for this test case
        print(min_cost)
if __name__ == ""__main__"":
    main()",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053438
1390053435,unknown,unknown,unknown,"def solve():
    server_rack = input().strip()
    n = len(server_rack)
    ones_prefix = [0] * (n + 1)
    for i in range(n):
        ones_prefix[i+1] = ones_prefix[i] + (1 if server_rack[i] == '1' else 0)
    min_cost = float('inf')
    for left_remove_count in range(n + 1):
        for right_remove_count in range(n - left_remove_count + 1):
            active_removed = ones_prefix[left_remove_count] + (ones_prefix[n] - ones_prefix[n - right_remove_count])
            remaining_rack = server_rack[left_remove_count:n - right_remove_count]
            idle_remaining = 0
            for char in remaining_rack:
                if char == '0':
                    idle_remaining += 1
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
T = int(input())
for _ in range(T):
    solve()",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053435
1390053439,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] s = new int[n];
            for (int i = 0; i < n; i++) s[i] = sc.nextInt();
            System.out.println(minEffort(s, n, k));
        }
        sc.close();
    }
    private static long minEffort(int[] s, int n, int k) {
        if (k >= n) return 0;
        long[][] dp = new long[n + 1][k + 1];
        for (long[] row : dp) Arrays.fill(row, Long.MAX_VALUE / 2);
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                if (dp[i][j] == Long.MAX_VALUE / 2) continue;
                dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + s[i] + j);
                if (j < k) dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j]);
            }
        }
        long minEffort = Long.MAX_VALUE;
        for (int j = 0; j <= k; j++) minEffort = Math.min(minEffort, dp[n][j]);
        return minEffort;
    }
}",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053439
1390053431,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053431
1390053432,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053432
1390053424,unknown,unknown,unknown,"def min_effort(firewalls, n, k):
    if k >= n:
        return 0
    indexed_firewalls = [(i, firewalls[i]) for i in range(n)]
    indexed_firewalls.sort(key=lambda x: x[1], reverse=True)
    skip = [False] * n
    for i in range(k):
        skip[indexed_firewalls[i][0]] = True
    total_effort = 0
    skipped_count = 0
    for i in range(n):
        if skip[i]:
            skipped_count += 1
        else:
            total_effort += firewalls[i] + skipped_count
    return total_effort
if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().split('\n')
    t = int(data[0])
    index = 1
    results = []
    for _ in range(t):
        n, k = map(int, data[index].split())
        firewalls = list(map(int, data[index + 1].split()))
        results.append(str(min_effort(firewalls, n, k)))
        index += 2
    print(""\n"".join(results))",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053424
1390053428,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053428
1390053427,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053427
1390053423,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    if k == n:
        return 0
    if k == 0:
        return sum(firewalls)
    min_effort = float('inf')
    for i in range(n):
        skipped = 0
        effort = 0
        for j in range(n):
            if skipped < k and j >= i:
                skipped += 1
            else:
                effort += firewalls[j] + skipped
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input().strip())
results = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    results.append(min_effort(n, k, firewalls))
for res in results:
    print(res)",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053423
1390053416,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for case in test_cases:
        n = len(case)
        min_cost = float('inf')
        # Precompute prefix sums for 0's and 1's
        prefix_0 = [0] * (n + 1)
        prefix_1 = [0] * (n + 1)
        for i in range(n):
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
        # Iterate through all possible splits
        for i in range(n + 1):
            for j in range(i, n + 1):
                # Remaining segment is from i to j-1
                remaining_0s = prefix_0[j] - prefix_0[i]
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
                cost = max(remaining_0s, removed_1s)
                if cost < min_cost:
                    min_cost = cost
        results.append(min_cost)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_decommission_cost(test_cases)
# Print output
for result in results:
    print(result)",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053416
1390053422,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minEffort(int[] firewalls, int k) {
        int n = firewalls.length;
        if (k >= n) return 0;
        int[][] dp = new int[n + 1][k + 1];
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= k; j++) {
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
                if (dp[i + 1][j] != Integer.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], firewalls[i] + j + dp[i + 1][j]);
                }
            }
        }
        return dp[0][0];
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minEffort(firewalls, k));
        }
        sc.close();
    }
}",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053422
1390053419,unknown,unknown,unknown,"def min_decommission_cost(binary_str):
    binary_str = binary_str.strip('0')
    if not binary_str:
        return 0  
    total_zeros = binary_str.count('0')
    min_cost = total_zeros  
    removed_ones = 0
    for ch in binary_str:
        if ch == '1':
            removed_ones += 1
        else:
            total_zeros -= 1  
        min_cost = min(min_cost, max(total_zeros, removed_ones))
    return min_cost
T = int(input())
for _ in range(T):
    binary_str = input().strip()
    print(min_decommission_cost(binary_str))",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053419
1390053412,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active ('1') and idle ('0') servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative count of active servers from the left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible segments
    for left in range(n + 1):
        for right in range(left, n + 1):
            # Active servers in the selected range
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed (total active - active in range)
            active_removed = total_active - active_remaining
            # Cost is max of idle servers in range or removed active servers
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active ('1') and idle ('0') servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case scenario
    # Iterate through all possible substrings efficiently
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in the selected range
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (total active - active in selected range)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            # Compute cost and update minimum
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053412
1390053411,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of faulty readings (negative values)
    for i in range(n):
        # Remove indices that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element's index if it's a negative value (faulty)
        if arr[i] < 0:
            dq.append(i)
        # If the window is large enough (i >= k - 1), we check the result
        if i >= k - 1:
            if dq:
                result.append(arr[dq[0]])  # The earliest faulty reading in the window
            else:
                result.append(0)  # No faulty reading in this window
    return result
def process_test_cases():
    t = int(input())  # number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # size of array and batch size
        arr = list(map(int, input().split()))  # the array of sensor readings
        result = earliest_faulty_reading(arr, k)
        print(' '.join(map(str, result)))
# Call the function to process test cases
process_test_cases()",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053411
1390053414,unknown,unknown,unknown,"def find_earliest_faults(arr, n, k):
    result = []
    for i in range(n - k + 1):
        window = arr[i:i + k]
        fault = next((num for num in window if num < 0), 0)
        result.append(fault)
    print(*result)
for _ in range(int(input().strip())):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    find_earliest_faults(arr, n, k)",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053414
1390053404,unknown,unknown,unknown,"import java.util.*;
public class FirewallMinEffort {
    public static long minEffort(int[] firewalls, int n, int k) {
        // If we can skip all firewalls, return 0
        if (k >= n) return 0;
        // Create a list of pairs (index, strength)
        List<int[]> indexedFirewalls = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            indexedFirewalls.add(new int[]{i, firewalls[i]});
        }
        // Sort by strength to find the k strongest firewalls to skip
        indexedFirewalls.sort((a, b) -> Integer.compare(b[1], a[1]));
        // Mark which firewalls to skip
        boolean[] skip = new boolean[n];
        for (int i = 0; i < k; i++) {
            skip[indexedFirewalls.get(i)[0]] = true;
        }
        // Calculate the total effort
        long totalEffort = 0;
        int skippedCount = 0;
        for (int i = 0; i < n; i++) {
            if (skip[i]) {
                skippedCount++;
            } else {
                totalEffort += firewalls[i] + skippedCount;
            }
        }
        return totalEffort;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Number of firewalls
            int k = sc.nextInt(); // Firewalls to skip
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minEffort(firewalls, n, k));
        }
        sc.close();
    }
}",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053404
1390053406,unknown,unknown,unknown,"def min_firewall_effort(n, k, firewalls):
    """"""
    Calculates the minimum effort needed to breach the network.
    Args:
        n: The number of firewalls.
        k: The maximum number of firewalls that can be skipped.
        firewalls: A list of firewall strengths.
    Returns:
        The minimum effort needed.
    """"""
    min_effort = float('inf')
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
        skipped_count = bin(i).count('1')
        if skipped_count <= k:
            current_effort = 0
            skipped = 0
            current_firewalls = firewalls[:]  # Create a copy to avoid modifying the original list
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            skipped_indices.sort()
            j = 0
            for index in skipped_indices:
                for l in range(index+1,n):
                    current_firewalls[l] +=1
            for j in range(n):
                if (i >> j) & 1:
                    continue
                else:
                    current_effort += current_firewalls[j]
            min_effort = min(min_effort, current_effort)
    return min_effort
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        result = min_firewall_effort(n, k, firewalls)
        print(result)",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053406
1390053410,unknown,unknown,unknown,"from collections import deque
def first_negative_in_batches(a, b):
    c = []
    d = deque()
    for i in range(b):
        if a[i] < 0:
            d.append(i)
    for i in range(b, len(a) + 1):
        c.append(a[d[0]] if d else 0)
        while d and d[0] < i - b + 1:
            d.popleft()
        if i < len(a) and a[i] < 0:
            d.append(i)
    return c
a = int(input())
for _ in range(a):
    b, c = map(int, input().split())
    d = list(map(int, input().split()))
    print(*first_negative_in_batches(d, c))",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053410
1390053403,unknown,unknown,unknown,"for _ in range(int(input())):
    x,y = map(int,input().split())
    arr = list(map(int,input().split()))
    res = []
    for i in range(x-y+1):
        batch = arr[i:i+y]
        for a in batch:
            if a<0:
                res.append(a)
                break
            elif a>=0 and a == batch[-1]: 
                res.append(0)
    for i in res:
        print(i, end = ' ')
    print()
            ",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053403
1390053396,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first k elements
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    # Compute and print results
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053396
1390053397,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove elements not part of the current batch
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # If current element is faulty, add its index to deque
        if arr[i] < 0:
            dq.append(i)
        # Add the first faulty element of the batch to result
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
if __name__ == ""__main__"":
    main()",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053397
1390053401,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
long long minEffort(vector<int>& firewalls, int n, int k) {
    // If we can skip all firewalls, return 0
    if (k >= n) return 0;
    // Create a vector of pairs (index, strength)
    vector<pair<int, int>> indexedFirewalls(n);
    for (int i = 0; i < n; i++) {
        indexedFirewalls[i] = {i, firewalls[i]};
    }
    // Sort by strength to find the k strongest firewalls to skip
    sort(indexedFirewalls.begin(), indexedFirewalls.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second;
    });
    // Mark which firewalls to skip
    vector<bool> skip(n, false);
    for (int i = 0; i < k; i++) {
        skip[indexedFirewalls[i].first] = true;
    }
    // Calculate the total effort
    long long totalEffort = 0;
    int skippedCount = 0;
    for (int i = 0; i < n; i++) {
        if (skip[i]) {
            skippedCount++;
        } else {
            totalEffort += firewalls[i] + skippedCount;
        }
    }
    return totalEffort;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; i++) {
            cin >> firewalls[i];
        }
        cout << minEffort(firewalls, n, k) << endl;
    }
    return 0;
}",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053401
1390053391,unknown,unknown,unknown,"def earliest_faulty_in_batches(arr, n, k):
    result = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        found_fault = False 
        for num in batch:
            if num < 0:
                result.append(num)
                found_fault = True
                break
        if not found_fault:
            result.append(0)
    return result
t= int(input().strip())
outputs = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    outputs.append(earliest_faulty_in_batches(arr, n, k))
for output in outputs:
    print("" "".join(map(str, output)))",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053391
1390053392,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    for (int i = k; i <= n; i++) {
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  
        else 
            result.push_back(0);  
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  
    while (t--) {
        int n, k;
        cin >> n >> k;  
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053392
1390053394,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())  # Read n (firewalls) and k (skips)
        effort = list(map(int, input().split()))  # Read effort values
        if k == n:  # If we skip all firewalls, effort is 0
            results.append(""0"")
            continue
        total_effort = sum(effort)  # Sum of all firewall efforts
        min_effort_value = total_effort  # Initialize with the maximum possible effort
        # Try skipping each firewall one by one and compute the new effort
        for i in range(n):
            new_effort = total_effort - effort[i]  # Remove effort[i] from the sum
            if i > 0:
                new_effort += 1  # Increase effort for all remaining firewalls
            min_effort_value = min(min_effort_value, new_effort)  # Update minimum effort
        results.append(str(min_effort_value))  # Store the result for this test case
    print(""\n"".join(results))  # Print results ef
T = int(input())  # Number of test cases
min_effort(T)",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053394
1390053387,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static long minDecommissionCost(String s) {
        int n = s.length();
        if (n == 0) return 0;
        long[] preOnes = new long[n + 1], preZeros = new long[n + 1];
        long[] sufOnes = new long[n + 1], sufZeros = new long[n + 1];
        for (int i = 0; i < n; i++) {
            preOnes[i + 1] = preOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
            preZeros[i + 1] = preZeros[i] + (s.charAt(i) == '0' ? 1 : 0);
        }
        for (int i = n - 1; i >= 0; i--) {
            sufOnes[i] = sufOnes[i + 1] + (s.charAt(i) == '1' ? 1 : 0);
            sufZeros[i] = sufZeros[i + 1] + (s.charAt(i) == '0' ? 1 : 0);
        }
        long minCost = Long.MAX_VALUE;
        for (int l = 0; l <= n; l++) {
            for (int r = l - 1; r < n; r++) {
                long decomm1s = (r < l) ? preOnes[n] : preOnes[l] + sufOnes[r + 1];
                long rem0s = (r < l) ? 0 : preZeros[r + 1] - preZeros[l];
                minCost = Math.min(minCost, Math.max(rem0s, decomm1s));
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        sc.nextLine();
        while (t-- > 0) System.out.println(minDecommissionCost(sc.nextLine().trim()));
        sc.close();
    }
}",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053387
1390053388,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.size();
        // Total 1s and 0s
        vector<int> prefix_1(n + 1, 0);
        vector<int> prefix_0(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
        }
        int total_1 = prefix_1[n];
        int total_0 = prefix_0[n];
        int min_cost = n;
        // Try all possible pairs of (left_removal = l, right_removal = r)
        // Keep substring from index l to r-1 inclusive
        for (int l = 0; l <= n; l++) {
            // Binary search on r (right removal count), so that l + r <= n
            for (int r = 0; r <= n - l; r++) {
                int start = l;
                int end = n - r;
                int kept_1 = prefix_1[end] - prefix_1[start];
                int kept_0 = prefix_0[end] - prefix_0[start];
                int removed_1 = total_1 - kept_1;
                int remaining_0 = kept_0;
                int cost = max(removed_1, remaining_0);
                min_cost = min(min_cost, cost);
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053388
1390053389,unknown,unknown,unknown,"def min_effort(arr, k):
    n = len(arr)
    total = sum(arr)
    # Consider not skipping any firewall as an option
    min_cost = total  
    # Try skipping every contiguous block of size k
    for i in range(n - k + 1):
        skipped_sum = sum(arr[i:i+k])
        penalty = n - (i + k)  # extra cost for each firewall after the skipped block
        cost = total - skipped_sum + penalty
        min_cost = min(min_cost, cost)
    return min_cost
# Input handling
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(min_effort(arr, k))",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053389
1390053379,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053379
1390053374,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        # Precompute prefix counts of '1's
        prefix_ones = [0] * (n + 1)
        for i in range(n):
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
        # Precompute suffix counts of '1's
        suffix_ones = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
        # Precompute the number of '0's in the entire string
        total_zeros = s.count('0')
        min_cost_val = float('inf')
        # Iterate over all possible left decommissioning points
        for left in range(n + 1):
            # Calculate the number of '1's removed from the left
            ones_removed_left = prefix_ones[left]
            low = 0
            high = n - left
            best_right = 0
            best_cost = float('inf')
            while low <= high:
                mid = (low + high) // 2
                right = mid
                ones_removed_right = suffix_ones[n - right]
                total_ones_removed = ones_removed_left + ones_removed_right
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
                current_cost = max(zeros_remaining, total_ones_removed)
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_right = right
                if zeros_remaining > total_ones_removed:
                    low = mid + 1
                else:
                    high = mid - 1
            if best_cost < min_cost_val:
                min_cost_val = best_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053374
1390053376,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_remaining = remaining.count('0')
            active_removed = s[:i].count('1') + s[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053376
1390053377,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053377
1390053363,unknown,unknown,unknown,"def min_decommission_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(i, n + 1):
            remaining = server_rack[i:j]
            cost = max(remaining.count('0'), server_rack[:i].count('1') + server_rack[j:].count('1'))
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    T = int(input().strip())
    for _ in range(T):
        server_rack = input().strip()
        print(min_decommission_cost(server_rack))
if __name__ == ""__main__"":
    main()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053363
1390053366,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        res = []
        negatives = []
        for i in range(k):
            if arr[i] < 0:
                negatives.append(i)
        res.append(arr[negatives[0]] if negatives else 0)
        for i in range(k, n):
            if negatives and negatives[0] < i - k + 1:
                negatives.pop(0)
            if arr[i] < 0:
                negatives.append(i)
            res.append(arr[negatives[0]] if negatives else 0)
        results.append("" "".join(map(str, res)))
    return ""\n"".join(results)
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
print(earliest_faulty_readings(test_cases))",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053366
1390053365,unknown,unknown,unknown,"test_cases = int(input())
for t in range(test_cases):
    a,b = list(map(int,input().split("" "")))
    arr = list(map(int,input().split("" "")))
    l,r = 0,b-1
    res = []
    neg_index = 0
    while r<a:
        temp = None
        for i in range(l,r+1):
            if arr[i]<0:
                temp = arr[i]
                break
        if temp:
            res.append(temp)
        else:
            res.append(0)
        l+=1
        r+=1
    for i in res:
        print(i,end="" "")
    print()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053365
1390053358,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommission {
    public static int minCostDecommissioning(String rack) {
        int n = rack.length();
        int totalOnes = 0;
        // Count total number of 1's in the rack
        for (char c : rack.toCharArray()) {
            if (c == '1') {
                totalOnes++;
            }
        }
        int minCost = Integer.MAX_VALUE;
        // Try all possible removals from left and right
        for (int left = 0; left <= n; left++) {
            for (int right = 0; right <= n - left; right++) {
                String remaining = rack.substring(left, n - right);
                int remainingZeros = 0, remainingOnes = 0;
                for (char c : remaining.toCharArray()) {
                    if (c == '0') {
                        remainingZeros++;
                    } else {
                        remainingOnes++;
                    }
                }
                int removedOnes = totalOnes - remainingOnes;
                int cost = Math.max(remainingZeros, removedOnes);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        for (int i = 0; i < T; i++) {
            String rack = scanner.nextLine();
            System.out.println(minCostDecommissioning(rack));
        }
        scanner.close();
    }
}",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053358
1390053359,unknown,unknown,unknown,"def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        # Edge case: if we can skip all firewalls
        if k >= n:
            print(0)
            continue
        # For small test cases, use brute force
        if n <= 20:
            min_effort = float('inf')
            # Try all possible combinations of firewalls to skip
            for mask in range(1 << n):
                if bin(mask).count('1') <= k:
                    effort = 0
                    skipped = 0
                    for i in range(n):
                        if (mask >> i) & 1:
                            skipped += 1
                        else:
                            effort += strengths[i] + skipped
                    min_effort = min(min_effort, effort)
            print(min_effort)
            continue
        # For larger test cases, use a more efficient approach
        # Calculate the benefit array
        benefits = []
        for i in range(n):
            benefits.append((strengths[i] - (n - i - 1), i))
        # Sort by benefit
        benefits.sort(reverse=True)
        # Try skipping different numbers of firewalls
        min_effort = float('inf')
        for skips in range(k + 1):
            to_skip = set()
            # Take the top 'skips' firewalls with highest benefit
            for i in range(skips):
                if i < len(benefits):
                    to_skip.add(benefits[i][1])
            # Calculate the effort
            effort = 0
            skipped = 0
            for i in range(n):
                if i in to_skip:
                    skipped += 1
                else:
                    effort += strengths[i] + skipped
            min_effort = min(min_effort, effort)
        print(min_effort)
if __name__ == ""__main__"":
    main()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053359
1390053361,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053361
1390053356,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # Initialize dp array with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        firewall_idx = i - 1  # Convert to 0-indexed
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            if j <= i - 1:  # Ensure we have processed enough firewalls
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
            # Option 2: Skip the current firewall
            if j > 0:  # We must have at least one skip available
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Return the minimum effort after processing all firewalls
    return dp[n][k]
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053356
1390053351,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first window of size k
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the new element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input().strip())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Read n and k
        arr = list(map(int, input().split()))  # Read array elements
        # Get the earliest faulty readings
        output = earliest_faulty_readings(arr, k)
        # Print result as space-separated values
        print("" "".join(map(str, output)))
if __name__ == ""__main__"":
    main()",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053351
1390053353,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for n, k, arr in test_cases:
        total_effort = sum(arr)
        if k == n:
            results.append(""0"")  
            continue
        min_effort = total_effort 
        for i in range(n):
            effort_with_skip = (total_effort - arr[i]) + k
            min_effort = min(min_effort, effort_with_skip)
        results.append(str(min_effort))
    return ""\n"".join(results)
t = int(input())  
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    test_cases.append((n, k, arr))
print(min_effort(test_cases))",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053353
1390053354,unknown,unknown,unknown,"def min_effort(n, k, arr):
    total_effort = sum(arr)  # Compute the total effort without skipping any firewall
    min_effort = total_effort  # Initialize minimum effort
    if len(arr)==k:
        return 0
    # Try skipping each firewall
    for i in range(n):
        effort = total_effort - arr[i] + k  # Skip the i-th firewall and add k penalty
        min_effort = min(min_effort, effort)  # Keep track of the minimum
    return min_effort
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(min_effort(n, k, arr))",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053354
1390053339,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053339
1390053344,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
long long minEffort(vector<int>& firewalls, int n, int k) {
    // If we can skip all firewalls, return 0
    if (k >= n) return 0;
    // Create a vector of pairs (index, strength)
    vector<pair<int, int>> indexedFirewalls(n);
    for (int i = 0; i < n; i++) {
        indexedFirewalls[i] = {i, firewalls[i]};
    }
    // Sort by strength to find the k strongest firewalls to skip
    sort(indexedFirewalls.begin(), indexedFirewalls.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second;
    });
    // Mark which firewalls to skip
    vector<bool> skip(n, false);
    for (int i = 0; i < k; i++) {
        skip[indexedFirewalls[i].first] = true;
    }
    // Calculate the total effort
    long long totalEffort = 0;
    int skippedCount = 0;
    for (int i = 0; i < n; i++) {
        if (skip[i]) {
            skippedCount++;
        } else {
            totalEffort += firewalls[i] + skippedCount;
        }
    }
    return totalEffort;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; i++) {
            cin >> firewalls[i];
        }
        cout << minEffort(firewalls, n, k) << endl;
    }
    return 0;
}",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053344
1390053349,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053349
1390053333,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [float('inf')] * (k + 1)
    dp[0] = 0
    for i in range(n):
        new_dp = [float('inf')]*(k+1)
        for s in range(k+1):
            if s>0:
                new_dp[s] = min(new_dp[s],dp[s - 1])
            new_dp[s] = min(new_dp[s], dp[s] + a[i] + s)
        dp = new_dp
    print(min(dp))",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053333
1390053334,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            String rack = sc.next();
            int n = rack.length();
            int[] prefixZero = new int[n + 1];
            int[] prefixOne = new int[n + 1];
            // Build prefix sums
            for (int i = 0; i < n; i++) {
                prefixZero[i + 1] = prefixZero[i] + (rack.charAt(i) == '0' ? 1 : 0);
                prefixOne[i + 1] = prefixOne[i] + (rack.charAt(i) == '1' ? 1 : 0);
            }
            int totalOnes = prefixOne[n];
            int totalZeros = prefixZero[n];
            int minCost = totalOnes; // If we remove nothing, A = 0, I = totalZeros
            // If all are zeros, we can remove everything from the beginning
            if (totalOnes == 0) {
                System.out.println(0);
                continue;
            }
            // Try all possible left starting points
            for (int i = 1; i <= n; i++) {
                int onesInPrefix = prefixOne[i];
                int zerosBefore = prefixZero[i];
                // Try all possible right ending points
                for (int j = 0; j <= n - i; j++) {
                    int onesInSuffix = prefixOne[n] - prefixOne[n - j];
                    int zerosInSuffix = prefixZero[n] - prefixZero[n - j];
                    int idleRemaining = totalZeros - zerosBefore - zerosInSuffix;
                    int activeDecommissioned = onesInPrefix + onesInSuffix;
                    int cost = Math.max(idleRemaining, activeDecommissioned);
                    minCost = Math.min(minCost, cost);
                    // Early termination: if activeDecommissioned >= minCost, no need to check larger suffixes
                    if (activeDecommissioned >= minCost) break;
                }
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053334
1390053337,unknown,unknown,unknown,"for _ in range(int(input())):
    x,y = map(int,input().split())
    arr = list(map(int,input().split()))
    res = []
    for i in range(x-y+1):
        batch = arr[i:i+y]
        for a in batch:
            if a<=0:
                res.append(a)
                break
            elif a>0 and a == batch[-1]: 
                res.append(0)
    for i in res:
        print(i, end = ' ')
    print()
            ",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053337
1390053332,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_remaining = remaining.count('0')
            active_removed = s[:i].count('1') + s[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053332
1390053322,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
            long minEffort = Long.MAX_VALUE;
            // Case when skipping 0 to k firewalls
            if (k >= n) {
                // Skip all firewalls
                System.out.println(0);
                continue;
            }
            // Try all combinations where we skip up to k firewalls
            // For k=1, try skipping each firewall one by one
            // General approach:
            boolean[] skip = new boolean[n];
            // Priority Queue to skip k largest firewalls
            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
            for (int i = 0; i < n; i++) {
                pq.add(new int[]{arr[i], i});
            }
            for (int s = 0; s <= k; s++) {
                Arrays.fill(skip, false);
                PriorityQueue<int[]> temp = new PriorityQueue<>(pq);
                // Skip 's' largest firewalls
                for (int j = 0; j < s; j++) {
                    int[] top = temp.poll();
                    skip[top[1]] = true;
                }
                long effort = 0;
                int skipped = 0;
                for (int i = 0; i < n; i++) {
                    if (skip[i]) {
                        skipped++;
                    } else {
                        effort += arr[i] + skipped;
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
            System.out.println(minEffort);
        }
        sc.close();
    }
}",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053322
1390053326,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining_s = s[i:n - j]
            idle_count = remaining_s.count('0')
            active_removed = s[:i].count('1') + s[n - j:].count('1')
            cost = max(idle_count, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053326
1390053327,unknown,unknown,unknown,"def min_decommissioning_cost(server_rack):
    n = len(server_rack)
    # Initialize counters
    min_cost = float('inf')
    # Try all possible combinations of removing prefix and suffix
    for i in range(n + 1):  # i = length of prefix to remove
        for j in range(n + 1 - i):  # j = length of suffix to remove
            if i + j > n:
                continue
            # Calculate what's left after removing prefix and suffix
            remaining = server_rack[i:n-j]
            if not remaining:
                continue  # Cannot remove all servers
            # Count idle servers remaining and active servers removed
            idle_remaining = remaining.count('0')
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
            # Cost is the maximum of these two
            cost = max(idle_remaining, active_removed)
            # Update min_cost if this is better
            min_cost = min(min_cost, cost)
    return min_cost
# Process input
t = int(input())
results = []
for _ in range(t):
    server_rack = input().strip()
    results.append(min_decommissioning_cost(server_rack))
# Output results
for result in results:
    print(result)",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053327
1390053317,unknown,unknown,unknown,"def solve():
    server_rack = input().strip()
    n = len(server_rack)
    min_cost = float('inf')
    for left_remove_count in range(n + 1):
        for right_remove_count in range(n - left_remove_count + 1):
            removed_prefix = server_rack[:left_remove_count]
            removed_suffix = server_rack[n - right_remove_count:]
            remaining_rack = server_rack[left_remove_count:n - right_remove_count]
            idle_remaining = remaining_rack.count('0')
            active_removed = removed_prefix.count('1') + removed_suffix.count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
T = int(input())
for _ in range(T):
    solve()",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053317
1390053320,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minEffort(int[] firewalls, int k) {
        int n = firewalls.length;
        if (k >= n) return 0;
        int[][] dp = new int[n + 1][k + 1];
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= k; j++) {
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
                int effort = firewalls[i] + j;
                dp[i][j] = Math.min(dp[i][j], effort + dp[i + 1][j]);
            }
        }
        return dp[0][0];
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] firewalls = new int[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = sc.nextInt();
            }
            System.out.println(minEffort(firewalls, k));
        }
        sc.close();
    }
}",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053320
1390053318,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053318
1390053313,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053313
1390053314,unknown,unknown,unknown,"from collections import deque
def find_earliest_faults(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()  # Store indices of negative elements
        res = []
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store result for first window
        res.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements not in the current window
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add new element if it's negative
            if arr[i] < 0:
                dq.append(i)
            # Store result for this batch
            res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    return results
# Read input
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    test_cases.append((n, k, arr))
# Processing and printing output
for result in find_earliest_faults(test_cases):
    print(result)",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053314
1390053312,unknown,unknown,unknown,"def earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        for num in arr[i:i+k]:
            if num < 0:
                result.append(num)
                break
        else:
            result.append(0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_fault(arr, k))",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053312
1390053311,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053311
1390053308,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053308
1390053305,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s;
        int n = s.size();
        // Step 1: Build prefix sums
        vector<int> prefix0(n + 1, 0);
        vector<int> prefix1(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i + 1] = prefix0[i] + (s[i] == '0' ? 1 : 0);
            prefix1[i + 1] = prefix1[i] + (s[i] == '1' ? 1 : 0);
        }
        // Step 2: Initialize min_cost with the case of removing everything
        int min_cost = prefix1[n];
        // Step 3: Iterate over all possible a and b
        for (int a = 0; a <= n; a++) {
            for (int b = a - 1; b < n; b++) {
                // Number of '0's in s[a..b]
                int zeros_remaining = (b >= a) ? prefix0[b + 1] - prefix0[a] : 0;
                // Number of '1's in prefix s[0..a-1] and suffix s[b+1..n-1]
                int ones_removed = prefix1[a] + (prefix1[n] - prefix1[b + 1]);
                // Cost for this substring
                int cost = max(zeros_remaining, ones_removed);
                // Update minimum cost
                min_cost = min(min_cost, cost);
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053305
1390053310,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # If we can skip all firewalls, no effort is needed
    if k >= n:
        return 0
    # Initialize DP array: dp[i][j] -> min effort to breach first i firewalls with j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: No firewalls, no effort needed
    for j in range(k + 1):
        dp[0][j] = 0  # If no firewalls exist, effort is zero
    for i in range(1, n + 1):
        for j in range(min(k, i) + 1):  # Ensure j never exceeds i
            # Case 1: Don't skip current firewall
            if j <= i - 1:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
            # Case 2: Skip current firewall (only if skips are available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return dp[n][k]
def solve():
    t = int(input())  # Read number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
        strengths = list(map(int, input().split()))  # Read firewall strengths
        # Special case: If we can skip all firewalls
        if k >= n:
            print(0)
        else:
            print(min_effort_to_breach(n, k, strengths))
# Run the solution
solve()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053310
1390053300,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    # Iterate through all possible combinations of firewalls to skip
    for i in range(1 << n):
        skipped_count = bin(i).count('1')  # Count the number of set bits (skipped firewalls)
        if skipped_count <= k:
            effort = 0
            skip_count_so_far = 0
            for j in range(n):
                if (i >> j) & 1:  # Check if the j-th firewall is skipped
                    skip_count_so_far += 1
                else:
                    effort += a[j] + skip_count_so_far  # Add the cost of the firewall + increased security
            min_effort = min(min_effort, effort)
    print(min_effort)
t = int(input())
for _ in range(t):
    solve()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053300
1390053302,unknown,unknown,unknown,"def solution():
    m = int(input())
    for _ in range(m):
        s = input() 
        n = len(s)
        ans = float('inf')
        for i in range(n+1):
            for j in range(n-i+1):
                temp = s[i:n-j]
                count = temp.count('0')
                removed = s[:i].count('1')+ s[n-j:].count('1')
                ans = min(ans,max(count,removed))
        print(ans)
solution()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053302
1390053304,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    """"""
    Calculate minimum effort to breach n firewalls with optimal strategy.
    Args:
        n: Number of firewalls
        k: Maximum number of firewalls that can be skipped
        firewalls: List of firewall strengths
    Returns:
        Minimum effort required
    """"""
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # Initialize dp array with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        firewall_idx = i - 1  # Convert to 0-indexed
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            if j <= i - 1:  # Ensure we have processed enough firewalls
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
            # Option 2: Skip the current firewall
            if j > 0:  # We must have at least one skip available
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Return the minimum effort after processing all firewalls
    return dp[n][k]
def main():
    t = int(input())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        min_effort = min_effort_to_breach(n, k, firewalls)
        print(min_effort)
if __name__ == ""__main__"":
    main()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053304
1390053290,unknown,unknown,unknown,"from collections import deque
import sys
def faults(arr, n, k):
    result = []
    dq = deque()  
    for i in range(n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def test_cases():
    t = int(sys.stdin.readline().strip())  
    results = []
    for _ in range(t):
        n, k = map(int, sys.stdin.readline().strip().split())  
        arr = list(map(int, sys.stdin.readline().strip().split()))  
        results.append("" "".join(map(str,faults(arr, n, k))))  
    print(""\n"".join(results))  
if __name__ == ""__main__"":
    test_cases()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053290
1390053291,unknown,unknown,unknown,"def minimum_decommission_cost(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    for prefix in range(n + 1):
        for suffix in range(n + 1 - prefix):
            if prefix + suffix > n:
                continue
            prefix_active = server_rack[:prefix].count('1')
            suffix_active = server_rack[n-suffix:].count('1')
            total_active_removed = prefix_active + suffix_active
            remaining_idle = server_rack[prefix:n-suffix].count('0')
            cost = max(remaining_idle, total_active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve_test_cases():
    t = int(input().strip())
    results = []
    for _ in range(t):
        server_rack = input().strip()
        results.append(minimum_decommission_cost(server_rack))
    return results
results = solve_test_cases()
for result in results:
    print(result)",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053291
1390053298,unknown,unknown,unknown,"for _ in range(int(input())):
    x,y = map(int,input().split())
    arr = list(map(int,input().split()))
    res = []
    for i in range(x-y+1):
        batch = arr[i:i+y]
        for a in batch:
            if a<0:
                res.append(a)
                break
            elif a>=0 and a == batch[-1]: 
                res.append(0)
    for i in res:
        print(i, end = ' ')
    print()
            ",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053298
1390053286,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0 
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    return min(dp[n])
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053286
1390053280,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053280
1390053284,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string servers;
        cin >> servers;
        int n = servers.size();
        int total_1 = count(servers.begin(), servers.end(), '1');
        int total_0 = n - total_1;
        int min_cost = n;  // Initialize to the maximum possible value
        // Try all possible ways of removing from the front (i) and from the back (j)
        for (int i = 0; i <= n; ++i) {
            int count_1_removed = 0;
            int count_0_remaining = total_0;
            // Count the number of 1's and 0's removed from the front
            for (int k = 0; k < i; ++k) {
                if (servers[k] == '1') {
                    count_1_removed++;
                } else {
                    count_0_remaining--;
                }
            }
            for (int j = 0; j <= n - i; ++j) {
                // Count the number of 1's and 0's removed from the back
                int count_1_removed_after_back = count_1_removed;
                int count_0_remaining_after_back = count_0_remaining;
                if (j > 0) {
                    if (servers[n - j] == '1') {
                        count_1_removed_after_back++;
                    } else {
                        count_0_remaining_after_back--;
                    }
                }
                // Compute the cost as max of (1's removed) and (0's remaining)
                min_cost = min(min_cost, max(count_1_removed_after_back, count_0_remaining_after_back));
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053284
1390053285,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        values = [a[i] + i for i in range(n)]
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
if _name_ == ""_main_"":
    main()",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053285
1390053268,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            temp = s[i:n - j]
            idle = temp.count('0')
            active = s[:i].count('1') + s[n - j:].count('1')
            ans = min(ans, max(idle, active))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053268
1390053272,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())  # Read n (firewalls) and k (skips)
        effort = list(map(int, input().split()))  # Read effort values
        if k == n:  # If we skip all firewalls, effort is 0
            results.append(""0"")
            continue
        total_effort = sum(effort)  # Sum of all firewall efforts
        min_effort_value = total_effort  # Initialize with the maximum possible effort
        # Try skipping each firewall one by one and compute the new effort
        for i in range(n):
            new_effort = total_effort - effort[i]  # Remove effort[i] from the sum
            if i > 0:
                new_effort += 1  # Increase effort for all remaining firewalls
            min_effort_value = min(min_effort_value, new_effort)  # Update minimum effort
        results.append(str(min_effort_value))  # Store the result for this test case
    print(""\n"".join(results))  # Print results efficiently
# Driver Code
T = int(input())  # Number of test cases
min_effort(T)",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053272
1390053278,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
            long[] prev = new long[k + 2];
            Arrays.fill(prev, Long.MAX_VALUE);
            prev[0] = 0;
            for (int i = 0; i < n; i++) {
                long[] curr = new long[k + 2];
                Arrays.fill(curr, Long.MAX_VALUE);
                for (int j = 0; j <= k; j++) {
                    if (prev[j] == Long.MAX_VALUE) continue;
                    // Option 1: Pay effort
                    curr[j] = Math.min(curr[j], prev[j] + arr[i] + j);
                    // Option 2: Skip (if skips left)
                    if (j + 1 <= k)
                        curr[j + 1] = Math.min(curr[j + 1], prev[j]);
                }
                prev = curr;
            }
            long result = Long.MAX_VALUE;
            for (int j = 0; j <= k; j++) result = Math.min(result, prev[j]);
            System.out.println(result);
        }
        sc.close();
    }
}",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053278
1390053262,unknown,unknown,unknown,"        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053262
1390053263,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process first k elements (first window)
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process rest of the array
    for i in range(n - k + 1):
        # Add earliest faulty reading or 0 if none
        result.append(arr[dq[0]] if dq else 0)
        # Remove elements out of the window
        if dq and dq[0] == i:
            dq.popleft()
        # Add new element to the window
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input().strip())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053263
1390053265,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # Calculate the impact of skipping each firewall
    impacts = []
    for i in range(n):
        impact = strengths[i] - (n - i - 1)  # Firewall strength minus penalty
        impacts.append((impact, i))  # Store impact and index
    # Sort by impact in descending order
    impacts.sort(reverse=True, key=lambda x: x[0])
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            penalty += 1  # Skipping imposes a penalty
        else:
            total_effort += strengths[i] + penalty  # Apply penalty to effort
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
if __name__ == ""__main__"":  # Fixed Typo
    results = solve_test_cases()
    for result in results:
        print(result)",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053265
1390053261,unknown,unknown,unknown,"def find_earliest_faults(t, data):
    results = []
    for case in range(t):
        n, k = data[case][0]
        arr = data[case][1]
        result = []
        from collections import deque
        dq = deque()
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        for i in range(k, n):
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            if dq:
                result.append(arr[dq[0]])
            else:
                result.append(0)
        results.append(result)
    return results
test_cases = [
    ((5, 2), [-8, 2, 3, -6, 10]),
    ((8, 3), [12, -1, -7, 8, -15, 30, 16, 28])
]
t = len(test_cases)
outputs = find_earliest_faults(t, test_cases)
for output in outputs:
    print("" "".join(map(str, output)))",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053261
1390053252,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        output = []
        # Process the first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Check the first window
        output.append(arr[dq[0]] if dq else 0)
        # Process the rest of the array
        for i in range(k, n):
            # Remove elements not in the window
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add the current element if it's negative
            if arr[i] < 0:
                dq.append(i)
            # Append the result for the current window
            output.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, output)))
    return results
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Get the results
output = earliest_faulty_readings(test_cases)
# Print the output
for line in output:
    print(line)
    ",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053252
1390053259,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active servers and total idle servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative counts of active servers from left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible starting positions for the remaining servers
    for left in range(n + 1):
        # For each possible ending position
        for right in range(left, n + 1):
            # Active servers in the remaining segment
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active and idle servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case cost
    # For each possible remaining substring (from i to j-1)
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in remaining substring
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (from left and right)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if _name_ == ""_main_"":
    main()",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053259
1390053257,unknown,unknown,unknown,"def solve():
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    mineffort=float('inf')
    for i in range(1<<n):
        skipped=[]
        efforts=[]
        for j in range(n):
            if(i>>j)&1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped)<=k:
            current_effort=0
            skippedcount=0
            for j in range(n):
                if j in skipped:
                    skippedcount+=1
                else:
                    current_effort+=a[j]+skippedcount
            mineffort=min(mineffort,current_effort)
    print(mineffort)
t = int(input())
for _ in range(t):
    solve()
    ",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053257
1390053249,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  
    for i in range(1, n + 1):
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    return min(dp[n])
T = int(input())  
for _ in range(T):
    n, k = map(int, input().split())  
    firewalls = list(map(int, input().split()))  
    print(min_effort(n, k, firewalls))",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053249
1390053250,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053250
1390053251,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    #sort
    value_idx = [(a[i], i) for i in range(n)]
    value_idx.sort(reverse=True)
    #possible skips
    k = min(k, n)  
    candidates = value_idx[:k]  
    min_cost = float('inf')
    for skips in range(k + 1):
        skip_positions = set(c[1] for c in candidates[:skips])
        num_skips_so_far = 0
        current_cost = 0
        for i in range(n):
            if i in skip_positions:
                current_cost += 0
                num_skips_so_far += 1
            else:
                current_cost += a[i] + num_skips_so_far
        min_cost = min(min_cost, current_cost)
    print(min_cost)",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053251
1390053243,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static int minEffort(int n, int k, int[] fw) {
        if (k >= n) return 0; 
        int total = 0;
        for (int x : fw) total += x; 
        Integer[] impact = new Integer[n];
        for (int i = 0; i < n; i++) {
            impact[i] = fw[i] - (n - i - 1); 
        }
        Arrays.sort(impact, Collections.reverseOrder()); 
        for (int i = 0; i < k; i++) {
            total -= Math.max(impact[i], 0); 
        }
        return total;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] fw = new int[n];
            for (int i = 0; i < n; i++) fw[i] = sc.nextInt();
            System.out.println(minEffort(n, k, fw));
        }
        sc.close();
    }
}",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053243
1390053246,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        min_cost_val = float('inf')
        # Iterate over possible decommissioning points
        for left in range(n + 1):
            for right in range(n + 1):
                if left + right > n:
                    continue
                remaining = s[left:n - right]
                idle_remaining = remaining.count('0')
                active_removed = s[:left].count('1') + s[n - right:].count('1')
                current_cost = max(idle_remaining, active_removed)
                if current_cost < min_cost_val:
                    min_cost_val = current_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053246
1390053248,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    # Create list of (value + index) for each firewall
    skip_value = []
    for i in range(n):
        skip_value.append((firewalls[i] + i, i))
    # Sort by descending benefit to skip
    skip_value.sort(reverse=True)
    # Mark which firewalls to skip
    skipped = [0] * n
    for i in range(k):
        _, idx = skip_value[i]
        skipped[idx] = 1
    # Now calculate final effort
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
# Main driver
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053248
1390053242,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <climits>  
using namespace std;
int minCost(const string& servers) {
    int n = servers.length();
    // Edge case: empty rack
    if (n == 0) return 0;
    // Precompute prefix sums for active and idle servers
    vector<int> activePrefixSum(n + 1, 0);
    vector<int> idlePrefixSum(n + 1, 0);
    for (int i = 0; i < n; i++) {
        activePrefixSum[i + 1] = activePrefixSum[i] + (servers[i] == '1');
        idlePrefixSum[i + 1] = idlePrefixSum[i] + (servers[i] == '0');
    }
    int minCost = INT_MAX;
    // Try all possible combinations of removing servers from beginning and end
    for (int prefix = 0; prefix <= n; prefix++) {
        for (int suffix = 0; prefix + suffix <= n; suffix++) {
            // Skip if removing all servers
            if (prefix + suffix == n) continue;
            // Calculate active servers removed
            int activeRemoved = activePrefixSum[prefix] + 
                               (activePrefixSum[n] - activePrefixSum[n - suffix]);
            // Calculate idle servers remaining
            int idleRemaining = idlePrefixSum[n] - idlePrefixSum[prefix] - 
                               (idlePrefixSum[n] - idlePrefixSum[n - suffix]);
            // Calculate cost as max of active removed and idle remaining
            int cost = max(activeRemoved, idleRemaining);
            minCost = min(minCost, cost);
        }
    }
    return minCost;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        string servers;
        cin >> servers;
        cout << minCost(servers) << endl;
    }
    return 0;
}",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053242
1390053237,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053237
1390053238,unknown,unknown,unknown,"def find_fault(arr,k):
    n=len(arr)
    result=[]
    for i in range(n-k+1):
        batch=arr[i:i+k]
        faulty=0
        for x in batch:
            if x<0:
                faulty=x
                break
        result.append(faulty)
    return result
t=int(input())
for j in range(t):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))
    faulty_readings=find_fault(arr,k)
    print(*faulty_readings)",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053238
1390053241,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053241
1390053231,unknown,unknown,unknown,"import sys
def main():
    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for _ in range(T):
        n, k = int(input[idx]), int(input[idx + 1])
        idx += 2
        a = list(map(int, input[idx:idx + n]))
        idx += n
        sum_S = sum(a)
        # Compute a[i] + i (0-based)
        values = [a[i] + i for i in range(n)]
        # Sort in descending order
        values.sort(reverse=True)
        sum_aj_plus_j = sum(values[:k])
        # Compute the result
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
        print(res)
if __name__ == ""__main__"":
    main()",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053231
1390053232,unknown,unknown,unknown,"def ans(x):
    n = len(x)
    total_idle = x.count('0')
    min_cost = float('inf')
    left = 0
    right = n - 1
    current_idle = 0
    current_active = 0
    while left <= right:
        idle_remaining = total_idle - current_idle
        active_decommissioned = current_active
        cost = max(idle_remaining, active_decommissioned)
        if cost < min_cost:
            min_cost = cost
        if x[left] == '0':
            current_idle += 1
            left += 1
        elif x[right] == '0':
            current_idle += 1
            right -= 1
        else:
            current_active += 1
            left += 1
    return min_cost
T = int(input())
for _ in range(T):
    x = input().strip()
    print(ans(x))",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053232
1390053233,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053233
1390053228,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # Stores indices of negative numbers in current window
    # Process first k elements
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process the remaining elements
    for i in range(n - k + 1):
        # If deque is not empty, add the first negative number; else, add 0
        result.append(arr[dq[0]] if dq else 0)
        # Remove elements that are out of this window
        if dq and dq[0] == i:
            dq.popleft()
        # Add next element to the window
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_reading(arr, k))",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053228
1390053229,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    for (int i = k; i <= n; i++) {
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  
        else 
            result.push_back(0);  
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  
    while (t--) {
        int n, k;
        cin >> n >> k;  
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053229
1390053230,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active servers and total idle servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative counts of active servers from left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible starting positions for the remaining servers
    for left in range(n + 1):
        # For each possible ending position
        for right in range(left, n + 1):
            # Active servers in the remaining segment
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active and idle servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case cost
    # For each possible remaining substring (from i to j-1)
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in remaining substring
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (from left and right)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result) # Corrected to print the result
if __name__ == ""__main__"": # Corrected if condition.
    main()",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053230
1390053227,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053227
1390053219,unknown,unknown,unknown,"def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        if k >= n:
            print(0)
            continue
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        for i in range(1, n + 1):
            for j in range(k + 1):
                if j > 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
                if dp[i-1][j] != float('inf'):
                    dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
        print(min(dp[n]))
if __name__ == ""__main__"":
    main()",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053219
1390053223,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, n, k):
    result = []
    dq = deque()
    for i in range(n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print("" "".join(map(str, earliest_faulty_reading(arr, n, k))))",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053223
1390053221,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # We need to handle the case where k >= n (can skip all firewalls)
    if k >= n:
        return 0
    # Initialize DP array
    # dp[i][j] = min effort to breach first i firewalls using at most j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Don't skip current firewall
            # Current strength is increased by the number of skips used so far
            # But j could be larger than what's possible with i-1 firewalls
            # So we need to cap the number of skips considered
            if j <= i - 1:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
            elif j == 0:  # Special case when no skips are used
                dp[i][j] = dp[i-1][j] + strengths[i-1]
            # Option 2: Skip current firewall (if we have skips left)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return dp[n][k]
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        # Special case: if we can skip all firewalls
        if k >= n:
            print(0)
        else:
            print(min_effort_to_breach(n, k, strengths))
# Run the solution
solve()",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053221
1390053215,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    #sort
    value_idx = [(a[i], i) for i in range(n)]
    value_idx.sort(reverse=True)
    #possible skips
    k = min(k, n)  
    candidates = value_idx[:k]  
    min_cost = float('inf')
    for skips in range(k + 1):
        skip_positions = set(c[1] for c in candidates[:skips])
        num_skips_so_far = 0
        current_cost = 0
        for i in range(n):
            if i in skip_positions:
                current_cost += 0
                num_skips_so_far += 1
            else:
                current_cost += a[i] + num_skips_so_far
        min_cost = min(min_cost, current_cost)
    print(min_cost)",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053215
1390053217,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string servers;
        cin >> servers;
        int n = servers.size();
        int min_cost = n;
        int total_1 = count(servers.begin(), servers.end(), '1');
        int total_0 = n - total_1;
        int count_1_removed = 0;
        int count_0_remaining = total_0;
        for (int i = 0; i <= n; ++i) {
            if (i > 0) {
                if (servers[i - 1] == '1') {
                    count_1_removed++;
                } else {
                    count_0_remaining--;
                }
            }
            for (int j = 0; j <= n - i; ++j) {
                int count_0_remaining_after_back = count_0_remaining;
                int count_1_removed_after_back = count_1_removed;
                if (j > 0) {
                    if (servers[n - j] == '1') {
                        count_1_removed_after_back++;
                    } else {
                        count_0_remaining_after_back--;
                    }
                }
                min_cost = min(min_cost, max(count_1_removed_after_back, count_0_remaining_after_back));
            }
        }
        cout << min_cost << endl;
    }
    return 0;
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053217
1390053214,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] s = new int[n];
            for (int i = 0; i < n; i++) s[i] = sc.nextInt();
            System.out.println(minEffort(s, n, k));
        }
        sc.close();
    }
    private static long minEffort(int[] s, int n, int k) {
        if (k >= n) return 0;
        int[] save = new int[n];
        for (int i = 0; i < n; i++) save[i] = s[i] - (n - i - 1);
        Integer[] idx = new Integer[n];
        for (int i = 0; i < n; i++) idx[i] = i;
        Arrays.sort(idx, (a, b) -> Integer.compare(save[b], save[a]));
        boolean[] skip = new boolean[n];
        int skipped = 0;
        for (int i = 0; i < n && skipped < k; i++) {
            if (save[idx[i]] > 0) skip[idx[i]] = true;
            else break;
            skipped++;
        }
        long effort = 0, skips = 0;
        for (int i = 0; i < n; i++) {
            if (skip[i]) skips++;
            else effort += s[i] + skips;
        }
        return effort;
    }
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053214
1390053212,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t >0){
            int n = sc.nextInt();
            int k = sc.nextInt();
            int arr[] = new int[n];
            for(int i = 0; i<n; i++){
                arr[i] = sc.nextInt();
            }
            for(int i = 0; i <= n-k; i++){
                int faulty = 0;
                for(int j = i; j < i+k; j++){
                    if(arr[j] < 0){
                        faulty = arr[j];
                        break;
                    }
                }
                System.out.print(faulty + "" "");
            }
            System.out.println();
            t--;
        }
        sc.close();
    }
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053212
1390053211,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        for (int testCase = 0; testCase < t; testCase++) {
            int n = scanner.nextInt(); // Number of firewalls
            int k = scanner.nextInt(); // Max firewalls we can skip
            long[] firewalls = new long[n];
            for (int i = 0; i < n; i++) {
                firewalls[i] = scanner.nextLong(); // Firewall strengths
            }
            System.out.println(findMinimumEffort(firewalls, n, k));
        }
        scanner.close();
    }
    private static long findMinimumEffort(long[] firewalls, int n, int k) {
        // If we can skip all firewalls, the minimum effort is 0
        if (k >= n) {
            return 0;
        }
        // Calculate the total sum of all firewalls
        long totalSum = 0;
        for (int i = 0; i < n; i++) {
            totalSum += firewalls[i];
        }
        // Try all possible combinations of skipping firewalls
        long minEffort = totalSum;
        // Try not skipping any firewalls
        minEffort = Math.min(minEffort, totalSum);
        // Try skipping each firewall individually
        for (int i = 0; i < n; i++) {
            // Calculate the effort if we skip this firewall
            long effort = totalSum - firewalls[i];
            // Add the penalty for each firewall after the skipped one
            for (int j = i + 1; j < n; j++) {
                effort += 1; // Penalty for each subsequent firewall
            }
            minEffort = Math.min(minEffort, effort);
        }
        return minEffort;
    }
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053211
1390053213,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
public static List<Integer> earliestFault(int[] arr, int k) {
        List<Integer> results = new ArrayList<>();
        // Loop through each possible batch
        for (int i = 0; i <= arr.length - k; i++) {
            boolean faultFound = false;
            // Find earliest fault in current batch
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    results.add(arr[j]);
                    faultFound = true;
                    break;
                }
            }
            // If no fault found in batch, append 0
            if (!faultFound) {
                results.add(0);
            }
        }
        return results;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Size of array
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = earliestFault(arr, k);
            // Print results in the required format
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053213
1390053210,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        min_cost_val = float('inf')
        # Iterate over possible decommissioning points
        for left in range(n + 1):
            for right in range(n + 1):
                if left + right > n:
                    continue
                remaining = s[left:n - right]
                idle_remaining = remaining.count('0')
                active_removed = s[:left].count('1') + s[n - right:].count('1')
                current_cost = max(idle_remaining, active_removed)
                if current_cost < min_cost_val:
                    min_cost_val = current_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053210
1390053203,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        res.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            if dq and dq[0] <= i - k:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    return ""\n"".join(results)
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
print(earliest_faulty_readings(test_cases))",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053203
1390053204,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            faulty = 0
            for num in batch:
                if num < 0:
                    faulty = num
                    break
            result.append(faulty)
        results.append(result)
    return results
# Read the number of test cases
test_cases = int(input())
results = earliest_faulty_readings(test_cases)
# Print the results
for result in results:
    print(' '.join(map(str, result)) + ' ')",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053204
1390053208,unknown,unknown,unknown,"def find_faults(readings, batch_size):
    results = []
    for i in range(len(readings) - batch_size + 1):
        batch = readings[i:i + batch_size]
        fault = 0
        for r in batch:
            if r < 0:
                fault = r
                break
        results.append(fault)
    return results
def process_tests():
    tests = int(input())
    for _ in range(tests):
        n, k = map(int, input().split())
        sensor_data = list(map(int, input().split()))
        fault_results = find_faults(sensor_data, k)
        print(*fault_results)
process_tests()",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053208
1390053200,unknown,unknown,unknown,"def minimum_effort(n, k, arr):
    if k == n:
        return 0
    total_effort = sum(arr)
    min_effort = total_effort  # Start with worst case
    for i in range(n - k + 1):
        current_effort = 0
        current_effort += sum(arr[:i])
        for j in range(i + k, n):
            current_effort += arr[j] + 1
        min_effort = min(min_effort, current_effort)
    return min_effort
T = int(input())
results = []
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    results.append(str(minimum_effort(n, k, arr)))
print('\n'.join(results))",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053200
1390053201,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # Base case: If we skip all firewalls, total effort = 0
    if k == n:
        return 0
    # If no skips are allowed, total effort is just the sum of all firewalls
    if k == 0:
        return sum(firewalls)
    min_effort = float('inf')
    # Try skipping up to 'k' firewalls
    for i in range(n):
        # Skip 'k' firewalls starting from index 'i'
        skipped = 0
        effort = 0
        # Count skips and apply penalties
        for j in range(n):
            if skipped < k and j >= i:
                skipped += 1
            else:
                effort += firewalls[j] + skipped
        # Track the minimum effort
        min_effort = min(min_effort, effort)
    return min_effort
# Reading input
T = int(input().strip())
results = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    results.append(min_effort(n, k, firewalls))
# Output the results for each test case
for res in results:
    print(res)",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053201
1390053202,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque() 
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input()) 
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    print(*earliest_faulty_readings(arr, k))",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053202
1390053194,unknown,unknown,unknown,"import sys
def f(n, k, a):
    if k >= n:
        return 0
    b = sum(a)
    c = b
    for i in range(n):
        d = 0
        e = 0
        for j in range(n):
            if d < k and j == i:
                d += 1
                continue
            e += a[j] + d
        c = min(c, e)
    return c
t = int(sys.stdin.readline().strip())
for _ in range(t):
    n, k = map(int, sys.stdin.readline().split())
    a = list(map(int, sys.stdin.readline().split()))
    print(f(n, k, a))",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053194
1390053196,unknown,unknown,unknown,"import java.util.Arrays;
import java.util.Scanner;
public class FirewallBreachOptimized {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextLong();
            }
            long minEffort = solveOptimized(a, k);
            System.out.println(minEffort);
        }
        scanner.close();
    }
    private static long solveOptimized(long[] a, int k) {
        long minEffort = Long.MAX_VALUE;
        long[][] dp = new long[a.length + 1][k + 1];
        for (int i = 0; i <= a.length; i++) {
            Arrays.fill(dp[i], Long.MAX_VALUE);
        }
        dp[0][0] = 0;
        for (int i = 1; i <= a.length; i++) {
            for (int j = 0; j <= k; j++) {
                // Option 1: Don't skip the current firewall
                if (dp[i - 1][j] != Long.MAX_VALUE) {
                    long currentEffort = dp[i - 1][j];
                    long increasedStrength = a[i - 1];
                    for(int l = 0; l < j; l++){
                        increasedStrength++;
                    }
                    dp[i][j] = Math.min(dp[i][j], currentEffort + increasedStrength);
                }
                // Option 2: Skip the current firewall
                if (j > 0 && dp[i - 1][j - 1] != Long.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        for (int j = 0; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[a.length][j]);
        }
        return minEffort;
    }
}",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053196
1390053199,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips available
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j > 0:
                skip_option = dp[i + 1][j - 1]
                dp[i][j] = min(dp[i][j], skip_option)
            # Option 2: Don't skip this firewall
            # The effort is the firewall value plus the number of skips used so far (k-j)
            effort_factor = k - j
            no_skip_option = firewalls[i] + effort_factor + dp[i + 1][j]
            dp[i][j] = min(dp[i][j], no_skip_option)
    return dp[0][k]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053199
1390053193,unknown,unknown,unknown,"import java.util.*;
public class FaultyComponentDetector {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Size of the array
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
    private static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove elements that are out of the current window
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new negative number index to the deque
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Start collecting results when we have a complete window
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
}",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053193
1390053188,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> dq = new LinkedList<>();
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                dq.addLast(i);
            }
        }
        if (!dq.isEmpty()) {
            result.add(arr[dq.peekFirst()]);
        } else {
            result.add(0);
        }
        for (int i = k; i < arr.length; i++) {
            if (!dq.isEmpty() && dq.peekFirst() <= i - k) {
                dq.pollFirst();
            }
            if (arr[i] < 0) {
                dq.addLast(i);
            }
            if (!dq.isEmpty()) {
                result.add(arr[dq.peekFirst()]);
            } else {
                result.add(0);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();  
        while (t-- > 0) {
            int n = sc.nextInt(); 
            int k = sc.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053188
1390053191,unknown,unknown,unknown,"def min_cost_decommission(server_rack):
    n = len(server_rack)
    min_cost = float('inf')
    # Iterate over all possible ways to decommission servers from the beginning and the end
    for i in range(n + 1):
        for j in range(n + 1):
            if i + j > n:
                continue
            remaining_rack = server_rack[i:n - j]
            idle_remaining = remaining_rack.count('0')
            active_decommissioned = server_rack[:i].count('1') + server_rack[n - j:].count('1')
            cost = max(idle_remaining, active_decommissioned)
            if cost < min_cost:
                min_cost = cost
    return min_cost
def main():
    # Predefined input for test cases
    test_cases = [
        ""101110110"",
        ""1001001001001"",
        ""0000111111""
    ]
    # Process each test case
    for server_rack in test_cases:
        print(min_cost_decommission(server_rack))
if __name__ == ""__main__"":
    main()
    ",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053191
1390053192,unknown,unknown,unknown,"def min_effort(arr, k):
    n = len(arr)
    # Option: Do not skip any firewall
    min_cost = sum(arr)
    # Try skipping every contiguous block of k firewalls
    for i in range(n - k + 1):
        cost_before = sum(arr[:i])
        cost_after = sum(arr[i+k:]) + (n - (i+k))  # extra 1 for each firewall after skipped block
        cost = cost_before + cost_after
        min_cost = min(min_cost, cost)
    return min_cost
# Input handling
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(min_effort(arr, k))",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053192
1390053179,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void earliest_faulty_readings(int arr[], int n, int k) {
    int i;
    int front = 0, rear = 0;  // Deque implemented using an array
    int deque[n]; // Stores indices of negative numbers
    // Process the first window
    for (i = 0; i < k; i++) {
        if (arr[i] < 0)
            deque[rear++] = i;
    }
    // Process rest of the windows
    for (i = k; i <= n; i++) {
        // Print the first negative number in the current window
        if (front < rear)
            printf(""%d "", arr[deque[front]]);
        else
            printf(""0 "");
        // Remove elements not in this window
        while (front < rear && deque[front] < i - k + 1)
            front++;
        // Add the new element if negative
        if (i < n && arr[i] < 0)
            deque[rear++] = i;
    }
    printf(""\n"");
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++)
            scanf(""%d"", &arr[i]);
        earliest_faulty_readings(arr, n, k);
    }
    return 0;
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053179
1390053182,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove elements out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add current element if it is faulty
        if arr[i] < 0:
            dq.append(i)
        # Add result when we have a full window
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053182
1390053185,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053185
1390053175,unknown,unknown,unknown,"def min_cost(test_cases):
    results = []
    for s in test_cases:
        n = len(s)
        min_cost_val = float('inf')
        # Iterate over possible decommissioning points
        for left in range(n + 1):
            for right in range(n + 1):
                if left + right > n:
                    continue
                remaining = s[left:n - right]
                idle_remaining = remaining.count('0')
                active_removed = s[:left].count('1') + s[n - right:].count('1')
                current_cost = max(idle_remaining, active_removed)
                if current_cost < min_cost_val:
                    min_cost_val = current_cost
        results.append(min_cost_val)
    return results
# Read input
T = int(input())
test_cases = [input().strip() for _ in range(T)]
# Compute results
results = min_cost(test_cases)
# Output results
for res in results:
    print(res)",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053175
1390053178,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053178
1390053174,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053174
1390053172,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
if __name__ == ""__main__"":
    main()",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053172
1390053169,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)  # Compute total effort without skipping
    if k == n:
        return 0  # If we can skip all, effort is 0
    min_effort = float('inf')
    for i in range(n):
        effort = total_effort - firewalls[i]  # Skip the i-th firewall
        penalty = 0
        for j in range(i + 1, n):
            penalty += 1  # Each subsequent firewall increases by 1
            effort += penalty
        if i < k:
            min_effort = min(min_effort, effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053169
1390053170,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            zeros = remaining.count('0')
            ones_removed = s[:i].count('1') + s[n-j:].count('1')
            ans = min(ans, max(zeros, ones_removed))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053170
1390053171,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Initialize an array to track the minimum effort for using exactly j skips
    # We'll use a 2D DP array where dp[i][j] = min effort to breach first i firewalls using exactly j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        # If we use 0 skips up to firewall i
        dp[i][0] = dp[i-1][0] + strengths[i-1]
        for j in range(1, min(i, k) + 1):
            # Option 1: Skip the current firewall
            dp[i][j] = dp[i-1][j-1]
            # Option 2: Don't skip the current firewall
            # If we've skipped j firewalls so far, strength increases by j
            dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
    # Return the minimum across all possible numbers of skips for all n firewalls
    return min(dp[n])
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        print(min_effort_to_breach(n, k, strengths))
# Run the solution
solve()",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053171
1390053163,unknown,unknown,unknown,"def min_cost(server_str):
    n = len(server_str)
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
    for i in range(n):
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
    total_1 = prefix_1[n]
    total_0 = prefix_0[n]
    min_cost = float('inf')
    # Try removing l elements from the front
    for l in range(n + 1):
        # Try removing r elements from the back
        for r in range(n - l + 1):
            left = l
            right = n - r
            remaining_0 = prefix_0[right] - prefix_0[left]
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
            cost = max(remaining_0, removed_1)
            min_cost = min(min_cost, cost)
    return min_cost
# Main driver
T = int(input())
for _ in range(T):
    server_str = input().strip()
    print(min_cost(server_str))",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053163
1390053164,unknown,unknown,unknown,"def min_decommissioning_cost(server_string):
    n = len(server_string)
    # Track total number of active servers in the original string
    total_active = server_string.count('1')
    min_cost = float('inf')
    # Try all possible prefixes and suffixes to remove
    for prefix_len in range(n + 1):
        for suffix_len in range(n + 1 - prefix_len):
            # The remaining substring after removing prefix and suffix
            remaining = server_string[prefix_len:n-suffix_len]
            if not remaining:  # If we removed everything
                continue
            # Count remaining idle servers and removed active servers
            remaining_idle = remaining.count('0')
            # Active servers in prefix and suffix
            removed_active = 0
            if prefix_len > 0:
                removed_active += server_string[:prefix_len].count('1')
            if suffix_len > 0:
                removed_active += server_string[n-suffix_len:].count('1')
            # Calculate cost
            cost = max(remaining_idle, removed_active)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    server_string = input().strip()
    print(min_decommissioning_cost(server_string))",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053164
1390053166,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053166
1390053160,unknown,unknown,unknown,"#include <iostream>
#include <deque>
#include <vector>
using namespace std;
void earliestFaultyReadings(int n, int k, vector<int>& arr) {
    deque<int> dq;
    vector<int> result;
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            dq.push_back(i);
        }
    }
    result.push_back(dq.empty() ? 0 : arr[dq.front()]);
    for (int i = k; i < n; i++) {
        if (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        if (arr[i] < 0) {
            dq.push_back(i);
        }
        result.push_back(dq.empty() ? 0 : arr[dq.front()]);
    }
    for (int num : result) {
        cout << num << "" "";
    }
    cout << endl;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        earliestFaultyReadings(n, k, arr);
    }
    return 0;
}",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053160
1390053161,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            if (arr[i] < 0) {
                deque.offer(i);
            }
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053161
1390053162,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active servers and total idle servers
    total_active = server_string.count('1')
    total_idle = n - total_active
    # Precompute cumulative counts of active servers from left
    active_prefix_sum = [0] * (n + 1)
    for i in range(n):
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
    min_cost = float('inf')
    # Try all possible starting positions for the remaining servers
    for left in range(n + 1):
        # For each possible ending position
        for right in range(left, n + 1):
            # Active servers in the remaining segment
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
            idle_remaining = (right - left) - active_remaining
            # Active servers removed
            active_removed = total_active - active_remaining
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def faster_min_decommission_cost(server_string):
    n = len(server_string)
    # Precompute prefix sums for active and idle servers
    active_prefix = [0] * (n + 1)
    idle_prefix = [0] * (n + 1)
    for i in range(n):
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
    min_cost = n  # Worst case cost
    # For each possible remaining substring (from i to j-1)
    for i in range(n + 1):
        for j in range(i, n + 1):
            # Idle servers in remaining substring
            idle_remaining = idle_prefix[j] - idle_prefix[i]
            # Active servers removed (from left and right)
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = faster_min_decommission_cost(server_string)
        print(result)
if _name_ == ""_main_"":
    main()",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053162
1390053159,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        output = []
        dq = deque()
        # Process first k elements
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Process remaining elements in a sliding window
        for i in range(n - k + 1):
            # Add the first faulty element in the current window
            if dq:
                output.append(arr[dq[0]])
            else:
                output.append(0)
            # Remove elements that are out of this window
            if dq and dq[0] == i:
                dq.popleft()
            # Add next element from the next window
            if i + k < n and arr[i + k] < 0:
                dq.append(i + k)
        results.append("" "".join(map(str, output)))
    return ""\n"".join(results)
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    test_cases.append((n, k, arr))
# Get results and print
print(earliest_faulty_readings(test_cases))",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053159
1390053148,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static int minDecommissionCost(String s) {
        int n = s.length(), minCost = n;
        for (int start = 0; start <= n; start++) {
            for (int end = 0; end <= n - start; end++) {
                int idle = 0, active = 0;
                for (int i = 0; i < n; i++) {
                    if (i < start || i >= n - end) {
                        if (s.charAt(i) == '1') active++;
                    } else {
                        if (s.charAt(i) == '0') idle++;
                    }
                }
                minCost = Math.min(minCost, Math.max(idle, active));
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        sc.nextLine();
        while (t-- > 0) System.out.println(minDecommissionCost(sc.nextLine().trim()));
        sc.close();
    }
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053148
1390053152,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053152
1390053156,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053156
1390053139,unknown,unknown,unknown,"function processData(input) {
    let lines = input.trim().split(""\n"");
    let t = parseInt(lines[0]);
    let testCases = [];
    let index = 1;
    for (let i = 0; i < t; i++) {
        let [n, k] = lines[index].split("" "").map(Number);
        let arr = lines[index + 1].split("" "").map(Number);
        testCases.push([n, k, arr]);
        index += 2;
    }
    function earliestFaultyReadings(testCases) {
        let results = [];
        for (let [n, k, arr] of testCases) {
            let dq = [];
            let output = [];
            // Process first k elements
            for (let i = 0; i < k; i++) {
                if (arr[i] < 0) {
                    dq.push(i);
                }
            }
            // Process remaining elements
            for (let i = 0; i <= n - k; i++) {
                // Append first negative if exists, else 0
                output.push(dq.length ? arr[dq[0]] : 0);
                // Remove elements that are out of the current window
                if (dq.length && dq[0] === i) {
                    dq.shift();
                }
                // Add next element from the array if it's negative
                if (i + k < n && arr[i + k] < 0) {
                    dq.push(i + k);
                }
            }
            results.push(output.join("" ""));
        }
        console.log(results.join(""\n""));
    }
    earliestFaultyReadings(testCases);
}
process.stdin.resume();
process.stdin.setEncoding(""ascii"");
let _input = """";
process.stdin.on(""data"", function (input) {
    _input += input;
});
process.stdin.on(""end"", function () {
    processData(_input);
});",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053139
1390053140,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove out-of-window elements
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add new faulty readings
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Collect results for valid windows
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Array size
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Compute and print results
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053140
1390053142,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053142
1390053137,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053137
1390053138,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(t>0){
            int n=sc.nextInt();
            int k=sc.nextInt();
            int arr[]=new int[n];
            int i,j;
            for(i=0;i<n;i++){
                arr[i]=sc.nextInt();
            }
            for(i=0;i<=n-k;i++){
                int res=0;
                for(j=i;j<=i+k-1;j++){
                    if(arr[j]<0){
                        res=arr[j];
                        break;
                    }
                }
                System.out.print(res+"" "");
            }
            System.out.println();
            t--;
        }
    }
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053138
1390053136,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053136
1390053135,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(min(i, k) + 1):
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
            if dp[i-1][j] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
    return min(dp[n])
def solve():
    t = int(input().strip())
    results = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        strengths = list(map(int, input().strip().split()))
        results.append(str(min_effort_to_breach(n, k, strengths)))
    print(""\n"".join(results))
solve()",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053135
1390053132,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # If we can skip all firewalls, the answer is 0
    if k >= n:
        return 0
    # Calculate the cost of skipping a firewall at position i
    # This includes the original firewall strength plus the penalty it would add to future firewalls
    impact = []
    for i in range(n):
        # Impact = strength of firewall + number of non-skipped firewalls after this one
        # We're assuming all firewalls after i are NOT skipped (we'll adjust this later)
        firewall_impact = strengths[i] + (n - i - 1)
        impact.append((firewall_impact, i))
    # Sort by impact (high to low)
    impact.sort(reverse=True)
    # Select firewalls to skip (those with highest impact)
    to_skip = set()
    for i in range(min(k, n)):
        to_skip.add(impact[i][1])
    # Calculate final effort
    total_effort = 0
    skipped_count = 0
    for i in range(n):
        if i in to_skip:
            skipped_count += 1
        else:
            # Add firewall strength plus penalty for each previously skipped firewall
            total_effort += strengths[i] + skipped_count
    return total_effort
def solve_all_subsets(n, k, strengths):
    # Try all possible subsets of firewalls to skip
    # This is an exhaustive approach for when n is small
    min_effort = float('inf')
    # 2^n possible subsets of firewalls
    for mask in range(1 << n):
        # Count bits to ensure we're skipping at most k firewalls
        skipped = bin(mask).count('1')
        if skipped > k:
            continue
        effort = 0
        skip_count = 0
        for i in range(n):
            if (mask >> i) & 1:  # This firewall is skipped
                skip_count += 1
            else:
                effort += strengths[i] + skip_count
        min_effort = min(min_effort, effort)
    return min_effort
def main():
    t = int(input().strip())
    for _ in range(t):
        n, k = map(int, input().strip().split())
        strengths = list(map(int, input().strip().split()))
        # For small n, use exhaustive approach
        if n <= 20:
            result = solve_all_subsets(n, k, strengths)
        else:
            # For larger n, use greedy approach
            result = min_effort_to_breach(n, k, strengths)
        print(result)
if __name__ == ""__main__"":
    main()",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053132
1390053133,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin>>t;
    while(t--)
    {
        int n,k;
        cin>>n>>k;
        vector<int> input(n);
        for(int i=0;i<n;i++)
        {
            int ele;
            cin>>ele;
            input[i]=ele;
        }
        vector<int> ans;
        int i=0;
        int j=0;
        queue<int> q;//would store indices of -ve
        while(j<k)
        {
            if(input[j]<0)
                q.push(j);
            j++;
        }
        j--;
        while(j<n)
        {   
            if(q.empty())
                ans.push_back(0);
            else
            ans.push_back(input[q.front()]);
            if(!q.empty() && q.front()==i)
                q.pop();
            i++;
            j++;
            if(j<n && input[j]<0)
                q.push(j);
        }
        for(auto &el:ans)
            cout<<el<<"" "";
        cout<<endl;
    }
    return 0;
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053133
1390053130,unknown,unknown,unknown,"import java.util.*;
public class EarliestFaultyBatch {
    public static List<Integer> earliestFaultyReadings(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> dq = new LinkedList<>();
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                dq.add(i);
            }
        }
        result.add(dq.isEmpty() ? 0 : arr[dq.peekFirst()]);
        for (int i = k; i < arr.length; i++) {
            if (!dq.isEmpty() && dq.peekFirst() < i - k + 1) {
                dq.pollFirst();
            }
            if (arr[i] < 0) {
                dq.add(i);
            }
            result.add(dq.isEmpty() ? 0 : arr[dq.peekFirst()]);
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = earliestFaultyReadings(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053130
1390053128,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            temp = s[i:n - j]
            idle = temp.count('0')
            active = s[:i].count('1') + s[n - j:].count('1')
            ans = min(ans, max(idle, active))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053128
1390053125,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053125
1390053129,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
// Comparator function for sorting in descending order
int compare(const void *a, const void *b) {
    return (*(int *)b - *(int *)a);
}
void minimum_effort(int test_cases) {
    for (int t = 0; t < test_cases; t++) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int *arr = (int *)malloc(n * sizeof(int));
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        // Edge case: If k >= n, the minimum effort is 0
        if (k >= n) {
            printf(""0\n"");
            free(arr);
            continue;
        }
        // Calculate the potential reduction for each firewall if skipped
        int *reduction = (int *)malloc(n * sizeof(int));
        for (int i = 0; i < n; i++) {
            reduction[i] = arr[i] - (n - i - 1);
        }
        // Sort the reduction array in descending order
        qsort(reduction, n, sizeof(int), compare);
        // Calculate the minimum effort
        long long total_effort = 0;
        for (int i = 0; i < n; i++) {
            total_effort += arr[i];
        }
        // Subtract the top k reductions
        for (int i = 0; i < k; i++) {
            total_effort -= reduction[i];
        }
        printf(""%lld\n"", total_effort);
        free(arr);
        free(reduction);
    }
}
int main() {
    int test_cases;
    scanf(""%d"", &test_cases);
    minimum_effort(test_cases);
    return 0;
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053129
1390053111,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053111
1390053117,unknown,unknown,unknown,"import java.util.Arrays;
import java.util.Scanner;
public class FirewallBreachOptimized {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextLong();
            }
            long minEffort = solveOptimized(a, k);
            System.out.println(minEffort);
        }
        scanner.close();
    }
    private static long solveOptimized(long[] a, int k) {
        long minEffort = Long.MAX_VALUE;
        long[][] dp = new long[a.length + 1][k + 1];
        for (int i = 0; i <= a.length; i++) {
            Arrays.fill(dp[i], Long.MAX_VALUE);
        }
        dp[0][0] = 0;
        for (int i = 1; i <= a.length; i++) {
            for (int j = 0; j <= k; j++) {
                // Option 1: Don't skip the current firewall
                if (dp[i - 1][j] != Long.MAX_VALUE) {
                    long currentEffort = dp[i - 1][j];
                    for (int l = 0; l < j; l++) {
                        currentEffort += 1;
                    }
                    dp[i][j] = Math.min(dp[i][j], currentEffort + a[i - 1]);
                }
                // Option 2: Skip the current firewall
                if (j > 0 && dp[i - 1][j - 1] != Long.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        for (int j = 0; j <= k; j++) {
            minEffort = Math.min(minEffort, dp[a.length][j]);
        }
        return minEffort;
    }
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053117
1390053122,unknown,unknown,unknown,"from collections import deque
def find_first_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*find_first_faulty_readings(arr, k))",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053122
1390053109,unknown,unknown,unknown,"import java.util.Scanner;
public class ServerDecommission {
    public static int minCostDecommissioning(String rack) {
        int n = rack.length();
        int totalOnes = 0;
        // Count total number of 1's in the rack
        for (char c : rack.toCharArray()) {
            if (c == '1') {
                totalOnes++;
            }
        }
        int minCost = Integer.MAX_VALUE;
        // Try all possible removals from left and right
        for (int left = 0; left <= n; left++) {
            for (int right = 0; right <= n - left; right++) {
                String remaining = rack.substring(left, n - right);
                int remainingZeros = 0, remainingOnes = 0;
                for (char c : remaining.toCharArray()) {
                    if (c == '0') {
                        remainingZeros++;
                    } else {
                        remainingOnes++;
                    }
                }
                int removedOnes = totalOnes - remainingOnes;
                int cost = Math.max(remainingZeros, removedOnes);
                minCost = Math.min(minCost, cost);
            }
        }
        return minCost;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        for (int i = 0; i < T; i++) {
            String rack = scanner.nextLine();
            System.out.println(minCostDecommissioning(rack));
        }
        scanner.close();
    }
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053109
1390053106,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()  # Stores indices of negative values
    # Process first window of size k
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store result for first window
    result.append(arr[dq[0]] if dq else 0)
    # Process rest of the windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the window
        if dq and dq[0] <= i - k:
            dq.popleft()
        # Add current element if negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result
        result.append(arr[dq[0]] if dq else 0)
    return result
# Input Handling
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))  # Print result space-separated",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053106
1390053107,unknown,unknown,unknown,"import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            long sum_a = 0;
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt();
                sum_a += a[i];
            }
            List<Long> values = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                long val = a[i] - (n - i - 1L);
                values.add(val);
            }
            values.sort((x, y) -> Long.compare(y, x));
            long[] prefixSum = new long[n + 1];
            prefixSum[0] = 0;
            for (int i = 1; i <= n; i++) {
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
            }
            int max_m = Math.min(k, n);
            long maxTotal = Long.MIN_VALUE;
            for (int m = 0; m <= max_m; m++) {
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
                if (current > maxTotal) {
                    maxTotal = current;
                }
            }
            long minEffort = sum_a - maxTotal;
            System.out.println(minEffort);
        }
        sc.close();
    }
}",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053107
1390053108,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053108
1390053095,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053095
1390053096,unknown,unknown,unknown,"from collections import deque 
def neginteger(arr_NeelJ, k_NeelJ):
    ans_NeelJ=[]
    queue_NeelJ=deque()
    i_NeelJ, j_NeelJ=0,0
    n_NeelJ= len(arr_NeelJ)
    while j_NeelJ<n_NeelJ:
        if arr_NeelJ[j_NeelJ]<0:
            queue_NeelJ.append(arr_NeelJ[j_NeelJ])
        if j_NeelJ- i_NeelJ + 1< k_NeelJ:
            j_NeelJ+=1
        elif j_NeelJ -i_NeelJ+1 == k_NeelJ:
            if not queue_NeelJ:
                ans_NeelJ.append(0)
            else:
                ans_NeelJ.append(queue_NeelJ[0])
                if arr_NeelJ[i_NeelJ]== queue_NeelJ[0]:
                    queue_NeelJ.popleft()
            i_NeelJ+=1
            j_NeelJ+=1
    return ans_NeelJ
if __name__ == ""__main__"":
    t_NeelJ = int(input())
    for _ in range(t_NeelJ):
        n_NeelJ, k_NeelJ = map(int, input().split())
        arr_NeelJ = list(map(int, input().split()))
        result_NeelJ = neginteger(arr_NeelJ, k_NeelJ)
        print(*result_NeelJ)",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053096
1390053102,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053102
1390053091,unknown,unknown,unknown,"function processData(input) {
    let lines = input.trim().split(""\n"");
    let t = parseInt(lines[0]); 
    let index = 1;
    let output = [];
    for (let test = 0; test < t; test++) {
        let [n, k] = lines[index].split("" "").map(Number);
        let arr = lines[index + 1].split("" "").map(Number);
        index += 2; // Move to next test case
        let res = [];
        for(let i = 0; i <= n - k; i++){
            let batch = arr.slice(i,i+k)
            let faulty = false;
            for(let val of batch){
                if(val < 0){
                    res.push(val)
                    faulty = true
                    break;
                }
            }
            if(!faulty) res.push(0)
        }
        output.push(res.join("" ""))        
    }
    console.log(output.join(""\n""));
} 
process.stdin.resume();
process.stdin.setEncoding(""ascii"");
_input = """";
process.stdin.on(""data"", function (input) {
    _input += input;
});
process.stdin.on(""end"", function () {
   processData(_input);
});",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053091
1390053093,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for test in test_cases:
        n, k, arr = test
        dq = deque()
        res = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        res.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    print(""\n"".join(results))
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
earliest_faulty_readings(test_cases)",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053093
1390053094,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
def min_effort_to_breach(n, k, firewalls):
    firewalls.sort() 
    if k >= n:
        return 0
    return sum(firewalls[k:])
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, split()))
    print(min_effort_to_breach(n, k, firewalls))",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053094
1390053090,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053090
1390053086,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053086
1390053087,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053087
1390053088,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    total_ones = s.count('1')
    for i in range(n + 1):
        remaining = s[i:]
        zeros_remaining = remaining.count('0')
        ones_removed = total_ones - remaining.count('1')
        ans = min(ans, max(zeros_remaining, ones_removed))
    for j in range(n + 1):
        remaining = s[:n-j]
        zeros_remaining = remaining.count('0')
        ones_removed = total_ones - remaining.count('1')
        ans = min(ans, max(zeros_remaining, ones_removed))
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            zeros_remaining = remaining.count('0')
            ones_removed = total_ones - remaining.count('1')
            ans = min(ans, max(zeros_remaining, ones_removed))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053088
1390053083,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053083
1390053085,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <deque>
using namespace std;
vector<int> earliestFaultyReadings(vector<int>& arr, int n, int k) {
    vector<int> result;
    deque<int> dq;  
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            dq.push_back(i);
        }
    }
    result.push_back(dq.empty() ? 0 : arr[dq.front()]);
    for (int i = k; i < n; i++) { 
        if (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        if (arr[i] < 0) {
            dq.push_back(i);
        }
        result.push_back(dq.empty() ? 0 : arr[dq.front()]);
    }
    return result;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> output = earliestFaultyReadings(arr, n, k);
        for (int val : output) {
            cout << val << "" "";
        }
        cout << endl;
    }
    return 0;
}",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053085
1390053081,unknown,unknown,unknown,,154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053081
1390053075,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053075
1390053079,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        earliest_fault = 0
        for j, reading in enumerate(batch):
            if reading < 0:
                earliest_fault = reading
                break
        result.append(earliest_fault)
    return result
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = find_earliest_faults(arr, k)
        print(*result)
solve()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053079
1390053080,unknown,unknown,unknown,"def minimum_effort(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]
        strengths = test_cases[t][1]
        if k == n:
            results.append(0)
            continue
        total_effort = sum(strengths)
        min_effort = total_effort
        for i in range(n):
            skip_effort = total_effort - strengths[i]
            for j in range(1, k + 1):
                if i + j < n:
                    skip_effort += 1  # Adding penalty for skipping next k firewalls
            min_effort = min(min_effort, skip_effort)
        results.append(min_effort)
    return results
# Input processing
def main():
    T = int(input().strip())
    test_cases = []
    for _ in range(T):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        test_cases.append(((n, k), strengths))
    results = minimum_effort(T, test_cases)
    for res in results:
        print(res)
if __name__ == ""__main__"":
    main()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053080
1390053073,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    servers = [int(c) for c in server_string]
    # Total number of ones and zeros
    total_ones = sum(servers)
    total_zeros = n - total_ones
    # Pre-compute prefix sums
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + servers[i]
    min_cost = float('inf')
    # For each number of servers to keep (not remove)
    for keep_len in range(1, n):
        # For each possible starting position of the kept segment
        for start in range(n - keep_len + 1):
            end = start + keep_len
            # Calculate ones removed
            ones_removed = total_ones - (prefix_ones[end] - prefix_ones[start])
            # Calculate zeros kept
            zeros_kept = keep_len - (prefix_ones[end] - prefix_ones[start])
            # Calculate cost
            cost = max(zeros_kept, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def optimize_by_sliding_window(server_string):
    n = len(server_string)
    total_ones = server_string.count('1')
    min_cost = float('inf')
    # For each possible continuous segment to keep
    for length in range(1, n):
        # Compute initial window
        window = server_string[:length]
        ones_in_window = window.count('1')
        zeros_in_window = length - ones_in_window
        ones_removed = total_ones - ones_in_window
        cost = max(zeros_in_window, ones_removed)
        min_cost = min(min_cost, cost)
        # Slide the window
        for i in range(1, n - length + 1):
            # Remove leftmost character from window
            if server_string[i-1] == '1':
                ones_in_window -= 1
            else:
                zeros_in_window -= 1
            # Add rightmost character to window
            if server_string[i+length-1] == '1':
                ones_in_window += 1
            else:
                zeros_in_window += 1
            ones_removed = total_ones - ones_in_window
            cost = max(zeros_in_window, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def optimize_further(server_string):
    n = len(server_string)
    # Precompute ones count
    ones = []
    for c in server_string:
        ones.append(1 if c == '1' else 0)
    total_ones = sum(ones)
    min_cost = n  # worst case is keeping all zeros
    # For each possible length of servers to keep
    for length in range(1, n):
        # Initialize window sum
        ones_in_window = sum(ones[:length])
        zeros_in_window = length - ones_in_window
        # Check cost for this window
        ones_removed = total_ones - ones_in_window
        cost = max(zeros_in_window, ones_removed)
        min_cost = min(min_cost, cost)
        # Slide window
        for i in range(length, n):
            # Add new element, remove old element
            ones_in_window += ones[i] - ones[i-length]
            zeros_in_window = length - ones_in_window
            ones_removed = total_ones - ones_in_window
            cost = max(zeros_in_window, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        server_string = input().strip()
        # Use the most optimized solution
        result = optimize_further(server_string)
        print(result)
# Execute the solution
solve()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053073
1390053069,unknown,unknown,unknown,"def find_earliest_faults(test_cases):
    output = []
    for case in test_cases:
        size, batch_size, readings = case
        batch_faults = []
        for start in range(size - batch_size + 1):
            current_batch = readings[start:start + batch_size]
            fault = next((value for value in current_batch if value < 0), 0)
            batch_faults.append(fault)
        output.append(batch_faults)
    return output
def main():
    import sys
    input = sys.stdin.read
    lines = input().splitlines()
    index = 0
    num_cases = int(lines[index])
    index += 1
    cases = []
    for _ in range(num_cases):
        size, batch_size = map(int, lines[index].split())
        index += 1
        readings = list(map(int, lines[index].split()))
        index += 1
        cases.append((size, batch_size, readings))
    results = find_earliest_faults(cases)
    for result in results:
        print("" "".join(map(str, result)))
if __name__ == ""__main__"":
    main()",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053069
1390053071,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053071
1390053072,unknown,unknown,unknown,"def findMinEffort():
    n,k = map(int,input().split())
    a = list(map(int,input().split()))   
    ans = float('inf')
    for i in range(1<<n):
        skipped=[]
        efforts=[]
        for j in range(n):
            if(i>>j) & 1:
                skipped.append(j)
            else:
                efforts.append(j)
        if len(skipped)<=k:
            current_effort=0
            skipped_count=0
            for j in range(n):
                if j in skipped:
                    skipped_count+=1
                else:
                    current_effort+= a[j] + skipped_count
            ans = min(ans,current_effort)
    print(ans)
t = int(input())
for _ in range(t):
    findMinEffort()",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053072
1390053057,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
            Deque<Integer> dq = new LinkedList<>();
            for (int i = 0; i < n; i++) {
                if (arr[i] < 0) dq.addLast(i);
                if (i >= k - 1) {
                    while (!dq.isEmpty() && dq.peekFirst() < i - k + 1) dq.pollFirst();
                    System.out.print((dq.isEmpty() ? 0 : arr[dq.peekFirst()]) + "" "");
                }
            }
            System.out.println();
        }
        sc.close();
    }
}",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053057
1390053064,unknown,unknown,unknown,"T=int(input())
for i in range(T):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))
    result=[]
    for x in range(n-k+1):
        faulty=0
        for y in range(x,x+k):
            if arr[y]<0:
                faulty=arr[y]
                break
        result.append(faulty)
    print(*result)",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053064
1390053067,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        res = []
        dq = deque()
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        if dq:
            res.append(arr[dq[0]])
        else:
            res.append(0)
        for i in range(k, n):
            if dq and dq[0] <= i - k:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            if dq:
                res.append(arr[dq[0]])
            else:
                res.append(0)
        results.append(' '.join(map(str, res)))
    print('\n'.join(results))
if __name__ == ""__main__"":
    t = int(input())
    earliest_faulty_readings(t)",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053067
1390053051,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    total_effort = sum(firewalls)
    min_effort = total_effort
    for i in range(n):
        effort = 0
        skipped = 0
        increased_security = 0
        for j in range(n):
            if skipped < k and j >= i:
                skipped += 1
                increased_security += 1
            else:
                effort += firewalls[j] + increased_security
        min_effort = min(min_effort, effort)
    return min_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053051
1390053054,unknown,unknown,unknown,"def minimize_breach_effort(n, k, strengths):
    # We need to determine which k firewalls to skip to minimize total effort
    # We'll try all possible combinations using dynamic programming
    # dp[i][j] represents the minimum effort needed to breach through i firewalls
    # using at most j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: no firewalls, no skips, zero effort
    for i in range(1, n + 1):
        firewall_idx = i - 1  # Convert to 0-indexed
        for j in range(k + 1):
            # Option 1: Don't skip current firewall
            if j <= i - 1:  # Ensure we have processed enough firewalls
                # Current strength is original strength + number of skipped firewalls so far
                strength_increase = j  # j firewalls have been skipped so far
                current_strength = strengths[firewall_idx] + strength_increase
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
            # Option 2: Skip current firewall (if we have skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Return minimum effort using at most k skips for all firewalls
    return dp[n][k]
def main():
    # Read the number of test cases
    t = int(input())
    for _ in range(t):
        # Read n (number of firewalls) and k (max skips)
        n, k = map(int, input().split())
        # Read the strengths of n firewalls
        firewall_strengths = list(map(int, input().split()))
        # Calculate and print the minimum effort required
        min_effort = minimize_breach_effort(n, k, firewall_strengths)
        print(min_effort)
if __name__ == ""__main__"":
    main()",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053054
1390053052,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053052
1390053050,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053050
1390053044,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
            long minEffort = Long.MAX_VALUE;
            // Case when skipping 0 to k firewalls
            if (k >= n) {
                // Skip all firewalls
                System.out.println(0);
                continue;
            }
            // Try all combinations where we skip up to k firewalls
            // For k=1, try skipping each firewall one by one
            // General approach:
            boolean[] skip = new boolean[n];
            // Priority Queue to skip k largest firewalls
            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
            for (int i = 0; i < n; i++) {
                pq.add(new int[]{arr[i], i});
            }
            for (int s = 0; s <= k; s++) {
                Arrays.fill(skip, false);
                PriorityQueue<int[]> temp = new PriorityQueue<>(pq);
                // Skip 's' largest firewalls
                for (int j = 0; j < s; j++) {
                    int[] top = temp.poll();
                    skip[top[1]] = true;
                }
                long effort = 0;
                int skipped = 0;
                for (int i = 0; i < n; i++) {
                    if (skip[i]) {
                        skipped++;
                    } else {
                        effort += arr[i] + skipped;
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
            System.out.println(minEffort);
        }
        sc.close();
    }
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053044
1390053047,unknown,unknown,unknown,"import java.util.Arrays;
import java.util.Scanner;
public class FirewallBreach {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextLong();
            }
            long minEffort = solve(a, k);
            System.out.println(minEffort);
        }
        scanner.close();
    }
    private static long solve(long[] a, int k) {
        long minEffort = Long.MAX_VALUE;
        for (int i = 0; i <= (1 << a.length) -1; i++) {
            if(Integer.bitCount(i) > k) continue;
            long currentEffort = 0;
            long[] tempA = Arrays.copyOf(a, a.length);
            int skipped = 0;
            for(int j = 0; j < a.length; j++){
                if((i & (1 << j)) != 0){
                    skipped++;
                }
                else{
                    currentEffort += tempA[j];
                }
            }
            if(skipped <= k){
                long currentEffort2 = 0;
                long[] tempA2 = Arrays.copyOf(a, a.length);
                int skipped2 = 0;
                for(int j = 0; j < a.length; j++){
                    if((i & (1 << j)) != 0){
                        skipped2++;
                    }
                    else{
                        currentEffort2 += tempA2[j];
                    }
                    for(int l = j+1; l < a.length; l++){
                        if((i & (1 << j)) != 0){
                            tempA2[l]+=1;
                        }
                    }
                }
                minEffort = Math.min(minEffort, currentEffort2);
            }
        }
        return minEffort;
    }
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053047
1390053049,unknown,unknown,unknown,"def min_firewall_effort(n, k, firewalls):
    prefix_sum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + firewalls[i - 1]
    min_effort = float('inf')
    for i in range(n - k + 1):
        effort = prefix_sum[i] + (prefix_sum[n] - prefix_sum[i + k]) + k * (n - (i + k))
        min_effort = min(min_effort, effort)
    return min_effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_firewall_effort(n, k, firewalls))",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053049
1390053042,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    servers = [int(c) for c in server_string]
    # Total number of ones and zeros
    total_ones = sum(servers)
    total_zeros = n - total_ones
    # Pre-compute prefix sums
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + servers[i]
    min_cost = float('inf')
    # For each number of servers to keep (not remove)
    for keep_len in range(1, n):
        # For each possible starting position of the kept segment
        for start in range(n - keep_len + 1):
            end = start + keep_len
            # Calculate ones removed
            ones_removed = total_ones - (prefix_ones[end] - prefix_ones[start])
            # Calculate zeros kept
            zeros_kept = keep_len - (prefix_ones[end] - prefix_ones[start])
            # Calculate cost
            cost = max(zeros_kept, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def optimize_by_sliding_window(server_string):
    """"""
    Optimize using sliding window to reduce time complexity to O(n²)
    but with much fewer operations
    """"""
    n = len(server_string)
    total_ones = server_string.count('1')
    min_cost = float('inf')
    # For each possible continuous segment to keep
    for length in range(1, n):
        # Compute initial window
        window = server_string[:length]
        ones_in_window = window.count('1')
        zeros_in_window = length - ones_in_window
        ones_removed = total_ones - ones_in_window
        cost = max(zeros_in_window, ones_removed)
        min_cost = min(min_cost, cost)
        # Slide the window
        for i in range(1, n - length + 1):
            # Remove leftmost character from window
            if server_string[i-1] == '1':
                ones_in_window -= 1
            else:
                zeros_in_window -= 1
            # Add rightmost character to window
            if server_string[i+length-1] == '1':
                ones_in_window += 1
            else:
                zeros_in_window += 1
            ones_removed = total_ones - ones_in_window
            cost = max(zeros_in_window, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def optimize_further(server_string):
    """"""
    Even more optimized solution with better constant factors
    """"""
    n = len(server_string)
    # Precompute ones count
    ones = []
    for c in server_string:
        ones.append(1 if c == '1' else 0)
    total_ones = sum(ones)
    min_cost = n  # worst case is keeping all zeros
    # For each possible length of servers to keep
    for length in range(1, n):
        # Initialize window sum
        ones_in_window = sum(ones[:length])
        zeros_in_window = length - ones_in_window
        # Check cost for this window
        ones_removed = total_ones - ones_in_window
        cost = max(zeros_in_window, ones_removed)
        min_cost = min(min_cost, cost)
        # Slide window
        for i in range(length, n):
            # Add new element, remove old element
            ones_in_window += ones[i] - ones[i-length]
            zeros_in_window = length - ones_in_window
            ones_removed = total_ones - ones_in_window
            cost = max(zeros_in_window, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        server_string = input().strip()
        # Use the most optimized solution
        result = optimize_further(server_string)
        print(result)
# Execute the solution
solve()",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053042
1390053038,unknown,unknown,unknown,"def minimum_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        if k >= n:
            results.append(0)
            continue
        # Calculate the total effort if no firewalls are skipped
        total_effort = sum(a)
        # Calculate the reduction for each firewall if it were skipped
        # The reduction is a[i] - (number of firewalls after it)
        # Because each skipped firewall increases the strength of all subsequent firewalls by 1
        reduction = []
        for i in range(n):
            reduction.append(a[i] - (n - i - 1))
        # Sort the reduction values in descending order
        reduction.sort(reverse=True)
        # Sum the top k reductions
        max_reduction = sum(reduction[:k])
        # Subtract the maximum reduction from the total effort
        results.append(total_effort - max_reduction)
    return results
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx])
    idx += 1
    test_cases = []
    for _ in range(T):
        n, k = int(data[idx]), int(data[idx + 1])
        idx += 2
        a = list(map(int, data[idx:idx + n]))
        idx += n
        test_cases.append((n, k, a))
    results = minimum_effort(test_cases)
    for res in results:
        print(res)
if __name__ == ""__main__"":
    main()",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053038
1390053031,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(); 
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println(); 
        }
        sc.close();
    }
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> output = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                deque.add(i);
            }
        }
        output.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
        for (int i = k; i < arr.length; i++) {
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            if (arr[i] < 0) {
                deque.add(i);
            }
            output.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
        }
        return output;
    }
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053031
1390053035,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <string>
using namespace std;
int main() {
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        string s;
        cin >> s;
        int n = s.size();
        // Compute prefix sums
        vector<int> prefix0(n + 1, 0);
        vector<int> prefix1(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix0[i + 1] = prefix0[i] + (s[i] == '0' ? 1 : 0);
            prefix1[i + 1] = prefix1[i] + (s[i] == '1' ? 1 : 0);
        }
        // Initialize minimum cost with the case of removing everything
        int min_cost = prefix1[n];
        // Iterate over all possible ending indices b
        for (int b = 0; b < n; b++) {
            int k = prefix0[b + 1];               // '0's up to b
            int c = prefix1[n] - prefix1[b + 1];  // '1's from b+1 to n-1
            // Define cost function h(a)
            auto h = [&](int a) {
                int zeros_remaining = k - prefix0[a];
                int ones_removed = prefix1[a] + c;
                return max(zeros_remaining, ones_removed);
            };
            // Ternary search for optimal a in [0, b]
            int left = 0, right = b;
            while (right - left > 2) {
                int m1 = left + (right - left) / 3;
                int m2 = right - (right - left) / 3;
                if (h(m1) < h(m2)) {
                    right = m2;
                } else {
                    left = m1;
                }
            }
            // Check remaining points for exact minimum
            int local_min = INT_MAX;
            for (int a = left; a <= right; a++) {
                local_min = min(local_min, h(a));
            }
            min_cost = min(min_cost, local_min);
        }
        cout << min_cost << endl;
    }
    return 0;
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053035
1390053037,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    ans = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            zeros = 0
            for char in remaining:
                if char == '0':
                    zeros += 1
            ones_removed = 0
            for k in range(i):
                if s[k] == '1':
                    ones_removed += 1
            for k in range(n - j, n):
                if s[k] == '1':
                    ones_removed += 1
            ans = min(ans, max(zeros, ones_removed))
    print(ans)
t = int(input())
for _ in range(t):
    solve()",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053037
1390053025,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053025
1390053019,unknown,unknown,unknown,"from collections import deque
def find_faulty_readings(sensor_data, batch_size):
    faulty_readings = []
    fault_indices = deque()
    for index in range(len(sensor_data)):
        if fault_indices and fault_indices[0] < index - batch_size + 1:
            fault_indices.popleft()
        if sensor_data[index] < 0:
            fault_indices.append(index)
        if index >= batch_size - 1:
            faulty_readings.append(sensor_data[fault_indices[0]] if fault_indices else 0)
    return faulty_readings
num_tests = int(input())
for _ in range(num_tests):
    array_size, batch_size = map(int, input().split())
    sensor_data = list(map(int, input().split()))
    print(*find_faulty_readings(sensor_data, batch_size))",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053019
1390053017,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053017
1390053022,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053022
1390053010,unknown,unknown,unknown,"def min_cost(server_str):
    n = len(server_str)
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
    for i in range(n):
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
    total_1 = prefix_1[n]
    total_0 = prefix_0[n]
    min_cost = float('inf')
    # Try removing l elements from the front
    for l in range(n + 1):
        # Try removing r elements from the back
        for r in range(n - l + 1):
            left = l
            right = n - r
            remaining_0 = prefix_0[right] - prefix_0[left]
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
            cost = max(remaining_0, removed_1)
            min_cost = min(min_cost, cost)
    return min_cost
# Main driver
T = int(input())
for _ in range(T):
    server_str = input().strip()
    print(min_cost(server_str))",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053010
1390053014,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053014
1390053016,unknown,unknown,unknown,"from collections import deque
import sys
def faculty(arr,kq):
    rs =[]
    dq= deque()
    for i in range(len(arr)):
        if dq and dq[0] < i - kq + 1:
            dq.popleft()
        if arr[i]<0:
            dq.append(i)
        if i >= kq -1:
            rs.append(str(arr[dq[0]])if dq else ""0"")
    return "" "".join(rs)
if __name__==""__main__"":
    t=int(sys.stdin.readline().strip())
    for _ in range(t):
        nm, kq = map(int, sys.stdin.readline().strip().split())
        arr=list(map(int,sys.stdin.readline().strip().split()))
        print(faculty(arr,kq))",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053016
1390053006,unknown,unknown,unknown,"def earliest_faulty_reading():
    # Read number of test cases
    t = int(input().strip())
    results = []
    for _ in range(t):
        # Read size of array and batch size
        n, k = map(int, input().strip().split())
        # Read the array elements
        arr = list(map(int, input().strip().split()))
        # Result list for this test case
        result = []
        # Process each batch
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            faulty = next((x for x in batch if x < 0), 0)
            result.append(faulty)
        # Store result as space-separated string
        results.append("" "".join(map(str, result)))
    # Print all results
    print(""\n"".join(results))
# Call the function to take input from user
earliest_faulty_reading()",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053006
1390053009,unknown,unknown,unknown,"import java.util.*;
import java.io.*;
public class FaultySensorReadings {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        int t =sc.nextInt();
        while(t--> 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for(int i = 0; i<n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaultyReadings(arr, n, k);
            for (int val:result) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
    public static List<Integer> findEarliestFaultyReadings(int[] arr, int n, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i<k; i++) {
            if (arr[i]<0){
                deque.addLast(i);
            }
        }
        for (int i = k; i<=n; i++) {
            if (!deque.isEmpty()) {
                result.add(arr[deque.peekFirst()]);
            } else {
                result.add(0);
            }
            while (!deque.isEmpty()  && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            if (i<n && arr[i] < 0) {
                deque.addLast(i);
            }
        }
        return result;
    }
}",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053009
1390053007,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        # Process first k elements
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Process rest of the elements
        for i in range(n - k + 1):
            # Append the first negative number in the current window
            if dq:
                res.append(arr[dq[0]])
            else:
                res.append(0)
            # Remove elements that are out of this window
            if dq and dq[0] == i:
                dq.popleft()
            # Add next element if it's negative
            if i + k < n and arr[i + k] < 0:
                dq.append(i + k)
        results.append("" "".join(map(str, res)))
    return ""\n"".join(results)
# Read input
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    test_cases.append((n, k, arr))
# Process and print output
print(earliest_faulty_readings(test_cases))",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053007
1390053003,unknown,unknown,unknown,"defmin_effort_to_breach(n,firewalls):
    total_effort=sum(firewall)
    min_effort=total_effort
    for i in range(n):
        skipped_effort=total_effort-firealls[i]
        min_effort=min(min_effort,skipped_effort)
    return min_effort
t=int(raw_input(""enter number of testcae ""))
result=[]
for_in range(t):
    n=int(raw_input(""/nEnter number of firewalls:""))
    result.append(min_effort_to_breach(n,firewalls))
print""/noutput""
for res in result:
    print res",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053003
1390052987,unknown,unknown,unknown,"def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        if k >= n:
            print(0)
            continue
        prev = [float('inf')] * (k + 1)
        prev[0] = 0
        for i in range(n):
            curr = [float('inf')] * (k + 1)
            for j in range(k + 1):
                if j > 0 and prev[j-1] != float('inf'):
                    curr[j] = min(curr[j], prev[j-1])
                if prev[j] != float('inf'):
                    curr[j] = min(curr[j], prev[j] + strengths[i] + j)
            prev = curr
        print(min(prev))
if __name__ == ""__main__"":
    main()",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052987
1390052996,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    """"""
    Calculate the minimum effort needed to breach the network.
    Args:
        n (int): Number of firewalls
        k (int): Maximum number of firewalls that can be skipped
        strengths (list): List of firewall strengths
    Returns:
        int: Minimum effort required
    """"""
    # Edge case: if we can skip all firewalls
    if k >= n:
        return 0
    # We need to find the optimal firewalls to skip
    # This is a combinatorial problem
    # First, let's calculate the impact of skipping each firewall
    # Impact = firewall's strength - penalty to subsequent firewalls
    impacts = []
    for i in range(n):
        # If we skip this firewall, we save its strength
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
        impact = strengths[i] - (n - i - 1)
        impacts.append((impact, i))
    # Sort by impact in descending order
    impacts.sort(reverse=True)
    # Select the k firewalls with the highest impact to skip
    to_skip = set(impacts[i][1] for i in range(k))
    # Calculate the total effort
    total_effort = 0
    penalty = 0
    for i in range(n):
        if i in to_skip:
            # Skip this firewall
            penalty += 1
        else:
            # Breach this firewall (with penalty applied)
            total_effort += strengths[i] + penalty
    return total_effort
def solve_test_cases():
    """"""
    Process all test cases and return the minimum effort for each.
    """"""
    t = int(input())  # Number of test cases
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        results.append(min_effort_to_breach(n, k, strengths))
    return results
# Main function to run the solution
def main():
    results = solve_test_cases()
    # Print the results
    for result in results:
        print(result)
if __name__ == ""__main__"":
    main()",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052996
1390052997,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052997
1390052978,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, n, k):
    result = []
    dq = deque()  # Store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process remaining windows
    for i in range(n - k + 1):
        # If deque is not empty, the front of the queue is the earliest negative
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of this window
        if dq and dq[0] == i:
            dq.popleft()
        # Add the next element of the window
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)  # Print space-separated output
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    earliest_faulty_readings(arr, n, k)",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052978
1390052980,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int T=sc.nextInt();
        while(T-- > 0) {
            int n=sc.nextInt(),k=sc.nextInt();
            int[] a=new int[n];
            for(int i=0;i<n;i++) a[i]=sc.nextInt();
            List<Integer> idx=new ArrayList<>();
            for(int i=0;i<n;i++) idx.add(i);
            idx.sort((x,y)->Integer.compare(a[y],a[x]));
            Set<Integer> skip=new HashSet<>();
            for(int i=0;i<k;i++) skip.add(idx.get(i));
            long effort=0;
            int skipped=0;
            for(int i=0;i<n;i++) {
                if(skip.contains(i)) skipped++;
                else effort+=a[i]+skipped;
            }
            System.out.println(effort);
        }
        sc.close();
    }
}",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052980
1390052981,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first k elements
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining elements
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add the current element if it is faulty
        if arr[i] < 0:
            dq.append(i)
        # Store the result for this window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052981
1390052971,unknown,unknown,unknown,"t = int(input())  
for _ in range(t):
    n, k = map(int, input().split()) 
    arr = list(map(int, input().split()))  
    for i in range(n - k + 1):  
        found = 0  
        for j in range(i, i + k):  
            if arr[j] < 0:
                found = arr[j]  
                break
        print(found, end="" "") 
    print() ",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052971
1390052976,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052976
1390052968,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052968
1390052964,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store result for first window
        res.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements not in the current window
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add new element if it's negative
            if arr[i] < 0:
                dq.append(i)
            # Store result for this batch
            res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    return results
# Reading input
t = int(input())  # Number of test cases
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Processing and printing output
for result in earliest_faulty_readings(test_cases):
    print(result)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052964
1390052965,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052965
1390052963,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052963
1390052953,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    // Optimize input/output
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int n, k;
        cin >> n >> k;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        // INF for impossible states , really tough one to solved actually 
        const ll INF = 1e18;
        vector<ll> prev(k + 1, INF);
        prev[0] = 0; 
        for (int i = 0; i < n; i++) {
            vector<ll> curr(k + 1, INF);
            for (int s = 0; s <= k; s++) {
                // Don't skip i
                curr[s] = prev[s] + a[i] + s;
                // Skip i (if possible)
                if (s > 0) {
                    curr[s] = min(curr[s], prev[s - 1]);
                }
            }
            prev = curr; 
        }
        ll ans = *min_element(prev.begin(), prev.end());
        cout << ans << '\n';
    }
    return 0;
}",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052953
1390052958,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052958
1390052961,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().strip().split())
    a = list(map(int, input().strip().split()))
    min_effort = float('inf')
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
        skipped_indices = []
        skipped_count = 0
        current_effort = 0
        current_a = a[:]  # Create a copy to avoid modifying the original list
        for j in range(n):
            if (i >> j) & 1:
                skipped_indices.append(j)
                skipped_count += 1
        if skipped_count <= k:
            skipped_indices.sort()
            offset = 0
            for j in range(n):
                if j in skipped_indices:
                    offset += 1
                    continue
                else:
                    current_effort += current_a[j] + offset
            min_effort = min(min_effort, current_effort)
    print(min_effort)
T = int(input().strip())
for _ in range(T):
    solve()",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052961
1390052947,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int testCases=scanner.nextInt();
        for(int t=0;t<testCases;t++) {
            int n=scanner.nextInt();
            int k=scanner.nextInt();
            int[] arr=new int[n];
            for(int i=0;i<n;i++) arr[i]=scanner.nextInt();
            List<Integer> result=new ArrayList<>();
            for(int i=0;i<=n-k;i++) {
                int earliestFault=0;
                for(int j=i;j<i+k;j++) {
                    if(arr[j]<0) {
                        earliestFault=arr[j];
                        break;
                    }
                }
                result.add(earliestFault);
            }
            for(int res:result) System.out.print(res+"" "");
            System.out.println();
        }
        scanner.close();
    }
}",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052947
1390052944,unknown,unknown,unknown,"def earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        # Check each batch of size k
        batch = arr[i:i+k]
        fault_found = False
        # Find the earliest fault in the current batch
        for num in batch:
            if num < 0:
                result.append(num)
                fault_found = True
                break
        # If no fault is found in the batch, append 0
        if not fault_found:
            result.append(0)
    return result
# Process the input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))  # Array elements
    result = earliest_fault(arr, k)
    print(*result)  # Print the result",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052944
1390052951,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int tCase = sc.nextInt();
        l1: 
        while (tCase-- > 0) {
            int n=sc.nextInt();
            int k=sc.nextInt();
            int[] arr=new int[n];
            long sum=0;
            for(int i=0; i<n; i++){
                arr[i]=sc.nextInt();
            }
            Arrays.sort(arr);
            for(int i=0; i<n-k; i++){
                sum+=(long)arr[i];
            }
            if(k!=n)sum+=k;
            System.out.println(sum);
        }
    }
}",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052951
1390052934,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # If there is a negative element, record it; otherwise, record 0
    if dq:
        result.append(arr[dq[0]])
    else:
        result.append(0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        if dq and dq[0] <= i - k:
            dq.popleft()
        # Add current element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Append the earliest negative or 0
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
    return result
# Input and Output Handling
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_faulty_reading(arr, k)
    print(' '.join(map(str, result)))",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052934
1390052935,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin>>t;
    while(t--)
    {
        int n,k;
        cin>>n>>k;
        vector<int> input(n);
        for(int i=0;i<n;i++)
        {
            int ele;
            cin>>ele;
            input[i]=ele;
        }
        vector<int> ans;
        int i=0;
        int j=0;
        queue<int> q;//would store indices of -ve
        while(j<k)
        {
            if(input[j]<0)
                q.push(j);
            j++;
        }
        j--;
        while(j<n)
        {   
            if(q.empty())
                ans.push_back(0);
            else
            ans.push_back(input[q.front()]);
            if(q.front()==i)
                q.pop();
            i++;
            j++;
            if(j<n && input[j]<0)
                q.push(j);
        }
        for(auto &el:ans)
            cout<<el<<"" "";
        cout<<endl;
    }
    return 0;
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052935
1390052939,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
vector<int> faults(vector<int>& arr, int n, int k){
    vector<int> ans;
    for(int i=0; i<=n-k; i++){
        int eFault = 0;
        for(int j=i; j<i+k; j++){
            if(arr[j]<0){
                eFault = arr[j];
                break;
            }
        }
        ans.push_back(eFault);
    }
    return ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
    int t;
    cin>>t;
    while(t--){
        int n, k;
        cin>>n>>k;
        vector<int> arr(n);
        for(int i=0; i<n; i++){
            cin>>arr[i];
        }
        vector<int> ans;
        ans = faults(arr, n, k);
        for(int val: ans){
            cout<<val<<"" "";
        }
        cout<<endl;
    }
    return 0;
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052939
1390052930,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
t = int(input())
while t:
    a, b = map(int, input().split())
    c = list(map(int, input().split()))
    ans = []
    for i in range(0, len(c)-int(b)+1):
        for j in c[i:i+b]:
            if j < 0:
                ans.append(j)
                break
        else:
            ans.append(0)
    for i in ans:
        print(i, end="" "")
    print()
    t -= 1",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052930
1390052932,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int n = s.length();
        // Count total active servers (1s) and idle servers (0s)
        int totalOnes = 0, totalZeros = 0;
        for (char c : s) {
            if (c == '1') totalOnes++;
            else totalZeros++;
        }
        int minCost = n; // Worst case
        // Try all combinations of prefix (left) and suffix (right) removals
        // Prefix i = number of characters removed from start
        for (int prefix = 0; prefix <= n; prefix++) {
            int onesRemovedLeft = 0;
            int zerosRemovedLeft = 0;
            for (int i = 0; i < prefix; i++) {
                if (s[i] == '1') onesRemovedLeft++;
                else zerosRemovedLeft++;
            }
            // Now, try all possible suffix removals
            for (int suffix = 0; suffix <= n - prefix; suffix++) {
                int onesRemovedRight = 0;
                int zerosRemovedRight = 0;
                for (int i = n - suffix; i < n; i++) {
                    if (s[i] == '1') onesRemovedRight++;
                    else zerosRemovedRight++;
                }
                int totalOnesRemoved = onesRemovedLeft + onesRemovedRight;
                int totalZerosRemoved = zerosRemovedLeft + zerosRemovedRight;
                int remainingZeros = totalZeros - totalZerosRemoved;
                int cost = max(remainingZeros, totalOnesRemoved);
                minCost = min(minCost, cost);
            }
        }
        cout << minCost << endl;
    }
    return 0;
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052932
1390052931,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static long minEffort(int[] f, int n, int k) {
        long[] dp=new long[n+1];
        Arrays.fill(dp,Long.MAX_VALUE);
        dp[n]=0;
        for(int i=n-1;i>=0;i--) {
            long str=f[i];
            for(int j=0;j<=k && i+j<=n;j++) {
                if(j==0) dp[i]=Math.min(dp[i],str+dp[i+1]);
                else {
                    long e=(i+j<n)?dp[i+j+1]+j:0;
                    for(int m=i+j;m<n;m++) e+=f[m];
                    dp[i]=Math.min(dp[i],e);
                }
            }
        }
        return dp[0];
    }
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(t-- > 0) {
            int n=sc.nextInt(),k=sc.nextInt();
            int[] f=new int[n];
            for(int i=0;i<n;i++) f[i]=sc.nextInt();
            System.out.println(minEffort(f,n,k));
        }
        sc.close();
    }
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052931
1390052927,unknown,unknown,unknown,"from collections import deque
def earliest_fault_in_batches(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(len(arr) - k + 1):
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        while dq and dq[0] < i + 1:
            dq.popleft()
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_fault_in_batches(arr, k))",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052927
1390052928,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        int arr[n];
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        for (int i = 0; i <= n - k; i++) {
            int sign = 0;
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    cout << arr[j] << "" "";
                    sign = 1;
                    break; 
                }
            }
            if (!sign) {
                cout << ""0 "";
            }
        }
        cout << endl;  
    }
    return 0;
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052928
1390052929,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k, readings = case
        result = []
        dq = deque()  # Stores indices of negative numbers
        # Process the first window
        for i in range(k):
            if readings[i] < 0:
                dq.append(i)
        # Process the sliding windows
        for i in range(n - k + 1):
            # Append the first negative in the deque, or 0 if empty
            result.append(readings[dq[0]] if dq else 0)
            # Remove elements that are out of this window
            if dq and dq[0] == i:
                dq.popleft()
            # Add next element (i + k) to the deque if it's negative
            if i + k < n and readings[i + k] < 0:
                dq.append(i + k)
        results.append("" "".join(map(str, result)))  # Convert list to space-separated string
    return ""\n"".join(results)
# Example Usage
t = 2
test_cases = [
    (5, 2, [-8, 2, 3, -6, 10]),
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
]
print(earliest_faulty_readings(t, test_cases))",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052929
1390052926,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052926
1390052922,unknown,unknown,unknown,"def min_decommissioning_cost(test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        total_zeros = servers.count('0')
        total_ones = servers.count('1')
        min_cost = float('inf')
        for i in range(n + 1):  
            for j in range(n + 1):  
                if i + j > n:
                    continue 
                active_decommissioned = servers[:i].count('1') + servers[n-j:].count('1')
                remaining_zeros = total_zeros - (servers[:i].count('0') + servers[n-j:].count('0'))
                cost = max(active_decommissioned, remaining_zeros)
                min_cost = min(min_cost, cost)
        results.append(min_cost)
    return results
T = int(input())
test_cases = [input().strip() for _ in range(T)]
results = min_decommissioning_cost(test_cases)
for result in results:
    print(result)",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052922
1390052925,unknown,unknown,unknown,"def min_cost(servers):
    n = len(servers)
    min_cost_val = float('inf')
    for i in range(n + 1): 
        for j in range(n - i + 1):  
            remaining_servers = servers[i:n - j]
            idle_count = remaining_servers.count('0')
            active_removed = servers[:i].count('1') + servers[n - j:].count('1')
            cost = max(idle_count, active_removed)
            min_cost_val = min(min_cost_val, cost)
    return min_cost_val
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        servers = input()
        print(min_cost(servers))",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052925
1390052921,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())  
        arr = list(map(int, input().split()))  
        results.append(earliest_faulty_readings(arr, k))
    for res in results:
        print(*res)
process_test_cases()",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052921
1390052917,unknown,unknown,unknown,"def minimum_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        if k >= n:
            results.append(0)
            continue
        # Calculate the total effort if no firewalls are skipped
        total_effort = sum(a)
        # Calculate the reduction for each firewall if it were skipped
        # The reduction is a[i] - (number of firewalls after it)
        # Because each skipped firewall increases the strength of all subsequent firewalls by 1
        reduction = []
        for i in range(n):
            reduction.append(a[i] - (n - i - 1))
        # Sort the reduction values in descending order
        reduction.sort(reverse=True)
        # Sum the top k reductions
        max_reduction = sum(reduction[:k])
        # Subtract the maximum reduction from the total effort
        results.append(total_effort - max_reduction)
    return results
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx])
    idx += 1
    test_cases = []
    for _ in range(T):
        n, k = int(data[idx]), int(data[idx + 1])
        idx += 2
        a = list(map(int, data[idx:idx + n]))
        idx += n
        test_cases.append((n, k, a))
    results = minimum_effort(test_cases)
    for res in results:
        print(res)
if __name__ == ""__main__"":
    main()",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052917
1390052919,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        # Calculate the potential reduction for each firewall if skipped
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
        # Because skipping it increases the strength of all subsequent firewalls by 1
        # So, the net reduction is a[i] - (n - i - 1)
        reductions = []
        for i in range(n):
            reductions.append(a[i] - (n - i - 1))
        # Select the top k reductions (most positive)
        # If a reduction is negative, it's better not to skip that firewall
        # So, we only consider positive reductions
        positive_reductions = [r for r in reductions if r > 0]
        positive_reductions.sort(reverse=True)
        # Take the top min(k, len(positive_reductions)) reductions
        skip_count = min(k, len(positive_reductions))
        total_reduction = sum(positive_reductions[:skip_count])
        # Calculate the total effort
        # Initial total effort is sum(a)
        # After skipping, the total effort is sum(a) - total_reduction
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
        # This is getting complicated. Let's think differently.
        # Alternative approach:
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
        # Skip the top k firewalls in this order
        # Calculate the total effort accordingly
        # Let's implement this alternative approach
        # Create a list of tuples (a[i], i)
        firewall_indices = [(a[i], i) for i in range(n)]
        # Sort by a[i] - (n - i - 1) in descending order
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
        # Select the top k firewalls to skip
        skip_indices = set()
        for i in range(min(k, n)):
            skip_indices.add(firewall_indices[i][1])
        # Calculate the total effort
        total_effort = 0
        increase = 0
        for i in range(n):
            if i in skip_indices:
                increase += 1
            else:
                total_effort += a[i] + increase
        results.append(total_effort)
    return results
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    test_cases.append((n, k, a))
# Compute results
results = min_effort(test_cases)
# Output results
for res in results:
    print(res)",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052919
1390052920,unknown,unknown,unknown,"def solution(n, k, arr):
    result = []
    for i in range(n - k + 1):  
        found_faulty = False
        for j in range(k):
            if arr[i + j] < 0:
                result.append(arr[i + j]) 
                found_faulty = True
                break
        if not found_faulty:
            result.append(0)  
    return "" "".join(map(str, result))  
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(solution(n, k, arr))",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052920
1390052906,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of this window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052906
1390052908,unknown,unknown,unknown,"def calculate_minimum_cost(rack):
    n = len(rack)
    min_cost = float('inf')
    for i in range(n+1):
        for j in range(n+1):
            if i + j <= n:
                remaining_rack = rack[i:n-j]
                idle_servers = remaining_rack.count('0')
                active_servers_removed = rack[:i].count('1') + rack[n-j:].count('1')
                cost = max(idle_servers, active_servers_removed)
                min_cost = min(min_cost, cost)
    return min_cost
def process_test_cases():
    t = int(input()) 
    for _ in range(t):
        rack = input().strip()  
        print(calculate_minimum_cost(rack))
process_test_cases()",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052908
1390052910,unknown,unknown,unknown,"import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int j = 0; j < n; j++) {
                a[j] = scanner.nextInt();
            }
            solve(n, k, a);
        }
        scanner.close();
    }
    public static void solve(int n, int k, int[] a) {
        long minEffort = Long.MAX_VALUE;
        // Try all possible combinations of skipping elements
        for (int i = 0; i < (1 << n); i++) {
            int skippedCount = 0;
            // Count how many elements are skipped in this combination
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) != 0) {
                    skippedCount++;
                }
            }
            // If the number of skipped elements is within the allowed limit
            if (skippedCount <= k) {
                long effort = 0;
                int increasedStrength = 0;
                int skippedIndex = 0;
                int[] skipped = new int[skippedCount];
                int skippedPtr = 0;
                //store the indexes of the skipped elements
                for (int j = 0; j < n; j++){
                    if((i & (1 << j)) != 0){
                        skipped[skippedPtr++] = j;
                    }
                }
                // Calculate the effort for this combination
                for (int j = 0; j < n; j++) {
                    // If this element is skipped, increase strength
                    if (skippedIndex < skippedCount && skipped[skippedIndex] == j) {
                        increasedStrength++;
                        skippedIndex++;
                    } else {
                        // Otherwise, add effort
                        effort += (long) a[j] + increasedStrength;
                    }
                }
                // Update the minimum effort if this combination is better
                minEffort = Math.min(minEffort, effort);
            }
        }
        System.out.println(minEffort);
    }
}",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052910
1390052905,unknown,unknown,unknown,"def earliest_faulty_readings(test_cases):
    results = []
    for _ in range(test_cases):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            faulty = 0
            for num in batch:
                if num < 0:
                    faulty = num
                    break
            result.append(faulty)
        results.append(result)
    return results
# Read the number of test cases
test_cases = int(input())
results = earliest_faulty_readings(test_cases)
# Print the results
for result in results:
    print(' '.join(map(str, result)) + ' ')",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052905
1390052899,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store result for first window
    result.append(arr[dq[0]] if dq else 0)
    # Process remaining windows
    for i in range(k, n):
        # Remove out-of-window elements
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Append the earliest fault or 0 if none
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052899
1390052902,unknown,unknown,unknown,"from collections import deque
def faul_read(arr, k):
    n = len(arr)
    res = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    res.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        res.append(arr[dq[0]] if dq else 0)
    return res
t = int(input())
for _ in range(t):
    n, k = map(int, input().split()) 
    arr = list(map(int, input().split())) 
    print(*faul_read(arr, k))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052902
1390052904,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, len(arr)):
        if dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    print(*result)
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    earliest_faulty_readings(arr, k)",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052904
1390052898,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<bits/stdc++.h>
using namespace std;
vector<int> solve(vector<int>& arr, int k){
    int n = arr.size();
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    for(int i=0; i<n; i++){
        if(arr[i]<0) pq.push({i,arr[i]});
    }
    vector<int> ans;
    for(int i=k-1; i<n; i++){
        int idx=-1,val=INT_MAX;
        if(!pq.empty()){
            idx=pq.top().first;
            val=pq.top().second;
        }
        if(idx<=i && val<0) ans.push_back(val);
        else ans.push_back(0);
        while(!pq.empty() && pq.top().first<=i-k+1){
            pq.pop();
        }
    }
    return ans;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    cin>>t;
    while(t--){
        int n,k;
        cin>>n>>k;
        vector<int> arr(n);
        for(int i=0; i<n; i++) cin>>arr[i];
        vector<int> ans = solve(arr,k);
        for(auto &i : ans) cout<<i<<"" "";
        cout<<endl;
    }
    return 0;
}",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052898
1390052893,unknown,unknown,unknown,"def minimum_effort(n, k, arr):
    total_sum = sum(arr)
    if k == n:
        return 0
    prefix_sum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]
    min_effort = total_sum
    for start in range(n - k + 1):
        skip_sum = prefix_sum[start + k] - prefix_sum[start]
        remaining_effort = total_sum - skip_sum + (n - (start + k))
        min_effort = min(min_effort, remaining_effort)
    return min_effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = minimum_effort(n, k, arr)
    print(result)",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052893
1390052884,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    print(*earliest_faulty_readings(arr, k))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052884
1390052885,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    total_effort = sum(firewalls)
    if k == n:
        return 0
    min_effort = total_effort  
    for i in range(n):
        skipped_effort = total_effort - firewalls[i] 
        increased_security = (n - i - 1) 
        skipped_effort += increased_security  
        min_effort = min(min_effort, skipped_effort)
    return min_effort
# Read input
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort_to_breach(n, k, firewalls))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052885
1390052887,unknown,unknown,unknown,"def ans(x):
    n = len(x)
    min_cost = float('inf')
    for left in range(n + 1):
        for right in range(n + 1):
            if left + right > n:
                continue
            rem = x[left:n - right]
            idle_rem = rem.count('0')
            act_dec = x[:left].count('1') + x[n - right:].count('1')
            cost = max(idle_rem, act_dec)
            if cost < min_cost:
                min_cost = cost
    return min_cost
T = int(input())
for _ in range(T):
    x = input().strip()
    print(ans(x))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052887
1390052883,unknown,unknown,unknown,"def earliest_faulty_in_batches(arr, n, k):
    result = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        found_fault = False
        for num in batch:
            if num < 0:
                result.append(num)
                found_fault = True
                break
        if not found_fault:
            result.append(0)
    return result
t = int(input().strip())
outputs = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    outputs.append(earliest_faulty_in_batches(arr, n, k))
for output in outputs:
    print("" "".join(map(str, output)))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052883
1390052871,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    # Create list of (value + index) for each firewall
    skip_value = []
    for i in range(n):
        skip_value.append((firewalls[i] + i, i))
    # Sort by descending benefit to skip
    skip_value.sort(reverse=True)
    # Mark which firewalls to skip
    skipped = [0] * n
    for i in range(k):
        _, idx = skip_value[i]
        skipped[idx] = 1
    # Now calculate final effort
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
# Main driver
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))
    ",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052871
1390052875,unknown,unknown,unknown,"def min_firewall_effort(n, k, firewalls):
    min_effort = float('inf')
    for i in range(1 << n):  
        skipped_count = bin(i).count('1')
        if skipped_count <= k:
            current_effort = 0
            current_firewalls = firewalls[:]  
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            skipped_indices.sort()
            for index in skipped_indices:
                for l in range(index + 1, n):
                    current_firewalls[l] += 1
            for j in range(n):
                if not (i >> j) & 1:
                    current_effort += current_firewalls[j]
            min_effort = min(min_effort, current_effort)
    return min_effort
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        result = min_firewall_effort(n, k, firewalls)
        print(result)",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052875
1390052880,unknown,unknown,unknown,"def min_decommission_cost(test_cases):
    results = []
    for s in test_cases:
        first, last = s.find('1'), s.rfind('1')
        if first == -1: 
            results.append(0)
            continue
        # Count 0's between the first and last '1'
        idle_servers = s[first:last + 1].count('0')
        # Count 1's outside the range [first, last]
        active_removed = s[:first].count('1') + s[last + 1:].count('1')
        results.append(max(idle_servers, active_removed))
    return results
t = int(input())
test_cases = [input().strip() for _ in range(t)]
for output in min_decommission_cost(test_cases):
    print(output)",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052880
1390052865,unknown,unknown,unknown,"def calculate_minimum_cost(rack):
    n = len(rack)
    min_cost = float('inf')
    for i in range(n+1):
        for j in range(n+1):
            if i + j <= n:
                remaining_rack = rack[i:n-j]
                idle_servers = remaining_rack.count('0')
                active_servers_removed = rack[:i].count('1') + rack[n-j:].count('1')
                cost = max(idle_servers, active_servers_removed)
                min_cost = min(min_cost, cost)
    return min_cost
def process_test_cases():
    t = int(input())  
    for _ in range(t):
        rack = input().strip()  
        print(calculate_minimum_cost(rack))
process_test_cases()",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052865
1390052869,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        if k == n:
            results.append(""0"")  # If we can skip all firewalls, effort is 0
            continue
        total_effort = sum(firewalls)
        min_effort = total_effort
        # Compute initial window sum of the first k firewalls
        window_sum = sum(firewalls[:k])
        # Calculate the increasing penalty sum dynamically
        penalty_sum = k * (k + 1) // 2  # Sum of first k natural numbers
        for i in range(n - k + 1):
            new_effort = total_effort - window_sum + penalty_sum
            min_effort = min(min_effort, new_effort)
            # Move the sliding window
            if i + k < n:
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
        results.append(str(min_effort))
    return ""\n"".join(results)
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(T, test_cases))",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052869
1390052867,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            String rack = sc.next();
            int n = rack.length();
            int[] prefixZero = new int[n + 1];
            int[] prefixOne = new int[n + 1];
            for (int i = 0; i < n; i++) {
                prefixZero[i + 1] = prefixZero[i] + (rack.charAt(i) == '0' ? 1 : 0);
                prefixOne[i + 1] = prefixOne[i] + (rack.charAt(i) == '1' ? 1 : 0);
            }
            int minCost = n;
            for (int i = 0; i <= n; i++) {
                int onesInPrefix = prefixOne[i];
                int zerosBefore = prefixZero[i];
                for (int j = 0; j <= n - i; j++) {
                    // Remaining segment: from index i to (n-1-j)
                    int onesInSuffix = prefixOne[n] - prefixOne[n - j];
                    int zerosInSuffix = prefixZero[n] - prefixZero[n - j];
                    int idleRemaining = (prefixZero[n] - zerosBefore - zerosInSuffix);
                    int activeDecommissioned = onesInPrefix + onesInSuffix;
                    int cost = Math.max(idleRemaining, activeDecommissioned);
                    minCost = Math.min(minCost, cost);
                }
            }
            // Special case: must decommission at least from the beginning
            if (minCost == prefixOne[n] && prefixOne[n] > 0) {
                minCost = Math.min(minCost, Math.max(prefixZero[n], prefixOne[n] - prefixOne[1]));
            }
            System.out.println(minCost);
        }
        sc.close();
    }
}",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052867
1390052861,unknown,unknown,unknown,"def min_effort_to_breach(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        min_effort = sum(firewalls)  # Default case: No skips
        for i in range(n - k + 1):  # Try skipping from each valid position
            effort = sum(firewalls[:i])  # Effort before skipped firewalls
            extra_security = 0
            for j in range(i, n):
                if j - i < k:  # Skip up to k firewalls
                    extra_security += 1
                else:
                    effort += firewalls[j] + extra_security  # Apply increment effect
            min_effort = min(min_effort, effort)
        results.append(min_effort)
    return ""\n"".join(map(str, results))
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(test_cases))",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052861
1390052862,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();  // Number of test cases
        while (t-- > 0) {
            int n = s.nextInt();
            int k = s.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = s.nextInt();
            }
            // Using a queue to track the index of negative numbers
            Queue<Integer> queue = new LinkedList<>();
            int i = 0;
            // Process first window
            for (i = 0; i < k; i++) {
                if (arr[i] < 0) {
                    queue.add(i);
                }
            }
            // Process remaining windows
            for (; i < n; i++) {
                // Print first negative number of previous window
                if (!queue.isEmpty()) {
                    System.out.print(arr[queue.peek()] + "" "");
                } else {
                    System.out.print(""0 "");
                }
                // Remove elements that are out of this window
                while (!queue.isEmpty() && queue.peek() <= i - k) {
                    queue.poll();
                }
                // Add current element if it's negative
                if (arr[i] < 0) {
                    queue.add(i);
                }
            }
            // Print for last window
            if (!queue.isEmpty()) {
                System.out.print(arr[queue.peek()] + "" "");
            } else {
                System.out.print(""0 "");
            }
            System.out.println();
        }
        s.close();
    }
}",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052862
1390052863,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n - j]
            idle_remaining = remaining.count('0')
            active_removed = s[:i].count('1') + s[n - j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052863
1390052860,unknown,unknown,unknown,"import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int j = 0; j < n; j++) {
                a[j] = scanner.nextInt();
            }
            solve(n, k, a);
        }
        scanner.close();
    }
    public static void solve(int n, int k, int[] a) {
        long minEffort = Long.MAX_VALUE;
        for (int i = 0; i < (1 << n); i++) {
            int skippedCount = Integer.bitCount(i);
            if (skippedCount <= k) {
                long effort = 0;
                int increasedStrength = 0;
                int currentSkippedIndex = 0;
                int[] skippedIndices = new int[skippedCount];
                int skippedIndexPointer = 0;
                for (int j = 0; j < n; j++) {
                    if ((i & (1 << j)) != 0) {
                        skippedIndices[skippedIndexPointer++] = j;
                    }
                }
                for (int j = 0; j < n; j++) {
                    if (currentSkippedIndex < skippedCount && currentSkippedIndex < skippedIndices.length && skippedIndices[currentSkippedIndex] == j) {
                        increasedStrength++;
                        currentSkippedIndex++;
                    } else {
                        effort += (long) a[j] + increasedStrength;
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
        }
        System.out.println(minEffort);
    }
}",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052860
1390052852,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            if dq:
                result.append(arr[dq[0]])  
            else:
                result.append(0)  
    return result
def process_test_cases():
    t = int(input())  # number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  
        arr = list(map(int, input().split()))  
        result = earliest_faulty_reading(arr, k)
        print(' '.join(map(str, result)))
process_test_cases()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052852
1390052854,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int T=sc.nextInt();
        while(T-- > 0) {
            int n=sc.nextInt(),k=sc.nextInt();
            int[] a=new int[n];
            for(int i=0;i<n;i++) a[i]=sc.nextInt();
            List<Integer> idx=new ArrayList<>();
            for(int i=0;i<n;i++) idx.add(i);
            idx.sort((x,y)->Integer.compare(a[y],a[x]));
            Set<Integer> skip=new HashSet<>();
            for(int i=0;i<k;i++) skip.add(idx.get(i));
            long effort=0;
            int skips=0;
            for(int i=0;i<n;i++) {
                if(skip.contains(i)) skips++;
                else effort+=a[i]+skips;
            }
            System.out.println(effort);
        }
        sc.close();
    }
}",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052854
1390052856,unknown,unknown,unknown,"# Enter your code here. Read input from STDIN. Print output to STDOUT
from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first window of size k
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the new element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input().strip())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # Read n and k
        arr = list(map(int, input().split()))  # Read array elements
        # Get the earliest faulty readings
        output = earliest_faulty_readings(arr, k)
        # Print result as space-separated values
        print("" "".join(map(str, output)))
if __name__ == ""__main__"":
    main()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052856
1390052842,unknown,unknown,unknown,"from collections import deque
import sys
def find_earliest_faults(n, k, arr):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Iterate through all possible windows
    for i in range(n - k + 1):
        # Get the earliest faulty reading in the window
        result.append(arr[dq[0]] if dq else 0)
        # Remove elements that are out of the current window
        if dq and dq[0] == i:
            dq.popleft()
        # Add the next element from the upcoming window
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(sys.stdin.readline())  # Number of test cases
output = []
for _ in range(t):
    n, k = map(int, sys.stdin.readline().split())
    arr = map(int, sys.stdin.readline().split())
    output.append("" "".join(map(str, find_earliest_faults(n, k, arr))))
# Print the final output
sys.stdout.write(""\n"".join(output) + ""\n"")",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052842
1390052845,unknown,unknown,unknown,"#include <iostream>
#include <vector>
using namespace std;
int main() {
    int t; 
    cin >> t;
    while(t--){
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++){
            cin >> arr[i];
        }
        if(n < k) {
            cout << -1 << endl;
            continue;
        }
        vector<int> ans;
        int negIndex = 0;
        for (int i = 0; i <= n - k; i++){
            if(negIndex < i) 
                negIndex = i;
            while(negIndex < i + k && arr[negIndex] >= 0)
                negIndex++;
            if(negIndex < i + k) 
                ans.push_back(arr[negIndex]);
            else 
                ans.push_back(0);
        }
        for (int num : ans)
            cout << num << "" "";
        cout << endl;
    }
    return 0;
}",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052845
1390052850,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Try all possible combinations of removing servers from beginning and end
    min_cost = float('inf')
    # Convert to list of integers for easier processing
    servers = [int(c) for c in server_string]
    # Precompute prefix and suffix sums for ones
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + servers[i]
    # Total ones in the string
    total_ones = prefix_ones[n]
    for i in range(n + 1):  # i servers removed from beginning
        for j in range(n + 1 - i):  # j servers removed from end
            if i + j == n:  # Skip if removing all servers
                continue
            # Calculate ones removed from beginning and end
            ones_removed_left = prefix_ones[i]
            ones_removed_right = total_ones - prefix_ones[n-j]
            total_ones_removed = ones_removed_left + ones_removed_right
            # Calculate zeros remaining in the middle portion
            middle_length = n - i - j
            middle_ones = prefix_ones[n-j] - prefix_ones[i]
            middle_zeros = middle_length - middle_ones
            # Calculate cost
            cost = max(middle_zeros, total_ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        server_string = input().strip()
        result = min_decommission_cost(server_string)
        print(result)
# Execute the solution
solve()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052850
1390052838,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052838
1390052839,unknown,unknown,unknown,"def min_decommission_cost(servers):
    n = len(servers)
    min_cost = float('inf')
    for i in range(n):
        for j in range(i, n):
            kept_substr = servers[i:j+1]
            idle_remaining = kept_substr.count('0')
            active_removed = servers[:i].count('1') + servers[j+1:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        servers = input().strip()
        result = min_decommission_cost(servers)
        print(result)
if __name__ == ""__main__"":
    solve()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052839
1390052840,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    if k >= n:
        return 0
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + strengths[i]
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            if dp[i-1][j] != float('inf'):
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
        for j in range(k):
            if dp[i-1][j] != float('inf'):
                dp[i][j+1] = min(dp[i][j+1], dp[i-1][j])
    return min(dp[n])
def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        print(min_effort_to_breach(n, k, strengths))
if __name__ == ""__main__"":
    main()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052840
1390052832,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>(); 
        for (int i = 0; i < arr.length; i++) {
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            if (arr[i] < 0) {
                deque.offer(i);
            }
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        for (int num : result) {
            System.out.print(num + "" "");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            findEarliestFaults(arr, k);
        }
        scanner.close();
    }
}",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052832
1390052819,unknown,unknown,unknown,"def min_decommissioning_cost(t, test_cases):
    results = []
    for servers in test_cases:
        n = len(servers)
        # Count total idle and active servers
        total_idle = servers.count('0')
        total_active = servers.count('1')
        # If there are no active servers, cost is 0
        if total_active == 0:
            results.append(0)
            continue
        min_cost = float('inf')
        left_idle = 0  # Idle servers removed from the left
        left_active = 0  # Active servers removed from the left
        for i in range(n + 1):  # Try removing from the left
            right_idle = total_idle - left_idle
            right_active = total_active - left_active
            # Try removing from the right as well
            for j in range(n + 1 - i):
                remaining_idle = right_idle - servers[n - j:].count('0')
                removed_active = left_active + servers[n - j:].count('1')
                # Cost is max of remaining idle and removed active
                cost = max(remaining_idle, removed_active)
                min_cost = min(min_cost, cost)
            # Update left counters if we haven't processed all characters
            if i < n:
                if servers[i] == '0':
                    left_idle += 1
                else:
                    left_active += 1
        results.append(min_cost)
    return results
# Reading input
t = int(input().strip())
test_cases = [input().strip() for _ in range(t)]
# Compute results
results = min_decommissioning_cost(t, test_cases)
# Output results
for res in results:
    print(res)",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052819
1390052827,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
            Deque<Integer> dq = new LinkedList<>();
            for (int i = 0; i < n; i++) {
                if (arr[i] < 0) dq.addLast(i);
                if (i >= k - 1) {
                    while (!dq.isEmpty() && dq.peekFirst() < i - k + 1) dq.pollFirst();
                    System.out.print((dq.isEmpty() ? 0 : arr[dq.peekFirst()]) + "" "");
                }
            }
            System.out.println();
        }
        sc.close();
    }
}",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052827
1390052826,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()  # Stores indices of negative numbers in the current window
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of the current window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input().strip())
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    # Get the result and print it
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052826
1390052807,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052807
1390052811,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()  # To store indices of negative values
    for i in range(len(arr)):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # If the current element is faulty, add it to the deque
        if arr[i] < 0:
            dq.append(i)
        # If we have processed at least k elements, find the earliest fault
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Read n and k
    arr = list(map(int, input().split()))  # Read array elements
    # Get the result and print it
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052811
1390052816,unknown,unknown,unknown,"import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int j = 0; j < n; j++) {
                a[j] = scanner.nextInt();
            }
            solve(n, k, a);
        }
        scanner.close();
    }
    public static void solve(int n, int k, int[] a) {
        long minEffort = Long.MAX_VALUE;
        for (int i = 0; i < (1 << n); i++) {
            int skippedCount = Integer.bitCount(i);
            if (skippedCount <= k) {
                long effort = 0;
                int increasedStrength = 0;
                int currentSkippedIndex = 0;
                int[] skippedIndices = new int[skippedCount];
                int skippedIndexPointer = 0;
                for (int j = 0; j < n; j++) {
                    if ((i & (1 << j)) != 0) {
                        skippedIndices[skippedIndexPointer++] = j;
                    }
                }
                for (int j = 0; j < n; j++) {
                    if (currentSkippedIndex < skippedCount && skippedIndices[currentSkippedIndex] == j) {
                        increasedStrength++;
                        currentSkippedIndex++;
                    } else {
                        effort += (long) a[j] + increasedStrength;
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
        }
        System.out.println(minEffort);
    }
}",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052816
1390052801,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    min_cost = float('inf')
    best_left = 0
    best_right = 0
    # Try all possible combinations of removing servers from left and right
    for left in range(n + 1):  # Number of servers to remove from left
        for right in range(n + 1 - left):  # Number of servers to remove from right
            # The remaining servers after decommissioning
            remaining = server_string[left:n-right]
            if not remaining:  # If all servers are decommissioned
                idle_remaining = 0
                active_removed = server_string.count('1')
            else:
                idle_remaining = remaining.count('0')
                # Calculate active servers removed
                left_part = server_string[:left]
                right_part = server_string[n-right:]
                active_removed = left_part.count('1') + right_part.count('1')
            # Cost is the maximum of idle remaining and active removed
            cost = max(idle_remaining, active_removed)
            if cost < min_cost:
                min_cost = cost
                best_left = left
                best_right = right
    return min_cost
def main():
    t = int(input().strip())
    for _ in range(t):
        server_string = input().strip()
        result = min_decommission_cost(server_string)
        print(result)
if __name__ == ""__main__"":
    main()",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052801
1390052802,unknown,unknown,unknown,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    min_effort = float('inf')
    for i in range(1 << n):  
        skipped_indices = []
        skipped_count = 0
        current_effort = 0
        current_a = a[:]  
        for j in range(n):
            if (i >> j) & 1:
                skipped_indices.append(j)
                skipped_count += 1
        if skipped_count <= k:
            skipped_indices.sort()
            offset = 0
            for j in range(n):
                if j in skipped_indices:
                    offset+=1
                    continue;
                else:
                    current_effort += current_a[j] + offset;
            min_effort = min(min_effort, current_effort)
    print(min_effort)
T = int(input())
for _ in range(T):
    solve()",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052802
1390052797,unknown,unknown,unknown,"from collections import deque
def find_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        result = []
        for i in range(n - k + 1):
            batch = arr[i:i+k]
            found_fault = False
            for num in batch:
                if num < 0: 
                    result.append(num)
                    found_fault = True
                    break
            if not found_fault:
                result.append(0)  
        results.append(result)
    return results
t = int(input()) 
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split())) 
    test_cases.append((n, k, arr))
results = find_faulty_readings(test_cases)
for result in results:
    print("" "".join(map(str, result)))",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052797
1390052793,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(n):
            if arr[i] < 0:
                dq.append(i)
            if i >= k - 1:
                while dq and dq[0] < i - k + 1:
                    dq.popleft()
                res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    print(""\n"".join(results))
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
earliest_faulty_readings(test_cases)",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052793
1390052794,unknown,unknown,unknown,"from collections import deque
def earliest_faculty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(n - k + 1):
        result.append(arr[dq[0]] if dq else 0)
        if dq and dq[0] == i:
            dq.popleft()
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int,input().split()))
    print(*earliest_faculty_readings(arr, k))",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052794
1390052795,unknown,unknown,unknown,"def minimum_effort(n, k, arr):
    total_sum = sum(arr)
    if k == n:
        return 0
    current_window_sum = sum(arr[:k])
    min_effort = total_sum - current_window_sum + (n - k)
    for i in range(1, n - k + 1):
        current_window_sum += arr[i + k - 1] - arr[i - 1]
        effort = total_sum - current_window_sum + (n - (i + k))
        min_effort = min(min_effort, effort)
    return min_effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = minimum_effort(n, k, arr)
    print(result)",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052795
1390052786,unknown,unknown,unknown,"def min_effort(test_cases):
    results = []
    for n, k, arr in test_cases:
        if k == n:
            results.append(0)
            continue
        total_effort = sum(arr)
        min_effort = total_effort
        for i in range(n):
            effort = total_effort - arr[i] + (n - 1) * k
            min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
t = int(input())
test_cases = [(lambda n, k, arr: (n, k, arr))(*map(int, input().split()), list(map(int, input().split()))) for _ in range(t)]
for output in min_effort(test_cases):
    print(output)",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052786
1390052787,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>(); 
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                deque.addLast(i);
            }
        }
        result.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
        for (int i = k; i < arr.length; i++) {
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            if (arr[i] < 0) {
                deque.addLast(i);
            }
            result.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
        }
        return result;
    }
}",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052787
1390052791,unknown,unknown,unknown,"def minimum_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, a = case
        if k >= n:
            results.append(0)
            continue
        total_effort = sum(a)
        reduction = []
        for i in range(n):
            reduction.append(a[i] - (n - i - 1))
        reduction.sort(reverse=True)
        max_reduction = sum(reduction[:k])
        results.append(total_effort - max_reduction)
    return results
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx])
    idx += 1
    test_cases = []
    for _ in range(T):
        n, k = int(data[idx]), int(data[idx + 1])
        idx += 2
        a = list(map(int, data[idx:idx + n]))
        idx += n
        test_cases.append((n, k, a))
    results = minimum_effort(test_cases)
    for res in results:
        print(res)
if __name__ == ""__main__"":
    main()",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052791
1390052777,unknown,unknown,unknown,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    result = []
    neg = []
    for i in range(k):
        if a[i] < 0:
            neg.append(i)
    result.append(a[neg[0]] if neg else 0)
    for i in range(k, n):
        if neg and neg[0] < i - k + 1:
            neg.pop(0)
        if a[i] < 0:
            neg.append(i)
        result.append(a[neg[0]] if neg else 0)
    print("" "".join(str(x) for x in result))",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052777
1390052780,unknown,unknown,unknown,"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int j = 0; j < n; j++) {
                a[j] = scanner.nextInt();
            }
            solve(n, k, a);
        }
        scanner.close();
    }
    public static void solve(int n, int k, int[] a) {
        long minEffort = Long.MAX_VALUE;
        for (int i = 0; i < (1 << n); i++) {
            int skippedCount = 0;
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) != 0) {
                    skippedCount++;
                }
            }
            if (skippedCount <= k) {
                long effort = 0;
                int increasedStrength = 0;
                int currentSkippedIndex = 0;
                List<Integer> skippedIndices = new ArrayList<>();
                for (int j = 0; j < n; j++) {
                    if ((i & (1 << j)) != 0) {
                        skippedIndices.add(j);
                    }
                }
                for (int j = 0; j < n; j++) {
                    if (currentSkippedIndex < skippedIndices.size() && skippedIndices.get(currentSkippedIndex) == j) {
                        increasedStrength++;
                        currentSkippedIndex++;
                    } else {
                        effort += (long) a[j] + increasedStrength;
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
        }
        System.out.println(minEffort);
    }
}",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052780
1390052781,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void earliest_faulty_readings(int test_cases) {
    for (int t = 0; t < test_cases; t++) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int *arr = (int *)malloc(n * sizeof(int));
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        for (int i = 0; i <= n - k; i++) {
            int fault = 0;
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    fault = arr[j];
                    break;
                }
            }
            printf(""%d "", fault);
        }
        printf(""\n"");
        free(arr);
    }
}
int main() {
    int test_cases;
    scanf(""%d"", &test_cases);
    earliest_faulty_readings(test_cases);
    return 0;
}",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052781
1390052772,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    min_total_effort = float('inf')
    for i in range(1 << n):  
        skipped_count = 0
        current_effort = 0
        current_firewalls = firewalls[:] 
        skipped_indices = []
        for j in range(n):
            if (i >> j) & 1:
                skipped_count += 1
                skipped_indices.append(j)
        if skipped_count <= k:
            skipped_indices.sort()
            for skip_index in skipped_indices:
                for idx in range(skip_index + 1, n):
                    current_firewalls[idx] += 1
            non_skipped_indices = [idx for idx in range(n) if idx not in skipped_indices]
            for idx in non_skipped_indices:
                current_effort += current_firewalls[idx]
            min_total_effort = min(min_total_effort, current_effort)
    return min_total_effort
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        print(min_effort(n, k, firewalls))",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052772
1390052768,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Create a dp array to store minimum effort
    # dp[i][j] represents minimum effort to breach i-th firewall using j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: no firewalls, no effort
    for j in range(k + 1):
        dp[0][j] = 0
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            # If we've skipped j firewalls so far, the current firewall's strength 
            # increases by j
            if j <= i - 1:  # Ensure we have firewalls to process
                dp[i][j] = dp[i-1][j] + (strengths[i-1] + j)
            # Option 2: Skip the current firewall (if we have skips left)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Find the minimum effort across all possible numbers of skips
    return min(dp[n])
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        result = min_effort_to_breach(n, k, strengths)
        print(result)
# Run the solution
solve()",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052768
1390052771,unknown,unknown,unknown,"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;
int minCost(const string& servers) {
    int n = servers.length();
    int totalActive = 0;
    int totalIdle = 0;
    for (char c : servers) {
        if (c == '1') totalActive++;
        else totalIdle++;
    }
    int minCost = max(totalIdle, 0); // Initial cost if we keep all servers
    // Arrays to track running counts
    vector<int> activePrefixSum(n + 1, 0);
    vector<int> idlePrefixSum(n + 1, 0);
    for (int i = 0; i < n; i++) {
        activePrefixSum[i + 1] = activePrefixSum[i] + (servers[i] == '1');
        idlePrefixSum[i + 1] = idlePrefixSum[i] + (servers[i] == '0');
    }
    // Try removing different numbers of servers from beginning and end
    for (int leftRemove = 0; leftRemove <= n; leftRemove++) {
        for (int rightRemove = 0; leftRemove + rightRemove <= n; rightRemove++) {
            // Calculate metrics for this configuration
            int activeRemoved = activePrefixSum[leftRemove] + 
                               (activePrefixSum[n] - activePrefixSum[n - rightRemove]);
            int idleRemaining = totalIdle - (idlePrefixSum[leftRemove] + 
                               (idlePrefixSum[n] - idlePrefixSum[n - rightRemove]));
            int cost = max(idleRemaining, activeRemoved);
            minCost = min(minCost, cost);
        }
    }
    return minCost;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin >> t;
    while (t--) {
        string servers;
        cin >> servers;
        cout << minCost(servers) << endl;
    }
    return 0;
}",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052771
1390052769,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []  # To store the output
    dq = deque()  # To store indices of negative numbers
    # Process the first batch of size k
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)  # Store index of negative number
    # Process the remaining batches
    for i in range(len(arr) - k + 1):
        # Add the earliest negative number from the deque
        if dq:
            result.append(arr[dq[0]])  # Front of the deque is the earliest fault
        else:
            result.append(0)  # No negative number in this batch
        # Remove elements that move out of the window
        if dq and dq[0] == i:
            dq.popleft()
        # Add the next element to the window
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the earliest faulty readings and print result
    print(*earliest_faulty_readings(arr, k))",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052769
1390052765,unknown,unknown,unknown,"def earliest_faulty_reading(test_case):
    results = []
    for case in test_cases:
        n, k, arr = case['n'], case['k'], case['arr']
        batch_result = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            fault = next((x for x in batch if x < 0), 0)
            batch_result.append(fault)
        results.append(batch_result)
    return results
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append({'n':n, 'k':k, 'arr':arr})
results = earliest_faulty_reading(test_cases)
for result in results:
    print("" "".join(map(str, result)))",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052765
1390052766,unknown,unknown,unknown,"def min_firewall_effort(n, k, firewalls):
    """"""
    Calculates the minimum effort needed to breach the network.
    Args:
        n: The number of firewalls.
        k: The maximum number of firewalls that can be skipped.
        firewalls: A list of firewall strengths.
    Returns:
        The minimum effort needed.
    """"""
    min_effort = float('inf')
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
        skipped_count = bin(i).count('1')
        if skipped_count <= k:
            current_effort = 0
            skipped = 0
            current_firewalls = firewalls[:]  # Create a copy to avoid modifying the original list
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            skipped_indices.sort()
            j = 0
            for index in skipped_indices:
                for l in range(index+1,n):
                    current_firewalls[l] +=1
            for j in range(n):
                if (i >> j) & 1:
                    continue
                else:
                    current_effort += current_firewalls[j]
            min_effort = min(min_effort, current_effort)
    return min_effort
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        result = min_firewall_effort(n, k, firewalls)
        print(result)",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052766
1390052767,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # If we can skip all firewalls, the answer is 0
    if k >= n:
        return 0
    # Calculate the cost of skipping a firewall at position i
    # This includes the original firewall strength plus the penalty it would add to future firewalls
    impact = []
    for i in range(n):
        # Impact = strength of firewall + number of non-skipped firewalls after this one
        # We're assuming all firewalls after i are NOT skipped (we'll adjust this later)
        firewall_impact = strengths[i] + (n - i - 1)
        impact.append((firewall_impact, i))
    # Sort by impact (high to low)
    impact.sort(reverse=True)
    # Select firewalls to skip (those with highest impact)
    to_skip = set()
    for i in range(min(k, n)):
        to_skip.add(impact[i][1])
    # Calculate final effort
    total_effort = 0
    skipped_count = 0
    for i in range(n):
        if i in to_skip:
            skipped_count += 1
        else:
            # Add firewall strength plus penalty for each previously skipped firewall
            total_effort += strengths[i] + skipped_count
    return total_effort
def solve_all_subsets(n, k, strengths):
    # Try all possible subsets of firewalls to skip
    # This is an exhaustive approach for when n is small
    min_effort = float('inf')
    # 2^n possible subsets of firewalls
    for mask in range(1 << n):
        # Count bits to ensure we're skipping at most k firewalls
        skipped = bin(mask).count('1')
        if skipped > k:
            continue
        effort = 0
        skip_count = 0
        for i in range(n):
            if (mask >> i) & 1:  # This firewall is skipped
                skip_count += 1
            else:
                effort += strengths[i] + skip_count
        min_effort = min(min_effort, effort)
    return min_effort
def main():
    t = int(input().strip())
    for _ in range(t):
        n, k = map(int, input().strip().split())
        strengths = list(map(int, input().strip().split()))
        # For small n, use exhaustive approach
        if n <= 20:
            result = solve_all_subsets(n, k, strengths)
        else:
            # For larger n, use greedy approach
            result = min_effort_to_breach(n, k, strengths)
        print(result)
if __name__ == ""__main__"":
    main()",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052767
1390052759,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for t in range(T):
        n, k = test_cases[t][0]
        firewalls = test_cases[t][1]
        if k >= n:  # If we can skip all firewalls, effort is 0
            results.append(0)
            continue
        min_effort = float('inf')
        for i in range(n):  # Try skipping each firewall one by one
            effort = 0
            skipped = 0
            for j in range(n):
                if j == i and skipped < k:  # Skip this firewall
                    skipped += 1
                else:
                    effort += firewalls[j] + skipped  # Increase strength for remaining ones
            min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
# Input Handling
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append(((n, k), firewalls))
# Process and Output Results
for res in min_effort_to_breach(T, test_cases):
    print(res)",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052759
1390052761,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        output = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        output.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            output.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, output)))
    return results
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
for result in earliest_faulty_readings(test_cases):
    print(result)",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052761
1390052762,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    if k >= n:
        return 0
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: when we've processed all firewalls
    for j in range(k + 1):
        dp[n][j] = 0
    # Fill DP table from right to left
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            # Option 1: Skip this firewall (if skips remain)
            if j < k:
                dp[i][j] = dp[i + 1][j + 1]
            # Option 2: Don't skip this firewall
            effort = firewalls[i] + j  # Current firewall + skips used before
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
    return dp[0][0]
# Handle automatic input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    result = min_effort(firewalls, k)
    print(result)",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052762
1390052758,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        if k == n:
            results.append(""0"")  # If all firewalls can be skipped, effort is 0
            continue
        total_effort = sum(firewalls)
        min_effort = total_effort
        # Sliding window to track sum of k skipped firewalls
        window_sum = sum(firewalls[:k])
        for i in range(n - k + 1):
            # Compute the increased security penalty dynamically
            penalty = sum(range(1, min(k, n - i) + 1))
            new_effort = total_effort - window_sum + penalty
            min_effort = min(min_effort, new_effort)
            # Move the window forward
            if i + k < n:
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
        results.append(str(min_effort))
    return ""\n"".join(results)
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(T, test_cases))",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052758
1390052749,unknown,unknown,unknown,"from collections import deque
t = int(input()) 
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    dq = deque()  
    results = [] 
    #check1
    for i in range(n):
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            while dq and dq[0] < i - k + 1:
                dq.popleft()
                #do
            results.append(arr[dq[0]] if dq else 0)
    print(' '.join(map(str, results)))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052749
1390052755,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k, readings = case
        result = []
        dq = deque()  # Stores indices of negative numbers
        # Initialize the deque with indices of negative numbers in the first window
        for i in range(k):
            if readings[i] < 0:
                dq.append(i)
        # Process sliding windows
        for i in range(n - k + 1):
            # The first negative number in the window is at dq[0], if it exists
            if dq:
                result.append(readings[dq[0]])
            else:
                result.append(0)
            # Remove elements that are out of the current window
            if dq and dq[0] == i:
                dq.popleft()
            # Add the next element (i + k) if it's negative
            if i + k < n and readings[i + k] < 0:
                dq.append(i + k)
        # Store results as a space-separated string for each test case
        results.append("" "".join(map(str, result)))
    return ""\n"".join(results)
# Example Usage
t = 2
test_cases = [
    (5, 2, [-8, 2, 3, -6, 10]),
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
]
print(earliest_faulty_readings(t, test_cases))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052755
1390052751,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    print(*earliest_faulty_readings(arr, k))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052751
1390052741,unknown,unknown,unknown,"import java.util.*;
public class FaultyComponentDetector {
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove elements that are out of the current window
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add current element index if it's a negative number
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Once we reach the window size, record the result
            if (i >= k - 1) {
                if (!deque.isEmpty()) {
                    result.add(arr[deque.peek()]); // Earliest fault in the current window
                } else {
                    result.add(0); // No fault in the current window
                }
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = scanner.nextInt(); // Size of array
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int val : result) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052741
1390052746,unknown,unknown,unknown,"def minimize_effort(n, k, firewalls):
    # Each skip at index i adds (n - i - 1) penalty to total
    # So total extra penalty = total number of skipped firewalls * (average of positions after the skip)
    total_effort = sum(firewalls)
    # Calculate cost of skipping each firewall (how much total cost increases due to penalty if we skip this one)
    penalties = []
    for i in range(n):
        # If we skip this firewall, we save a[i], but add (n - i - 1) penalty to the rest
        cost_diff = firewalls[i] + (n - i - 1)
        penalties.append((cost_diff, i))
    # Pick k firewalls with the **highest cost_diff**, i.e., best to skip (highest saving)
    penalties.sort(reverse=True)
    skipped = [0] * n
    for i in range(k):
        _, idx = penalties[i]
        skipped[idx] = 1
    # Now calculate final effort
    effort = 0
    penalty = 0
    for i in range(n):
        if skipped[i]:
            penalty += 1
        else:
            effort += firewalls[i] + penalty
    return effort
# Main driver
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(minimize_effort(n, k, firewalls))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052746
1390052748,unknown,unknown,unknown,"def min_effort(arr, k):
    n = len(arr)
    if k >= n:
        return 0
    # Calculate total effort without skipping
    total_effort = sum(arr)
    # Calculate impact of skipping each firewall
    impacts = []
    for i in range(n):
        # If we skip this firewall:
        # - We save its strength
        # - We add +1 penalty to each non-skipped firewall that comes after it
        firewall_strength = arr[i]
        penalty = n - i - 1 - k + 1  # Remaining firewalls minus skipped ones after this one
        # We need to adjust the penalty:
        # We can skip at most k firewalls, and we're skipping this one
        # So we can skip at most (k-1) more firewalls after this one
        penalty = max(0, penalty)  # If we can skip all remaining firewalls, no penalty
        net_impact = firewall_strength - penalty
        impacts.append((net_impact, i))
    # Sort impacts in descending order
    impacts.sort(reverse=True)
    # Skip k firewalls with highest impact
    skipped = 0
    skip_indices = []
    for impact, idx in impacts:
        if skipped < k:
            skip_indices.append(idx)
            skipped += 1
    # Calculate final effort
    final_effort = 0
    skipped_so_far = 0
    for i in range(n):
        if i in skip_indices:
            skipped_so_far += 1
        else:
            final_effort += arr[i] + skipped_so_far
    return final_effort
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = min_effort(arr, k)
        print(result)
if __name__ == ""__main__"":
    solve()",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052748
1390052727,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <limits.h>  // For INT_MAX
using namespace std;
int minEffort(vector<int>& firewalls, int k) {
    int totalEffort = 0, n = firewalls.size();
    // Compute total effort without skipping any firewall
    for (int effort : firewalls) {
        totalEffort += effort;
    }
    // If we can skip all firewalls, the minimum effort is 0
    if (k == n) return 0;
    int minEffort = totalEffort;  // Initialize with no skipping
    // Check the effort when skipping each firewall
    for (int i = 0; i < n; i++) {
        int currentEffort = totalEffort - firewalls[i] + k;
        minEffort = min(minEffort, currentEffort);
    }
    return minEffort;
}
int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; i++) {
            cin >> firewalls[i];
        }
        cout << minEffort(firewalls, k) << endl;
    }
    return 0;
}",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052727
1390052729,unknown,unknown,unknown,"def faulty_sensor_readings(arr, k):
    """"""
    Determines the earliest faulty reading for each consecutive batch of size k.
    Args:
        arr: A list of sensor readings.
        k: The batch size.
    Returns:
        A list containing the earliest faulty reading for each batch.
    """"""
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        fault = 0
        for num in batch:
            if num < 0:
                fault = num
                break
        result.append(fault)
    return result
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = faulty_sensor_readings(arr, k)
        print(*result)",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052729
1390052740,unknown,unknown,unknown,"from collections import deque
def find_faulty_readings(t, test_cases):
    results = []
    for i in range(t):
        n, k = test_cases[i][0], test_cases[i][1]
        arr = test_cases[i][2]
        result = []
        dq = deque()
        for j in range(k):
            if arr[j] < 0:
                dq.append(j)
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        for j in range(k, n):
            if dq and dq[0] <= j - k:
                dq.popleft()
            if arr[j] < 0:
                dq.append(j)
            if dq:
                result.append(arr[dq[0]])
            else:
                result.append(0)
        results.append(result)
    return results
t = int(input())  
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    test_cases.append((n, k, arr))
results = find_faulty_readings(t, test_cases)
for result in results:
    print("" "".join(map(str, result)))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052740
1390052719,unknown,unknown,unknown,"from collections import deque
def earliest_faults(t, test_cases):
    result = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(k):
            if arr[i]<0:
                dq.append(i)
        for i in range(n-k+1):
            if dq:
                res.append(arr[dq[0]])
            else:
                res.append(0)
            if dq and dq[0]==i:
                dq.popleft()
            if i+k<n and arr[i+k]<0:
                dq.append(i+k)
        result.append(res)
    return result
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    test_cases.append((n, k, arr))
result = earliest_faults(t, test_cases)
for res in result:
    print("" "".join(map(str, res)))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052719
1390052717,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void faultyComponent(int arr[], int k) {
        int n = arr.length;
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i <= n - k; i++) {
            boolean found = false;
            for (int j = i; j < i + k; j++) {
                if (arr[j] < 0) {
                    result.add(arr[j]);
                    found = true;
                    break;
                }
            }
            if (!found) {
                result.add(0);
            }
        }
        for (int num : result) {
            System.out.print(num + "" "");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            faultyComponent(arr, k);
        }
        scanner.close();
    }
}",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052717
1390052721,unknown,unknown,unknown,"from collections import deque
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(n - k + 1):
        result.append(arr[dq[0]] if dq else 0)
        if dq and dq[0] == i:
            dq.popleft()
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052721
1390052703,unknown,unknown,unknown,"def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        earliest_fault = next((x for x in batch if x < 0), 0)
        result.append(earliest_fault)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052703
1390052705,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(len(arr) - k + 1):
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        while dq and dq[0] < i + 1:
            dq.popleft()
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052705
1390052714,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    if k >= n:
        return 0
    min_effort = sum(firewalls)
    for i in range(n - k + 1):
        skipped = 0
        total_effort = 0
        for j in range(n):
            if skipped < k and i <= j < i + k:
                skipped += 1
            else:
                total_effort += firewalls[j] + skipped
        min_effort = min(min_effort, total_effort)
    return min_effort
t = int(input())
for i in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052714
1390052701,unknown,unknown,unknown,"def fr(arr, k):
    res = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        found = False
        for num in batch:
            if num < 0:
                res.append(num)
                found = True
                break
        if not found:
            res.append(0)
    return res
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*fr(arr, k))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052701
1390052702,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_remaining = remaining.count('0')
            active_removed = s[:i].count('1') + s[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052702
1390052699,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split()) 
    arr = list(map(int, input().split()))  
    print(*earliest_faulty_readings(arr, k))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052699
1390052698,unknown,unknown,unknown,"def min_effort_to_breach_firewalls(test_cases):
    results = []
    for n, k, strengths in test_cases:
        # Sort the strengths in ascending order
        strengths.sort()
        # Calculate the total effort after skipping the k weakest firewalls
        total_effort = 0
        # Iterate over the remaining firewalls
        for i in range(n - k):
            total_effort += strengths[i] + k  # Each remaining firewall's strength increases by k
        results.append(total_effort)
    return results
# Input reading
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    test_cases.append((n, k, strengths))
# Get results
results = min_effort_to_breach_firewalls(test_cases)
# Output results
for result in results:
    print(result)",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052698
1390052694,unknown,unknown,unknown,"def min_effort(arr, k):
    n = len(arr)
    if k >= n:
        return 0
    total = sum(arr)
    impact = []
    for i, strength in enumerate(arr):
        remaining_firewalls = n - i - 1
        net_impact = strength - remaining_firewalls
        impact.append((net_impact, i))
    impact.sort(reverse=True)
    for i in range(k):
        if i < len(impact):
            net_impact, idx = impact[i]
            if net_impact > 0:
                total -= net_impact
    return total
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = min_effort(arr, k)
        print(result)
if __name__ == ""__main__"":
    solve()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052694
1390052695,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        if k == n:
            results.append(""0"")  # If we can skip all firewalls, effort is 0
            continue
        total_effort = sum(firewalls)
        min_effort = total_effort
        # Sliding window to track k skipped firewalls' effort
        window_sum = sum(firewalls[:k])
        for i in range(n - k + 1):
            increased_security = k  # Each skipped firewall increases later firewalls' strength
            new_effort = total_effort - window_sum + increased_security
            min_effort = min(min_effort, new_effort)
            # Move the window forward
            if i + k < n:
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
        results.append(str(min_effort))
    return ""\n"".join(results)
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(T, test_cases))",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052695
1390052696,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of faulty readings (negative values)
    for i in range(n):
        # Remove indices that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element's index if it's a negative value (faulty)
        if arr[i] < 0:
            dq.append(i)
        # If the window is large enough (i >= k - 1), we check the result
        if i >= k - 1:
            if dq:
                result.append(arr[dq[0]])  # The earliest faulty reading in the window
            else:
                result.append(0)  # No faulty reading in this window
    return result
def process_test_cases():
    t = int(input())  # number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # size of array and batch size
        arr = list(map(int, input().split()))  # the array of sensor readings
        result = earliest_faulty_reading(arr, k)
        print(' '.join(map(str, result)))
# Call the function to process test cases
process_test_cases()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052696
1390052692,unknown,unknown,unknown,"def solve_firewall_problem():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        strengths = list(map(int, input().split()))
        min_effort = float('inf')
        for mask in range(1 << n):
            if bin(mask).count('1') <= k:
                effort = 0
                skipped = 0
                for i in range(n):
                    if (mask >> i) & 1:
                        skipped += 1
                    else:
                        effort += strengths[i] + skipped
                min_effort = min(min_effort, effort)
        print(min_effort)
if __name__ == ""__main__"":
    solve_firewall_problem()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052692
1390052693,unknown,unknown,unknown,"def find_faulty_readings(arr, k):
    ans = []
    for i in range(len(arr)-k+1):
        batch = arr[i: i+k]
        fault = 0
        for reading in batch:
            if reading < 0:
                fault=reading
                break
        ans.append(fault)
    return ans
def solve():
    m = int(input())
    for _ in range(m):
        n,k = map(int,input().split())
        arr = list(map(int,input().split()))
        ans = find_faulty_readings(arr,k)
        print(*ans)
solve()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052693
1390052684,unknown,unknown,unknown,"from collections import deque
def find_earliest_faults(arr, n, k):
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = find_earliest_faults(arr, n, k)
        results.append("" "".join(map(str, result)))
    print(""\n"".join(results))
if __name__ == ""__main__"":
    main()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052684
1390052685,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Create prefix sums for 1's to optimize counting
    prefix_ones = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
    # Create prefix sums for 0's
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possible substrings (start, end)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Active servers removed = ones before start + ones after end
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
            # Idle servers remaining = zeros between start and end
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052685
1390052687,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total numbers of ones and zeros
    total_ones = server_string.count('1')
    total_zeros = n - total_ones
    # Precompute prefix/suffix counts
    prefix_ones = [0] * (n + 1)
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_string[i] == '1' else 0)
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_string[i] == '0' else 0)
    min_cost = float('inf')
    # For each possible prefix length
    for left in range(n + 1):
        # Ones removed from the left
        left_ones_removed = prefix_ones[left]
        # Remaining zeros after removing left prefix
        remaining_zeros_after_left = total_zeros - prefix_zeros[left]
        # Optimize right side removal using the fact that we want to minimize
        # both remaining zeros and removed ones
        right_ones_to_remove = 0
        right_zeros_removed = 0
        # Binary search approach to find optimal right side removal
        lo, hi = 0, n - left
        while lo < hi:
            mid = (lo + hi) // 2
            # If removing up to mid characters from right
            ones_right = prefix_ones[n] - prefix_ones[n - mid]
            zeros_right = prefix_zeros[n] - prefix_zeros[n - mid]
            # Remaining zeros
            remaining_zeros = remaining_zeros_after_left - zeros_right
            # Total ones removed
            removed_ones = left_ones_removed + ones_right
            # Current cost
            cost = max(remaining_zeros, removed_ones)
            # Update minimum
            if cost < min_cost:
                min_cost = cost
                right_ones_to_remove = ones_right
                right_zeros_removed = zeros_right
            # Decide which direction to continue search
            if remaining_zeros > removed_ones:
                # Need to remove more zeros
                lo = mid + 1
            else:
                # Need to remove fewer ones
                hi = mid
    # Handle the special case when binary search didn't find optimal solution
    # Check all possible right removals for the best left prefix
    for right in range(n - left + 1):
        if left + right == n:  # Skip if removing everything
            continue
        ones_right = prefix_ones[n] - prefix_ones[n - right]
        zeros_right = prefix_zeros[n] - prefix_zeros[n - right]
        remaining_zeros = remaining_zeros_after_left - zeros_right
        removed_ones = left_ones_removed + ones_right
        cost = max(remaining_zeros, removed_ones)
        min_cost = min(min_cost, cost)
    return min_cost
def linear_solution(server_string):
    """"""
    O(n) solution that's simpler and more reliable
    """"""
    n = len(server_string)
    total_ones = server_string.count('1')
    # Precompute prefix sums
    prefix_ones = [0] * (n + 1)
    prefix_zeros = [0] * (n + 1)
    for i in range(n):
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_string[i] == '1' else 0)
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_string[i] == '0' else 0)
    min_cost = float('inf')
    # Try all possibilities of where to cut from left (i) and right (j)
    for i in range(n + 1):  # left cut position
        left_ones_removed = prefix_ones[i]
        for j in range(n + 1):  # right cut position
            # Skip if we're removing everything
            if i + j >= n:
                continue
            # Ones removed from right
            right_ones_removed = total_ones - prefix_ones[n-j]
            # Total ones removed
            ones_removed = left_ones_removed + right_ones_removed
            # Zeros remaining in the middle section
            zeros_remaining = prefix_zeros[n-j] - prefix_zeros[i]
            # Cost is max of ones removed and zeros remaining
            cost = max(ones_removed, zeros_remaining)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        server_string = input().strip()
        # Use linear solution for reliable results
        result = linear_solution(server_string)
        print(result)
# Execute the solution
solve()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052687
1390052676,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextLong();
            }
            long[][] dp = new long[n + 1][k + 1];
            for (int i = 0; i <= n; i++) {
                for (int j = 0; j <= k; j++) {
                    dp[i][j] = Long.MAX_VALUE / 2; // Avoid overflow in min operations
                }
            }
            dp[0][0] = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j <= k; j++) {
                    if (dp[i][j] >= Long.MAX_VALUE / 2) continue;
                    // Don't skip current firewall
                    if (dp[i + 1][j] > dp[i][j] + a[i] + j) {
                        dp[i + 1][j] = dp[i][j] + a[i] + j;
                    }
                    // Skip current firewall
                    if (j + 1 <= k && dp[i + 1][j + 1] > dp[i][j]) {
                        dp[i + 1][j + 1] = dp[i][j];
                    }
                }
            }
            long minEffort = Long.MAX_VALUE;
            for (int j = 0; j <= k; j++) {
                if (dp[n][j] < minEffort) {
                    minEffort = dp[n][j];
                }
            }
            System.out.println(minEffort == Long.MAX_VALUE / 2 ? 0 : minEffort);
        }
        sc.close();
    }
}",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052676
1390052670,unknown,unknown,unknown,"def min_effort(n, k, strengths):
    total_effort = sum(strengths)  
    for i in range(n - k + 1):  
        skipped_effort = sum(strengths[i:i + k])  
        increased_effort = sum(strengths[:i]) + sum(strengths[i + k:]) + (n - (i + k)) * k
        total_effort = min(total_effort, increased_effort)
    return total_effort
T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    print(min_effort(n, k, strengths))",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052670
1390052672,unknown,unknown,unknown,"def solve():
    s = input()
    n = len(s)
    min_cost = float('inf')
    for i in range(n + 1):
        for j in range(n - i + 1):
            remaining = s[i:n-j]
            idle_remaining = remaining.count('0')
            active_removed = s[:i].count('1') + s[n-j:].count('1')
            cost = max(idle_remaining, active_removed)
            min_cost = min(min_cost, cost)
    print(min_cost)
t = int(input())
for _ in range(t):
    solve()",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052672
1390052673,unknown,unknown,unknown,"#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
long long minEffort(vector<int>& firewalls, int n, int k) {
    // If we can skip all firewalls, return 0
    if (k >= n) return 0;
    // Calculate the total cost of skipping each firewall
    vector<long long> skipCost(n, 0);
    for (int i = 0; i < n; i++) {
        // If we skip firewall i, all subsequent firewalls (n-i-1 of them) increase by 1
        skipCost[i] = firewalls[i] - (n - i - 1);
    }
    // Sort firewalls by their skip cost
    vector<pair<long long, int>> indexedCosts(n);
    for (int i = 0; i < n; i++) {
        indexedCosts[i] = {skipCost[i], i};
    }
    sort(indexedCosts.begin(), indexedCosts.end());
    // Mark which firewalls to skip (those with the highest skip cost)
    vector<bool> skip(n, false);
    for (int i = n - 1; i >= max(0, n - k); i--) {
        skip[indexedCosts[i].second] = true;
    }
    // Calculate the total effort
    long long totalEffort = 0;
    int penaltyCount = 0;
    for (int i = 0; i < n; i++) {
        if (skip[i]) {
            // Skip this firewall
            penaltyCount++;
        } else {
            // Don't skip - add the current strength plus penalty
            totalEffort += firewalls[i] + penaltyCount;
        }
    }
    return totalEffort;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> firewalls(n);
        for (int i = 0; i < n; i++) {
            cin >> firewalls[i];
        }
        cout << minEffort(firewalls, n, k) << endl;
    }
    return 0;
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052673
1390052663,unknown,unknown,unknown,"import java.util.*;
public class FaultySensorReadings {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Size of array
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaultyReadings(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
    public static List<Integer> findEarliestFaultyReadings(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            // Remove elements that are out of the current window
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            // Add current element index if it's faulty (negative)
            if (arr[i] < 0) {
                deque.offerLast(i);
            }
            // Collect result once the first batch is formed
            if (i >= k - 1) {
                if (!deque.isEmpty()) {
                    result.add(arr[deque.peekFirst()]);
                } else {
                    result.add(0);
                }
            }
        }
        return result;
    }
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052663
1390052665,unknown,unknown,unknown,"def find_earliest_faulty(arr, k):
    result = []
    n = len(arr)
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        faulty = 0
        for num in batch:
            if num < 0:
                faulty = num
                break
        result.append(faulty)
    return result
def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    for _ in range(t):
        n, k = int(data[idx]), int(data[idx + 1])
        idx += 2
        arr = list(map(int, data[idx:idx + n]))
        idx += n
        result = find_earliest_faulty(arr, k)
        print(' '.join(map(str, result)))
if __name__ == ""__main__"":
    main()",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052665
1390052669,unknown,unknown,unknown,"def min_firewall_effort(n, k, firewalls):
    """"""
    Calculates the minimum effort needed to breach the network.
    Args:
        n: The number of firewalls.
        k: The maximum number of firewalls that can be skipped.
        firewalls: A list of firewall strengths.
    Returns:
        The minimum effort needed.
    """"""
    min_effort = float('inf')
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
        skipped_count = bin(i).count('1')
        if skipped_count <= k:
            current_effort = 0
            skipped = 0
            current_firewalls = firewalls[:]  # Create a copy to avoid modifying the original list
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            skipped_indices.sort()
            j = 0
            for index in skipped_indices:
                for l in range(index+1,n):
                    current_firewalls[l] +=1
            for j in range(n):
                if (i >> j) & 1:
                    continue
                else:
                    current_effort += current_firewalls[j]
            min_effort = min(min_effort, current_effort)
    return min_effort
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        result = min_firewall_effort(n, k, firewalls)
        print(result)",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052669
1390052655,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # If we can skip all firewalls, return 0
    if k >= n:
        return 0
    # Create an array to track the minimum effort to breach the network
    # dp[i][j] = min effort to process first i firewalls with j skips
    dp = [[float('inf')] * (min(k, n) + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: no firewalls, no skips, no effort
    for i in range(1, n + 1):
        for j in range(min(i, k) + 1):  # We can't skip more firewalls than we've seen
            # Option 1: Don't skip current firewall
            if j <= i - 1:
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
            # Option 2: Skip current firewall (if we have skips left)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Find minimum effort across all possible skip counts
    return min(dp[n])
def main():
    try:
        t = int(input().strip())
        for _ in range(t):
            line = input().strip().split()
            n, k = int(line[0]), int(line[1])
            strengths = list(map(int, input().strip().split()))
            # Ensure we have the right number of strengths
            if len(strengths) != n:
                # Handle case where input is malformed
                continue
            result = min_effort_to_breach(n, k, strengths)
            print(result)
    except Exception as e:
        # Fallback for any unexpected errors
        print(0)  # Default answer if something goes wrong
if __name__ == ""__main__"":
    main()",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052655
1390052660,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt(), k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
            Deque<Integer> dq = new LinkedList<>();
            for (int i = 0; i < n; i++) {
                if (arr[i] < 0) dq.addLast(i);
                if (i >= k - 1) {
                    while (!dq.isEmpty() && dq.peekFirst() < i - k + 1) dq.pollFirst();
                    System.out.print((dq.isEmpty() ? 0 : arr[dq.peekFirst()]) + "" "");
                }
            }
            System.out.println();
        }
        sc.close();
    }
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052660
1390052650,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); 
        while (t-- > 0) {
            int n = sc.nextInt(); 
            int k = sc.nextInt();
            int[] a = new int[n]; 
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            findFaulty(a, n, k); 
        }
    }
    public static void findFaulty(int[] a, int n, int k) {
        int fn = 0, i = 0, j = 0; 
        while (j < n) {
            if (j - i + 1 < k) j++; 
            else {
                while (fn < i || (fn <= j && a[fn] >= 0)) fn++;
                if (fn >= i && fn <= j) System.out.print(a[fn] + "" "");
                else System.out.print(""0 "");
                i++; j++; 
            }
        }
        System.out.println();
    }
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052650
1390052645,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();  // Number of test cases
        sc.nextLine(); // Consume newline
        while (T-- > 0) {
            String servers = sc.nextLine();
            System.out.println(minimumPruningCost(servers));
        }
        sc.close();
    }
    public static int minimumPruningCost(String servers) {
    int n = servers.length();
    int firstOne = servers.indexOf('1');
    int lastOne = servers.lastIndexOf('1');
    // If no active servers exist, the cost is 0
    if (firstOne == -1) return 0;
    // Count groups of zeros
    int zeroGroups = 0;
    boolean inZeroGroup = false;
    for (int i = firstOne; i <= lastOne; i++) {
        if (servers.charAt(i) == '0') {
            if (!inZeroGroup) {
                // Start of a new group of zeros
                zeroGroups++;
                inZeroGroup = true;
            }
        } else {
            // We found a '1', so we're no longer in a zero group
            inZeroGroup = false;
        }
    }
    return zeroGroups;
}
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052645
1390052632,unknown,unknown,unknown,"#include <iostream>
#include <vector>
using namespace std;
void findnegative(vector<int>& arr, int n, int k) {
    for (int i = 0; i <= n - k; i++) {
        int tempans = 0;
    for (int j = i; j < i + k; j++) {
           if (arr[j] < 0) {
            tempans = arr[j];
                break;
            }
        }
  cout << tempans<<"" "";
    }
    cout << endl;
}
int main() {
    int t;
cin >> t;
    while (t--) {
        int n, k;
         cin >> n >> k;
    vector<int> arr(n);
        for (int i = 0; i < n; i++) {
           cin >> arr[i];
        }
         findnegative(arr, n, k);
    }
    return 0;
}",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052632
1390052635,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process the remaining windows
    for i in range(len(arr) - k + 1):
        # If deque is not empty, the first element is the earliest negative
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of the current window
        while dq and dq[0] < i + 1:
            dq.popleft()
        # Add the next element (end of the new window)
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052635
1390052637,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        fault_found = False
        for reading in batch:
            if reading < 0:
                result.append(reading)
                fault_found = True
                break
        if not fault_found:
            result.append(0)
    return result
def process_testcases(testcases):
    results = []
    for arr, k in testcases:
        results.append(find_earliest_faults(arr, k))
    return results
if __name__ == ""__main__"":
    num_testcases = int(input())
    testcases = []
    for _ in range(num_testcases):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        testcases.append((arr, k))
    results = process_testcases(testcases)
    for result in results:
        print(*result)",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052637
1390052628,unknown,unknown,unknown,"from collections import deque
def find_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        faulty_indices = deque()
        result = []
        for i in range(n):
            if faulty_indices and faulty_indices[0] < i - k + 1:
                faulty_indices.popleft()
            if arr[i] < 0:
                faulty_indices.append(i)
            if i >= k - 1:
                if faulty_indices:
                    result.append(arr[faulty_indices[0]])
                else:
                    result.append(0)
        results.append(result)
    return results
t = int(input())  
test_cases = []
for _ in range(t):
    n, k = map(int, input().split()) 
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
results = find_faulty_readings(test_cases)
for result in results:
    print("" "".join(map(str, result)))",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052628
1390052630,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t-->0){
            int n = sc.nextInt();
            int k = sc.nextInt();
            int []arr = new int [n];
            ArrayList<Integer> list = new ArrayList<>();
            for(int i=0;i<n;i++){
                arr[i] = sc.nextInt();
            }
            for (int i=0;i<=n-k;i++){
                int value = 0;
                for(int j=i;j<k+i;j++){
                    if(arr[j]<0){
                        value = arr[j];
                        break;
                    }
                }
                 list.add(value);
            }
            for (int num : list) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
    }
}",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052630
1390052631,unknown,unknown,unknown,"def earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i+k]
        fault_found = False
        for num in batch:
            if num < 0:
                result.append(num)
                fault_found = True
                break
        if not fault_found:
            result.append(0)
    return result
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    result = earliest_fault(arr, k)
    print(*result)  ",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052631
1390052622,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
       Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); 
        while (t-- > 0) {
            int n = sc.nextInt();  
            int k = sc.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            for (int i = 0; i <= n - k; i++) {
                int firstfa = 0; 
                for (int j = i; j < i + k; j++) {
                    if (arr[j] < 0) {
                        firstfa = arr[j];  
                        break; 
                    }
                }
            System.out.print(firstfa + "" "");  
            }
            System.out.println(); 
            }
        sc.close();
    }
}",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052622
1390052626,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, len(arr)):
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input().strip())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052626
1390052621,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k, readings = case
        result = []
        dq = deque()  # Stores indices of negative numbers
        # Process the first window
        for i in range(k):
            if readings[i] < 0:
                dq.append(i)
        # Process the sliding windows
        for i in range(n - k + 1):
            # Append the first negative in the deque, or 0 if empty
            result.append(readings[dq[0]] if dq else 0)
            # Remove elements that are out of this window
            if dq and dq[0] == i:
                dq.popleft()
            # Add next element (i + k) to the deque if it's negative
            if i + k < n and readings[i + k] < 0:
                dq.append(i + k)
        results.append("" "".join(map(str, result)))  # Convert list to space-separated string
    return ""\n"".join(results)
# Example Usage
t = 2
test_cases = [
    (5, 2, [-8, 2, 3, -6, 10]),
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
]
print(earliest_faulty_readings(t, test_cases))",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052621
1390052615,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        result.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements no longer in window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add new element if it's faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return results
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute and print output
for res in earliest_faulty_readings(test_cases):
    print(res)",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052615
1390052609,unknown,unknown,unknown,"def min_effort_to_breach(n, k, strengths):
    # Initialize array to store minimum effort for each possible combination
    # dp[i][j] = min effort to process first i firewalls using j skips
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
    dp[0][0] = 0  # Base case: no firewalls, no skips, no effort
    for i in range(1, n+1):
        firewall_idx = i-1  # Convert to 0-indexed for strengths array
        for j in range(k+1):
            # Option 1: Don't skip current firewall
            if j <= i-1:  # Can only have used j skips on previous i-1 firewalls
                # Current strength + penalty of j for j previously skipped firewalls
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[firewall_idx] + j)
            # Option 2: Skip current firewall (if we have skips left)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Return minimum effort after processing all firewalls with any number of skips
    return min(dp[n])
def main():
    t = int(input().strip())
    for _ in range(t):
        n, k = map(int, input().strip().split())
        strengths = list(map(int, input().strip().split()))
        result = min_effort_to_breach(n, k, strengths)
        print(result)
if __name__ == ""__main__"":
    main()",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052609
1390052611,unknown,unknown,unknown,"def min_effort_to_breach(count, max_skip, values):
    if max_skip >= count:
        return 0
    effort = [[float('inf')] * (max_skip + 1) for _ in range(count + 1)]
    effort[0][0] = 0
    for i in range(1, count + 1):
        for j in range(max_skip + 1):
            if j > 0:
                current_value = values[i-1] + j
            else:
                current_value = values[i-1]
            if effort[i-1][j] != float('inf'):
                effort[i][j] = min(effort[i][j], effort[i-1][j] + current_value)
            if j < max_skip:
                effort[i][j+1] = min(effort[i][j+1], effort[i-1][j])
    return min(effort[count])
def solve():
    test_cases = int(input().strip())
    results = []
    for _ in range(test_cases):
        count, max_skip = map(int, input().strip().split())
        values = list(map(int, input().strip().split()))
        results.append(min_effort_to_breach(count, max_skip, values))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    solve()",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052611
1390052613,unknown,unknown,unknown,,173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052613
1390052601,unknown,unknown,unknown,,173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052601
1390052605,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        if k == n:
            results.append(""0"")  # If all firewalls can be skipped, effort is 0
            continue
        total_effort = sum(firewalls)
        min_effort = total_effort
        # Compute the initial window sum (sum of first k firewalls)
        window_sum = sum(firewalls[:k])
        # Iterate through possible skip windows
        for i in range(n - k + 1):
            skipped_firewalls = k
            increased_security = sum(range(1, skipped_firewalls + 1))  # Penalty for skipping
            new_effort = total_effort - window_sum + increased_security
            min_effort = min(min_effort, new_effort)
            # Move the sliding window
            if i + k < n:
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
        results.append(str(min_effort))
    return ""\n"".join(results)
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(T, test_cases))",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052605
1390052607,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string)
    # Count total active and idle servers
    total_active = server_string.count('1')
    total_idle = server_string.count('0')
    min_cost = float('inf')
    # Try all possible combinations of removing servers from beginning and end
    for left in range(n + 1):  # Servers to remove from left (including 0)
        for right in range(n + 1 - left):  # Servers to remove from right (including 0)
            # Skip if we're removing all servers
            if left + right == n:
                continue
            # Calculate remaining substring
            remaining = server_string[left:n-right]
            # Count remaining idle servers
            remaining_idle = remaining.count('0')
            # Count active servers removed
            active_removed = total_active - remaining.count('1')
            # Calculate cost
            cost = max(remaining_idle, active_removed)
            # Update minimum cost
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        server_string = input().strip()
        result = min_decommission_cost(server_string)
        print(result)
# Execute the solution
solve()",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052607
1390052590,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052590
1390052592,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        res.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            res.append(arr[dq[0]] if dq else 0)
        results.append(res)
    return results
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
output = earliest_faulty_readings(test_cases)
for res in output:
    print(*res)",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052592
1390052596,unknown,unknown,unknown,"def minimize_effort(test_cases):
    results = []
    for n, k, strengths in test_cases:
        # Sort the strengths array to prioritize skipping the most costly firewalls
        strengths.sort()
        # Skip up to k strongest firewalls, which are now the last k elements in the sorted list
        total_effort = sum(strengths[:-k]) if k < n else 0
        results.append(total_effort)
    return results
# Input reading
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    strengths = list(map(int, input().split()))
    test_cases.append((n, k, strengths))
# Get results
results = minimize_effort(test_cases)
# Output results
for res in results:
    print(res)",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052596
1390052588,unknown,unknown,unknown,,173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052588
1390052579,unknown,unknown,unknown,"def minimize_effort(test_cases):
    results = []
    for case in test_cases:
        n, k, firewalls = case
        min_effort = float('inf')
        for i in range(1 << n):
            skipped_count = 0
            current_effort = 0
            skipped = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_count += 1
                    skipped.append(j)
            if skipped_count <= k:
                effort = 0
                increase = 0
                for j in range(n):
                    if j in skipped:
                        increase += 1
                    else:
                        effort += firewalls[j]
                min_effort = min(min_effort, effort + increase * k)  # Correct effort calculation
        results.append(min_effort)
    return results
# Input reading and processing
def main():
    t = int(input())  # Number of test cases
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().split())  # Number of firewalls and max skips
        firewalls = list(map(int, input().split()))  # Strength of each firewall
        test_cases.append((n, k, firewalls))
    results = minimize_effort(test_cases)
    for result in results:
        print(result)
# Run the program
if __name__ == ""__main__"":
    main()",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052579
1390052580,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = new ArrayList<>();
            for (int i = 0; i <= n - k; i++) {
                boolean foundFault = false;
                for (int j = i; j < i + k; j++) {
                    if (arr[j] < 0) {
                        result.add(arr[j]);
                        foundFault = true;
                        break;
                    }
                }
                if (!foundFault) {
                    result.add(0);
                }
            }
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
}",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052580
1390052586,unknown,unknown,unknown,"def earliest_faulty_reading(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        result = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            faulty = next((x for x in batch if x < 0), 0)
            result.append(faulty)
        results.append(result)
    return results
# Example usage
test_cases = [
    (5, 2, [-8, 2, 3, -6, 10]),
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
]
output = earliest_faulty_reading(test_cases)
for res in output:
    print("" "".join(map(str, res)))",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052586
1390052574,unknown,unknown,unknown,"def earliest_fault_in_batches(arr, k):
    results = []
    n = len(arr)
    for i in range(n - k + 1):
        batch = arr[i:i+k]
        fault_found = False
        for val in batch:
            if val < 0:
                results.append(val)
                fault_found = True
                break
        if not fault_found:
            results.append(0)
    return results
def solve_test_cases():
    t = int(input())  
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        batch_results = earliest_fault_in_batches(arr, k)
        results.append(batch_results)
    for batch_result in results:
        print(*batch_result)
if __name__ == ""__main__"":
    solve_test_cases()",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052574
1390052577,unknown,unknown,unknown,"def minimum_effort(n, k, arr):
    total_sum = sum(arr)
    if k == n:
        return 0
    current_window_sum = sum(arr[:k])
    min_effort = total_sum - current_window_sum + (n - k)
    for i in range(1, n - k + 1):
        current_window_sum += arr[i + k - 1] - arr[i - 1]
        effort = total_sum - current_window_sum + (n - (i + k))
        min_effort = min(min_effort, effort)
    return min_effort
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = minimum_effort(n, k, arr)
    print(result)",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052577
1390052573,unknown,unknown,unknown,"def min_decommission_cost(server_string):
    n = len(server_string) 
    total_active = server_string.count('1')
    total_idle = server_string.count('0')
    min_cost = float('inf')
    for left in range(n + 1):  
        for right in range(n + 1 - left):  
            if left + right == n:
                continue
            remaining = server_string[left:n-right]
            remaining_idle = remaining.count('0')
            active_removed = total_active - remaining.count('1')
            cost = max(remaining_idle, active_removed)
            min_cost = min(min_cost, cost)
    return min_cost
def solve():
    t = int(input())
    for _ in range(t):
        server_string = input().strip()
        result = min_decommission_cost(server_string)
        print(result)
solve()",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052573
1390052566,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)  # Case where no firewall is skipped
    if k == n:
        return 0  # If we can skip all firewalls, effort is zero
    min_effort = total_effort  # Initialize min_effort with total sum
    for i in range(n):
        skipped_effort = total_effort - firewalls[i] + k  # Skip firewall i
        min_effort = min(min_effort, skipped_effort)
    return min_effort
def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        print(min_effort(n, k, firewalls))
if __name__ == ""__main__"":
    main()",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052566
1390052565,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(n - k + 1):
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        while dq and dq[0] < i + 1:
            dq.popleft()
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    earliest_faulty_readings(arr, k)",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052565
1390052571,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of this window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052571
1390052561,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- > 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            long[][] dp = new long[n + 1][k + 1];
            for (int i = 0; i <= n; i++) {
                for (int j = 0; j <= k; j++) {
                    dp[i][j] = Long.MAX_VALUE;
                }
            }
            dp[0][0] = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j <= k; j++) {
                    if (dp[i][j] == Long.MAX_VALUE) continue;
                    dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + a[i] + j);
                    if (j + 1 <= k) {
                        dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j]);
                    }
                }
            }
            long minEffort = Long.MAX_VALUE;
            for (int j = 0; j <= k; j++) {
                minEffort = Math.min(minEffort, dp[n][j]);
            }
            System.out.println(minEffort);
        }
        sc.close();
    }
}",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052561
1390052547,unknown,unknown,unknown,"def solve_breach_problem(n, k, firewall_strengths):
    # Create a 2D dp array where:
    # dp[i][j] = minimum effort needed to breach first i firewalls 
    # after skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: No firewall, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        current_strength = firewall_strengths[i - 1]
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall (if j firewalls already skipped)
            if j <= i - 1:  # We can only skip j firewalls out of i-1 previous ones
                # Current firewall strength increases by j (number of previously skipped firewalls)
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
            # Option 2: Skip the current firewall (if we haven't used all our skips)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Find minimum effort considering all possible numbers of skipped firewalls
    return min(dp[n])
def main():
    test_cases = int(input())
    for _ in range(test_cases):
        n, k = map(int, input().split())
        firewall_strengths = list(map(int, input().split()))
        min_effort = solve_breach_problem(n, k, firewall_strengths)
        print(min_effort)
if __name__ == ""__main__"":
    main()",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052547
1390052552,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    for (int i = k; i < n; i++) {
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052552
1390052560,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of faulty readings (negative values)
    for i in range(n):
        # Remove indices that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element's index if it's a negative value (faulty)
        if arr[i] < 0:
            dq.append(i)
        # If the window is large enough (i >= k - 1), we check the result
        if i >= k - 1:
            if dq:
                result.append(arr[dq[0]])  # The earliest faulty reading in the window
            else:
                result.append(0)  # No faulty reading in this window
    return result
def process_test_cases():
    t = int(input())  # number of test cases
    for _ in range(t):
        n, k = map(int, input().split())  # size of array and batch size
        arr = list(map(int, input().split()))  # the array of sensor readings
        result = earliest_faulty_reading(arr, k)
        print(' '.join(map(str, result)))
# Call the function to process test cases
process_test_cases()",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052560
1390052538,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
vector<int> earliestFaults(vector<int>& arr, int k) {
    vector<int> result;
    for (int i = 0; i <= arr.size() - k; i++) {
        bool found = false;
        for (int j = i; j < i + k; j++) {
            if (arr[j] < 0) {
                result.push_back(arr[j]);
                found = true;
                break;
            }
        }
        if (!found) result.push_back(0);
    }
    return result;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliestFaults(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052538
1390052539,unknown,unknown,unknown,"def minimum_effort_to_breach_firewalls(test_cases):
    results = []
    for case in test_cases:
        n, k, firewalls = case
        min_effort = float('inf')  # Initialize with a large value
        for i in range(1 << n):  # Iterate through all possible subsets of firewalls to skip
            skipped_count = 0
            current_effort = 0
            temp_firewalls = firewalls[:]  # Create a copy to modify
            # Determine which firewalls are skipped based on the bits in i
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_count += 1
                    skipped_indices.append(j)
            if skipped_count <= k:
                effort = 0
                skipped_indices.sort()
                #Calculate effort with increased strength for subsequent firewalls
                for j in range(n):
                    if j in skipped_indices:
                        continue
                    else:
                        increase = 0
                        skipped_before = 0
                        for skip_idx in skipped_indices:
                            if skip_idx < j:
                                skipped_before += 1
                        effort += firewalls[j] + skipped_before
                min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
# Example Usage (based on the sample input):
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
results = minimum_effort_to_breach_firewalls(test_cases)
for result in results:
    print(result)",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052539
1390052545,unknown,unknown,unknown,"def earliest_faulty_reading(arr, k):
    n = len(arr)
    result = []
    first_faulty_index = -1  # Track index of first negative in the current window
    for i in range(n - k + 1):
        # If the previous first_faulty_index is out of the window, find a new one
        if first_faulty_index < i:
            first_faulty_index = -1
            for j in range(i, i + k):
                if arr[j] < 0:
                    first_faulty_index = j
                    break
        # Append the first negative number in the window, or 0 if none found
        if first_faulty_index != -1:
            result.append(arr[first_faulty_index])
        else:
            result.append(0)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    # Compute and print results
    print(*earliest_faulty_reading(arr, k))  # Print space-separated values",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052545
1390052525,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process all sliding windows
    for i in range(n - k + 1):
        # Append first negative in current window
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of window
        while dq and dq[0] < i + 1:
            dq.popleft()
        # Add next element if negative
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    earliest_faulty_readings(arr, k)",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052525
1390052533,unknown,unknown,unknown,"from collections import deque
def earliest_faults_in_batches(test_cases):
    results = []
    for n, k, arr in test_cases:
        output, dq = [], deque()
        for i in range(n):
            if arr[i] < 0: dq.append(i)
            if i >= k and dq and dq[0] <= i - k: dq.popleft()
            if i >= k - 1: output.append(arr[dq[0]] if dq else 0)
        results.append(output)
    return results
t = int(input())
test_cases = [(lambda n, k, arr: (n, k, arr))(*map(int, input().split()), list(map(int, input().split()))) for _ in range(t)]
for output in earliest_faults_in_batches(test_cases):
    print(*output)",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052533
1390052531,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        output = []
        dq = deque()
        # Process the first window
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the result for the first batch
        output.append(arr[dq[0]] if dq else 0)
        # Process the remaining windows
        for i in range(k, n):
            # Remove elements that are out of the current window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add the current element if it is negative
            if arr[i] < 0:
                dq.append(i)
            # Store the result for the current batch
            output.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, output)))
    return ""\n"".join(results)
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Compute and print results
print(earliest_faulty_readings(test_cases))",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052531
1390052524,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052524
1390052517,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052517
1390052519,unknown,unknown,unknown,"cases = int(input())
for t in range(cases):
    n,k = [int(i) for i in input().split()]
    array = [int(i) for i in input().split()]
    prefix = [0]*len(array)
    for i in range(len(array)-k+1):
        to_check = array[i:i+k]
        for j in to_check:
            neg = 0
            if j < 0:
                neg = j
                break
        print(neg, end = "" "")
    print("""")
        ",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052519
1390052522,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine().trim()); // Number of test cases
        StringBuilder result = new StringBuilder();
        while (t-- > 0) {
            String[] nk = br.readLine().trim().split("" "");
            int n = Integer.parseInt(nk[0]); // Size of the array
            int k = Integer.parseInt(nk[1]); // Batch size
            String[] arrStr = br.readLine().trim().split("" "");
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = Integer.parseInt(arrStr[i]);
            }
            result.append(findEarliestFaults(arr, n, k)).append(""\n"");
        }
        System.out.print(result);
    }
    private static String findEarliestFaults(int[] arr, int n, int k) {
        StringBuilder sb = new StringBuilder();
        Deque<Integer> deque = new LinkedList<>(); // To store indices of negative numbers
        // Process first window of size k
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                deque.add(i);
            }
        }
        // Process remaining windows
        for (int i = k; i <= n; i++) {
            // Add the earliest fault in the current batch
            sb.append(deque.isEmpty() ? ""0"" : arr[deque.peek()]).append("" "");
            // Remove elements that are out of the current window
            if (!deque.isEmpty() && deque.peek() == i - k) {
                deque.poll();
            }
            // Add the next element if it's negative
            if (i < n && arr[i] < 0) {
                deque.add(i);
            }
        }
        return sb.toString().trim();
    }
}",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052522
1390052510,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    for i in range(len(arr) - k + 1):
        fault_found = False
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        if not fault_found:
            results.append(0)
    return results
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052510
1390052511,unknown,unknown,unknown,"from collections import deque
def first_negative_in_window(arr, k):
    q = deque() 
    result = []
    for i in range(k):
        if arr[i] < 0:
            q.append(i)
    if q:
        result.append(arr[q[0]])
    else:
        result.append(0)
    for i in range(k, len(arr)):
        if q and q[0] < i - k + 1:
            q.popleft()
        if arr[i] < 0:
            q.append(i)
        if q:
            result.append(arr[q[0]])
        else:
            result.append(0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    ans = first_negative_in_window(arr, k)
    print("" "".join(map(str, ans)))",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052511
1390052509,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, len(arr)):
        while dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    output = earliest_faulty_reading(arr, k)
    print("" "".join(map(str, output)))",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052509
1390052501,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    """"""
    Finds the earliest faulty reading for each consecutive batch of size k.
    Args:
        arr: A list of sensor readings (integers).
        k: The batch size.
    Returns:
        A list of earliest faulty readings for each batch.
    """"""
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        earliest_fault = 0
        for j, reading in enumerate(batch):
            if reading < 0:
                earliest_fault = reading
                break
        result.append(earliest_fault)
    return result
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = find_earliest_faults(arr, k)
        print(*result)
solve()",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052501
1390052502,unknown,unknown,unknown,"def faults(n, k, arr):
    output = []
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        first_neg = next((x for x in batch if x < 0), 0)
        output.append(first_neg)
    print(*output)
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    faults(n, k, arr)",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052502
1390052505,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        if i >= k - 1:
            if dq:
                result.append(arr[dq[0]])  
            else:
                result.append(0)  
    return result
def process_test_cases():
    t = int(input())  
    for _ in range(t):
        n, k = map(int, input().split())  
        arr = list(map(int, input().split()))  
        result = earliest_faulty_reading(arr, k)
        print(' '.join(map(str, result)))
process_test_cases()",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052505
1390052500,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052500
1390052495,unknown,unknown,unknown,"from collections import deque
def earliest_faculty_readings(arr,k):
    dq,result=deque(),[]
    for i in range (len(arr)):
        if dq and dq[0]<i-k+1:
            dq.popleft()
        if arr[i]<0:
            dq.append(i)
        if i>=k-1:
            result.append(arr[dq[0]] if dq else 0)
    return result
t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    arr=list(map(int,input().split()))
    print(*earliest_faculty_readings(arr,k))
        ",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052495
1390052497,unknown,unknown,unknown,"def solve_breach_problem(n, k, firewall_strengths):
    # Create a 2D dp array where:
    # dp[i][j] = minimum effort needed to breach first i firewalls 
    # after skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: No firewall, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        current_strength = firewall_strengths[i - 1]
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall (if j firewalls already skipped)
            if j <= i - 1:  # We can only skip j firewalls out of i-1 previous ones
                # Current firewall strength increases by j (number of previously skipped firewalls)
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
            # Option 2: Skip the current firewall (if we haven't used all our skips)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Find minimum effort considering all possible numbers of skipped firewalls
    return min(dp[n])
def main():
    test_cases = int(input())
    for _ in range(test_cases):
        n, k = map(int, input().split())
        firewall_strengths = list(map(int, input().split()))
        min_effort = solve_breach_problem(n, k, firewall_strengths)
        print(min_effort)
if __name__ == ""__main__"":
    main()",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052497
1390052498,unknown,unknown,unknown,"import sys
def min_effort_to_breach(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        total_effort = sum(firewalls)
        min_effort = total_effort
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + firewalls[i]
        for i in range(n - k + 1):
            skipped_sum = prefix_sum[i + k] - prefix_sum[i]  
            increased_effort = (n - (i + k)) * k  
            min_effort = min(min_effort, total_effort - skipped_sum + increased_effort)
        results.append(str(min_effort))
    return ""\n"".join(results)
input = sys.stdin.read
data = input().split()
t = int(data[0])
index = 1
test_cases = []
for _ in range(t):
    n, k = int(data[index]), int(data[index + 1])
    firewalls = list(map(int, data[index + 2: index + 2 + n]))
    index += 2 + n
    test_cases.append((n, k, firewalls))
print(min_effort_to_breach(test_cases))",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052498
1390052490,unknown,unknown,unknown,"def minimum_effort_to_breach_firewalls(test_cases):
    results = []
    for case in test_cases:
        n, k, firewalls = case
        min_effort = float('inf')  # Initialize with a large value
        for i in range(1 << n):  # Iterate through all possible subsets of firewalls to skip
            skipped_count = 0
            current_effort = 0
            temp_firewalls = firewalls[:]  # Create a copy to modify
            # Determine which firewalls are skipped based on the bits in i
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_count += 1
                    skipped_indices.append(j)
            if skipped_count <= k:
                effort = 0
                skipped_indices.sort()
                #Calculate effort with increased strength for subsequent firewalls
                for j in range(n):
                    if j in skipped_indices:
                        continue
                    else:
                        increase = 0
                        skipped_before = 0
                        for skip_idx in skipped_indices:
                            if skip_idx < j:
                                skipped_before += 1
                        effort += firewalls[j] + skipped_before
                min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
# Example Usage (based on the sample input):
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
results = minimum_effort_to_breach_firewalls(test_cases)
for result in results:
    print(result)",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052490
1390052492,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int testCases=scanner.nextInt();
        for(int t=0;t<testCases;t++){
            int n=scanner.nextInt();
            int k=scanner.nextInt();
            int[] arr=new int[n];
            for(int i=0;i<n;i++) arr[i]=scanner.nextInt();
            List<Integer> result=new ArrayList<>();
            for(int i=0;i<=n-k;i++) {
                int earliestFault=0;
                for(int j=i;j<i+k;j++) {
                    if(arr[j]<0) {
                        earliestFault=arr[j];
                        break;
                    }
                }
                result.add(earliestFault);
            }
            for(int res:result) System.out.print(res+"" "");
            System.out.println();
        }
        scanner.close();
    }
}",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052492
1390052486,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # For each possible remaining substring (after removing prefixes and suffixes)
    min_cost = float('inf')
    # Try all possible substrings (start, end+1)
    for start in range(n + 1):
        for end in range(start, n + 1):
            # Calculate the substring that remains after decommissioning
            remaining = servers[start:end]
            # Calculate metrics
            active_removed = servers[:start].count('1') + servers[end:].count('1')
            idle_remaining = remaining.count('0')
            # Cost is the maximum of idle servers remaining and active servers removed
            cost = max(idle_remaining, active_removed)
            # Update minimum cost
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052486
1390052476,unknown,unknown,unknown,"def min_effort_to_breach(T, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        if k == n:
            results.append(""0"")  # If all firewalls can be skipped, effort is 0
            continue
        total_effort = sum(firewalls)
        min_effort = total_effort
        # Compute initial sum of first k firewalls
        window_sum = sum(firewalls[:k])
        # Iterate through possible skip windows
        for i in range(n - k + 1):
            skipped_firewalls = k
            increased_security = sum(range(1, skipped_firewalls + 1))  # Penalty for skipping
            new_effort = total_effort - window_sum + increased_security
            min_effort = min(min_effort, new_effort)
            # Move the sliding window
            if i + k < n:
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
        results.append(str(min_effort))
    return ""\n"".join(results)
# Read input
T = int(input())
test_cases = []
for _ in range(T):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(T, test_cases))",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052476
1390052479,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        while dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases(t, test_cases):
    for n, k, arr in test_cases:
        print(*earliest_faulty_readings(arr, k))
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
process_test_cases(t, test_cases)",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052479
1390052485,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static List<List<Integer>> f(int t, List<int[]> a, List<int[]> s) {
        List<List<Integer>> r = new ArrayList<>();
        for (int i = 0; i < t; i++) {
            int n = s.get(i)[0], k = s.get(i)[1];
            int[] x = a.get(i);
            List<Integer> res = new ArrayList<>();
            Deque<Integer> d = new LinkedList<>();
            for (int j = 0; j < k; j++) {
                if (x[j] < 0) d.add(j);
            }
            res.add(d.isEmpty() ? 0 : x[d.peek()]);
            for (int j = k; j < n; j++) {
                if (!d.isEmpty() && d.peek() <= j - k) d.poll();
                if (x[j] < 0) d.add(j);
                res.add(d.isEmpty() ? 0 : x[d.peek()]);
            }
            r.add(res);
        }
        return r;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        List<int[]> a = new ArrayList<>(), s = new ArrayList<>();
        for (int i = 0; i < t; i++) {
            int n = sc.nextInt(), k = sc.nextInt();
            s.add(new int[]{n, k});
            int[] x = new int[n];
            for (int j = 0; j < n; j++) x[j] = sc.nextInt();
            a.add(x);
        }
        List<List<Integer>> o = f(t, a, s);
        for (List<Integer> l : o) {
            for (int v : l) System.out.print(v + "" "");
            System.out.println();
        }
        sc.close();
    }
}",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052485
1390052469,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();  // Number of testcases
        // Process each testcase
        while (t-- > 0) {
            int n = scanner.nextInt();  // Size of array
            int k = scanner.nextInt();  // Batch size
            int[] arr = new int[n];
            // Reading array elements
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> result = earliestFaults(arr, k);
            // Printing the result for the current testcase
            for (int res : result) {
                System.out.print(res + "" "");
            }
            System.out.println();
        }
    }
    // Function to calculate the earliest faults for consecutive batches of size k
    private static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        // Iterating through the array
        for (int i = 0; i < arr.length; i++) {
            // Remove elements which are no longer in the current window
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            // Add the current element index to the deque if it's a faulty component
            if (arr[i] < 0) {
                deque.addLast(i);
            }
            // For the first batch of size k and onward, calculate the earliest fault
            if (i >= k - 1) {
                if (!deque.isEmpty()) {
                    result.add(arr[deque.peekFirst()]);  // Add the earliest fault in the batch
                } else {
                    result.add(0);  // No faults in the current batch
                }
            }
        }
        return result;
    }
}",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052469
1390052461,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process all sliding windows
    for i in range(n - k + 1):
        # Append first negative in current window
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of window
        while dq and dq[0] < i + 1:
            dq.popleft()
        # Add next element if negative
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    earliest_faulty_readings(arr, k)",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052461
1390052462,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    # DP array, initialized with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: No firewalls, no effort
    # DP Computation
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Case 1: Don't skip this firewall
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
            # Case 2: Skip this firewall (if skips available)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Answer is the minimum effort across all skip possibilities
    return min(dp[n])
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    n, k = map(int, input().split())  # Read n and k
    firewalls = list(map(int, input().split()))  # Firewall strengths
    # Compute and print the minimum effort
    print(min_effort(n, k, firewalls))",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052462
1390052468,unknown,unknown,unknown,"import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            System.out.println(solve(n, k, a));
        }
        scanner.close();
    }
    public static long solve(int n, int k, int[] a) {
        long minEffort = Long.MAX_VALUE;
        for (int i = 0; i <= k; i++) {
            long effort = 0;
            int skipped = 0;
            int increasedStrength = 0;
            int remainingSkips = k;
            for (int j = 0; j < n; j++) {
                if (skipped < i && remainingSkips > 0) {
                    skipped++;
                    remainingSkips--;
                    increasedStrength++;
                } else {
                    effort += a[j] + increasedStrength -1;
                    if(a[j] < 0){
                      effort +=1;
                    }
                }
            }
            minEffort = Math.min(minEffort, effort);
        }
        return minEffort;
    }
}",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052468
1390052454,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // Number of test cases
        for (int testCase = 0; testCase < t; testCase++) {
            int n = scanner.nextInt(); // Size of array
            int k = scanner.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            // Process each batch and find earliest fault
            for (int i = 0; i <= n - k; i++) {
                int earliestFault = findEarliestFault(arr, i, i + k - 1);
                System.out.print(earliestFault + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
    // Function to find the earliest fault (negative reading) in a batch
    private static int findEarliestFault(int[] arr, int start, int end) {
        for (int i = start; i <= end; i++) {
            if (arr[i] < 0) {
                return arr[i]; // Return the first negative reading
            }
        }
        return 0; // No faults found
    }
}",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052454
1390052456,unknown,unknown,unknown,"def faulty_sensor_readings(arr, k):
    """"""
    Determines the earliest faulty reading for each consecutive batch of size k.
    Args:
        arr: A list of sensor readings.
        k: The batch size.
    Returns:
        A list containing the earliest faulty reading for each batch.
    """"""
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        fault = 0
        for num in batch:
            if num < 0:
                fault = num
                break
        result.append(fault)
    return result
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = faulty_sensor_readings(arr, k)
        print(*result)",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052456
1390052458,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    result = []
    dq = deque()
    # Process the first k elements
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining elements
    for i in range(k, len(arr)):
        # Remove elements not in the current window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add the new element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    # Get the earliest faulty readings for each batch
    output = earliest_faulty_reading(arr, k)
    print("" "".join(map(str, output)))",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052458
1390052443,unknown,unknown,unknown,"#include <iostream>
#include <vector>
using namespace std;
int main() {
    int t;
    cin >> t; 
    for (int test = 0; test < t; test++) {
        int n, k;
        cin >> n >> k; 
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i]; 
        }
        //Compute next_neg array
        vector<int> next_neg(n);
        for (int i = n - 1; i >= 0; i--) {
            if (arr[i] < 0) {
                next_neg[i] = i; 
            } else {
                next_neg[i] = (i + 1 < n) ? next_neg[i + 1] : n; 
            }
        }
        for (int i = 0; i <= n - k; i++) {
            if (next_neg[i] < i + k) {
                cout << arr[next_neg[i]] << "" ""; 
            } else {
                cout << ""0 ""; 
            }
        }
        cout << endl; 
    }
    return 0;
}",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052443
1390052445,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, len(arr)):
        while dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    output = earliest_faulty_reading(arr, k)
    print("" "".join(map(str, output)))",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052445
1390052451,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove elements not part of the current batch
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # If current element is faulty, add its index to deque
        if arr[i] < 0:
            dq.append(i)
        # Add the first faulty element of the batch to result
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
if __name__ == ""__main__"":
    main()",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052451
1390052440,unknown,unknown,unknown,"def solve_breach_problem(n, k, firewall_strengths):
    # Create a 2D dp array where:
    # dp[i][j] = minimum effort needed to breach first i firewalls 
    # after skipping exactly j firewalls
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: No firewall, no effort
    dp[0][0] = 0
    for i in range(1, n + 1):
        current_strength = firewall_strengths[i - 1]
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall (if j firewalls already skipped)
            if j <= i - 1:  # We can only skip j firewalls out of i-1 previous ones
                # Current firewall strength increases by j (number of previously skipped firewalls)
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
            # Option 2: Skip the current firewall (if we haven't used all our skips)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    # Find minimum effort considering all possible numbers of skipped firewalls
    return min(dp[n])
def main():
    test_cases = int(input())
    for _ in range(test_cases):
        n, k = map(int, input().split())
        firewall_strengths = list(map(int, input().split()))
        min_effort = solve_breach_problem(n, k, firewall_strengths)
        print(min_effort)
if __name__ == ""__main__"":
    main()",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052440
1390052429,unknown,unknown,unknown,"#include <stdio.h>
#include <string.h>
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        char rack[100005];
        scanf(""%s"", rack);
        int n = strlen(rack);
        int first = -1, last = -1;
        for (int i = 0; i < n; i++) {
            if (rack[i] == '1') {
                if (first == -1) {
                    first = i;
                }
                last = i;
            }
        }
        if (first == -1) {
            printf(""0\n"");
        } else {
            int zeroCount = 0;
            int oneCount = 0;
            for (int i = first; i <= last; i++) {
                if (rack[i] == '0') {
                    zeroCount++;
                } else {
                    oneCount++;
                }
            }
            if (zeroCount < oneCount) {
                printf(""%d\n"", zeroCount);
            } else {
                printf(""%d\n"", oneCount);
            }
        }
    }
    return 0;
}",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052429
1390052430,unknown,unknown,unknown,"def min_effort(arr, k):
    n = len(arr)
    if k >= n:
        return 0
    prev_dp = [float('inf')] * (k + 1)
    prev_dp[0] = 0  
    for i in range(n):
        curr_dp = [float('inf')] * (k + 1)
        for j in range(k + 1):
            curr_dp[j] = prev_dp[j] + arr[i] + j if j <= i else float('inf')
            if j > 0:
                curr_dp[j] = min(curr_dp[j], prev_dp[j - 1])
        prev_dp = curr_dp
    return min(prev_dp)
def solve():
    for _ in range(int(input())):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print(min_effort(arr, k))
if __name__ == ""__main__"":
    solve()",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052430
1390052427,unknown,unknown,unknown,"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for (int i = 0; i < t; i++) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] a = new int[n];
            for (int j = 0; j < n; j++) {
                a[j] = scanner.nextInt();
            }
            solve(n, k, a);
        }
        scanner.close();
    }
    public static void solve(int n, int k, int[] a) {
        long minEffort = Long.MAX_VALUE;
        for (int i = 0; i < (1 << n); i++) {
            List<Integer> skippedIndices = new ArrayList<>();
            for (int j = 0; j < n; j++) {
                if ((i >> j) % 2 == 1) {
                    skippedIndices.add(j);
                }
            }
            if (skippedIndices.size() <= k) {
                long effort = 0;
                int increasedStrength = 0;
                int currentSkippedIndex = 0;
                for (int j = 0; j < n; j++) {
                    if (currentSkippedIndex < skippedIndices.size() && skippedIndices.get(currentSkippedIndex) == j) {
                        increasedStrength++;
                        currentSkippedIndex++;
                    } else {
                        effort += a[j] + increasedStrength;
                    }
                }
                minEffort = Math.min(minEffort, effort);
            }
        }
        System.out.println(minEffort);
    }
}",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052427
1390052416,unknown,unknown,unknown,"def min_effort(n, k, arr):
    arr.sort()  # Sort firewalls in ascending order
    total_sum = sum(arr)  # Total strength without skipping
    min_effort = total_sum  # Start with no skipping
    for x in range(k + 1):  # Try skipping from 0 to k firewalls
        remaining_sum = sum(arr[x:])  # Sum of remaining firewalls
        added_penalty = (n - x) * x  # Every remaining firewall gets increased by x
        current_effort = remaining_sum + added_penalty
        min_effort = min(min_effort, current_effort)  # Update minimum effort
    print(min_effort)
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Read n and k
    arr = list(map(int, input().split()))  # Read firewall strengths
    min_effort(n, k, arr)",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052416
1390052414,unknown,unknown,unknown,"def min_effort_to_breach(t, test_cases):
    results = []
    for n, k, firewalls in test_cases:
        if k == n:
            results.append(""0"")
            continue
        total_effort = sum(firewalls)
        min_effort = total_effort
        # Compute the initial window sum (sum of first k firewalls)
        current_sum = sum(firewalls[:k])
        # Iterate over all possible positions to skip k firewalls
        for i in range(n - k + 1):
            increased_security = k  # Since each skipped firewall increases the rest by 1
            new_effort = total_effort - current_sum + increased_security
            min_effort = min(min_effort, new_effort)
            # Slide the window
            if i + k < n:
                current_sum = current_sum - firewalls[i] + firewalls[i + k]
        results.append(str(min_effort))
    return ""\n"".join(results)
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Compute and print results
print(min_effort_to_breach(t, test_cases))",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052414
1390052421,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052421
1390052404,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, len(arr)):
        while dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    output = earliest_faulty_reading(arr, k)
    print("" "".join(map(str, output)))",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052404
1390052407,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(n):
        # Add current element index to deque if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Start recording results when we reach the first full batch
        if i >= k - 1:
            result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Read array size and batch size
    arr = list(map(int, input().split()))  # Read array elements
    print(*earliest_faulty_readings(arr, k))  # Print the output as space-separated values",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052407
1390052413,unknown,unknown,unknown,"def min_decommissioning_cost(servers):
    n = len(servers)
    # Count total active servers (1's) and idle servers (0's)
    total_active = servers.count('1')
    total_idle = servers.count('0')
    min_cost = float('inf')
    # Try all possible combinations of removing servers from the beginning and end
    for left in range(n + 1):  # Number of servers to remove from the left
        for right in range(n + 1 - left):  # Number of servers to remove from the right
            if left + right > n:
                continue
            # Count active and idle servers in the segments we're removing
            active_removed_left = servers[:left].count('1')
            active_removed_right = servers[n-right:].count('1')
            total_active_removed = active_removed_left + active_removed_right
            # Calculate the remaining idle servers
            remaining_idle = total_idle - (left - active_removed_left) - (right - active_removed_right)
            # Calculate cost
            cost = max(remaining_idle, total_active_removed)
            # Update minimum cost
            min_cost = min(min_cost, cost)
    return min_cost
# Process test cases
t = int(input())
for _ in range(t):
    servers = input().strip()
    print(min_decommissioning_cost(servers))",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052413
1390052401,unknown,unknown,unknown,"import java.util.*;
public class SmartFactoryQC {
    public static List<Integer> earliestFaultyReadings(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>(); // Stores indices of negative values
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            // Remove indices that are out of the current window
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Add current element index if it's negative
            if (arr[i] < 0) {
                deque.offer(i);
            }
            // Process output once we reach full window size
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Array size
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = earliestFaultyReadings(arr, k);
            // Print output
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
}",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052401
1390052397,unknown,unknown,unknown,"from collections import deque
def faulty_readings(num_testcases, testcases):
    results = []
    for i in range(num_testcases):
        n, k = testcases[i][0]  
        arr = testcases[i][1]  
        dq = deque() 
        result = []
        for j in range(k):
            if arr[j] < 0:
                dq.append(j)
        result.append(arr[dq[0]] if dq else 0)
        for j in range(k, n):
            while dq and dq[0] < j - k + 1:
                dq.popleft()
            if arr[j] < 0:
                dq.append(j)
            result.append(arr[dq[0]] if dq else 0)
        results.append(result)
    return results
if __name__ == ""__main__"":
    num_testcases = int(input().strip())  
    testcases = []
    for _ in range(num_testcases):
        n, k = map(int, input().strip().split())  
        arr = list(map(int, input().strip().split()))  
        testcases.append(((n, k), arr))  
    results = faulty_readings(num_testcases, testcases)
    for result in results:
        print("" "".join(map(str, result)))  ",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052397
1390052398,unknown,unknown,unknown,"def min_decommission_cost(binary_string):
    n = len(binary_string)
    # Step 1: Find the first and last occurrence of '1'
    first_one = binary_string.find('1')
    last_one = binary_string.rfind('1')
    # If there are no active servers, cost is 0
    if first_one == -1:
        return 0  
    # Step 2: Extract the ""core"" part (between first and last '1')
    core_section = binary_string[first_one:last_one + 1]
    # Step 3: Compute values needed for the cost calculation
    remaining_idle = core_section.count('0')  # Count of '0's inside the core
    removed_active = binary_string[:first_one].count('1') + binary_string[last_one + 1:].count('1')
    return max(remaining_idle, removed_active)
# Read input
T = int(input())  # Number of test cases
for _ in range(T):
    binary_string = input().strip()
    print(min_decommission_cost(binary_string))",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052398
1390052399,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process all sliding windows
    for i in range(n - k + 1):
        # Append first negative in current window
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of window
        while dq and dq[0] < i + 1:
            dq.popleft()
        # Add next element if negative
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    earliest_faulty_readings(arr, k)",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052399
1390052388,unknown,unknown,unknown,"#include <stdio.h>
#include <string.h>
#include <limits.h>
int minDecommissionCost(char *rack) {
    int n = strlen(rack);
    int first = -1, last = -1;
    for (int i = 0; i < n; i++) {
        if (rack[i] == '1') {
            if (first == -1) first = i;
            last = i;
        }
    }
    if (first == -1) return 0;
    int zeroCount = 0, oneCount = 0;
    for (int i = first; i <= last; i++) {
        if (rack[i] == '0') zeroCount++;
        else oneCount++;
    }
    return (zeroCount > oneCount) ? oneCount : zeroCount;
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        char rack[100005];
        scanf(""%s"", rack);
        printf(""%d\n"", minDecommissionCost(rack));
    }
    return 0;
}",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052388
1390052394,unknown,unknown,unknown,"def faulty_sensor_readings(arr, k):
    """"""
    Determines the earliest faulty reading for each consecutive batch of size k.
    Args:
        arr: A list of sensor readings.
        k: The batch size.
    Returns:
        A list containing the earliest faulty reading for each batch.
    """"""
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        fault = 0
        for num in batch:
            if num < 0:
                fault = num
                break
        result.append(fault)
    return result
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = faulty_sensor_readings(arr, k)
        print(*result)",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052394
1390052389,unknown,unknown,unknown,"t = int(input())
for i in range(t):  
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    res = []
    for i in range(n - k + 1):
        for j in range(i, i + k):
            if arr[j] < 0:
                res.append(arr[j])
                break
        else:
            res.append(0)
    print("" "".join(map(str, res)))",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052389
1390052382,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()  # Stores indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process each window
    for i in range(len(arr) - k + 1):
        # If deque is not empty, first element is the first negative in window
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Slide window: Remove elements out of range
        if dq and dq[0] == i:
            dq.popleft()
        # Add next element in the window
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    # Process and output result
    print(*earliest_faulty_readings(arr, k))",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052382
1390052378,unknown,unknown,unknown,"def min_effort_to_breach(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        min_effort = float('inf')
        for i in range(n - k + 1):
            effort = 0
            skip_count = 0
            for j in range(n):
                if i <= j < i + k:
                    skip_count += 1  # Skipping this firewall
                else:
                    effort += firewalls[j] + skip_count  # Adding the firewall's strength + penalty
            min_effort = min(min_effort, effort)
        results.append(str(min_effort))
    return ""\n"".join(results)
t = int(input())
test_cases = [tuple(map(int, input().split())) + (list(map(int, input().split())),) for _ in range(t)]
print(min_effort_to_breach(test_cases))",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052378
1390052385,unknown,unknown,unknown,"def earliest_fault(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        batch_results = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            fault = next((x for x in batch if x < 0), 0)
            batch_results.append(fault)
        results.append(batch_results)
    return results
import sys
input_data = sys.stdin.read()
lines = input_data.splitlines()
t = int(lines[0])
test_cases = []
index = 1
for _ in range(t):
    n, k = map(int, lines[index].split())
    index += 1
    arr = list(map(int, lines[index].split()))
    index += 1
    test_cases.append((n, k, arr))
results = earliest_fault(test_cases)
for result in results:
    print("" "".join(map(str, result)))",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052385
1390052374,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove indices that are out of the current window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add current element index if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Start adding results only when we have a full batch
        if i >= k - 1:
            if dq:
                result.append(arr[dq[0]])  # Earliest fault in the window
            else:
                result.append(0)  # No fault found in the window
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))  # Sensor readings
    # Get and print results
    print("" "".join(map(str, earliest_faults(arr, k))))",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052374
1390052366,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        res = []
        dq = deque()
        # Process the first k elements
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        res.append(arr[dq[0]] if dq else 0)
        # Process the remaining elements
        for i in range(k, n):
            # Remove elements that are out of the current window
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add new element if it is faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            res.append(arr[dq[0]] if dq else 0)
        results.append(res)
    return results
# Read input
def main():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        test_cases.append((n, k, arr))
    # Get results
    output = earliest_faulty_readings(test_cases)
    # Print results
    for res in output:
        print("" "".join(map(str, res)))
if __name__ == ""__main__"":
    main()",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052366
1390052367,unknown,unknown,unknown,"def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        min_effort = float('inf')
        for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
            skipped_indices = []
            for j in range(n):
                if (i >> j) & 1:
                    skipped_indices.append(j)
            if len(skipped_indices) <= k:
                effort = 0
                increased_strength = 0
                current_skipped_index = 0
                for j in range(n):
                    if current_skipped_index < len(skipped_indices) and skipped_indices[current_skipped_index] == j:
                        increased_strength += 1
                        current_skipped_index += 1
                    else:
                        effort += a[j] + increased_strength
                min_effort = min(min_effort, effort)
        print(min_effort)
solve()",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052367
1390052363,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        dq = deque()
        res = []
        for i in range(n):
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            if i >= k - 1:
                res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    print(""\n"".join(results))
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
earliest_faulty_readings(test_cases)",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052363
1390052359,unknown,unknown,unknown,"def earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i+k]
        fault_found = False
        for num in batch:
            if num < 0:
                result.append(num)
                fault_found = True
                break
        if not fault_found:
            result.append(0)
    return result
t = int(input())  
for _ in range(t):
    n, k = map(int, input().split())  
    arr = list(map(int, input().split()))  
    result = earliest_fault(arr, k)
    print(*result)  ",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052359
1390052360,unknown,unknown,unknown,"def find_faulty_readings(arr, k):
    n = len(arr)
    results = []
    for i in range(n - k + 1):
        batch = arr[i:i+k]
        faulty_index = next((j for j, value in enumerate(batch) if value < 0), None)
        if faulty_index is not None:
            results.append(batch[faulty_index])
        else:
            results.append(0)
    return results
# Read input
import sys
input = sys.stdin.read
data = input().split()
t = int(data[0])  # Number of test cases
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    k = int(data[index + 1])
    index += 2
    arr = list(map(int, data[index:index + n]))
    index += n
    results.append(find_faulty_readings(arr, k))
# Print results
for result in results:
    print("" "".join(map(str, result)))",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052360
1390052362,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t-- > 0){
            int n = sc.nextInt();
            int k = sc.nextInt();
            int [] arr = new int [n];
            for(int i = 0 ;i<n ; i++){
                arr[i] = sc.nextInt();
            }
            for(int i = 0 ; i<=n-k ; i++){
                int earlyFault = 0;
                for(int j = i ; j<i+k ; j++){
                    if(arr[j]<0){
                        earlyFault = arr[j];
                        break;
                    }
                }
                System.out.print(earlyFault+ "" "");
            }
            System.out.println();
        }
    }
}",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052362
1390052353,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, testcases):
    results = []
    for n, k, arr in testcases:
        dq = deque() 
        res = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        res.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            res.append(arr[dq[0]] if dq else 0)
        results.append(res)
    return results
t = int(input().strip())
testcases = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    testcases.append((n, k, arr))
output = earliest_faulty_readings(t, testcases)
for res in output:
    print(*res)",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052353
1390052354,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(t, test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        dq = deque()
        output = []
        for i in range(n):
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            if i >= k - 1:
                output.append(arr[dq[0]] if dq else 0)
        results.append(output)
    return results
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
results = earliest_faulty_readings(t, test_cases)
for res in results:
    print("" "".join(map(str, res)))",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052354
1390052357,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    result = []
    dq = deque()
    for i in range(len(arr)):
        # Remove out-of-window elements from the deque
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add current element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Once we have a full window, determine the earliest fault
        if i >= k - 1:
            if dq:
                result.append(arr[dq[0]])  # Earliest negative in the window
            else:
                result.append(0)  # No negative found
    return result
# Input processing
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_faulty_reading(arr, k)
    print(' '.join(map(str, result)))
    ",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052357
1390052345,unknown,unknown,unknown,"def min_effort_to_breach(test_cases):
    results = []
    for n, k, arr in test_cases:
        if k >= n:
            results.append(0)
            continue
        min_effort = float('inf')
        # Iterate through all possible segments of length k to skip
        for i in range(n - k + 1):
            skipped = arr[i:i + k]
            remaining = arr[:i] + arr[i + k:]
            # Calculate the effort after the skip
            effort = sum(remaining) + sum(range(1, len(skipped) + 1))
            min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
if __name__ == ""__main__"":
    t = int(input())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        test_cases.append((n, k, arr))
    results = min_effort_to_breach(test_cases)
    for res in results:
        print(res)",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052345
1390052341,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first k elements
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process rest of the elements
    for i in range(k, len(arr)):
        # Remove elements that are out of the window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result
        result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print(*earliest_faulty_readings(arr, k))
if __name__ == ""__main__"":
    process_test_cases()",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052341
1390052343,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <deque>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        deque<int> dq;
        vector<int> result;
        for (int i = 0; i < n; i++) {
            // Add current element if it's a fault (negative)
            if (arr[i] < 0) {
                dq.push_back(i);
            }
            // Remove elements that are out of current window
            if (i >= k && !dq.empty() && dq.front() <= i - k) {
                dq.pop_front();
            }
            // Start recording result once we have a complete window
            if (i >= k - 1) {
                if (!dq.empty()) {
                    result.push_back(arr[dq.front()]);
                } else {
                    result.push_back(0);
                }
            }
        }
        // Print the result for this test case
        for (int i = 0; i < result.size(); i++) {
            cout << result[i];
            if (i != result.size() - 1) cout << "" "";
        }
        cout << endl;
    }
    return 0;
}",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052343
1390052340,unknown,unknown,unknown,"def min_cost(servers):
    n = len(servers)
    # Try all possible combinations of prefix and suffix removal
    min_cost = float('inf')
    # i represents number of servers to remove from start
    for i in range(n + 1):
        # j represents number of servers to remove from end
        for j in range(n - i + 1):
            # Get the remaining substring
            remaining = servers[i:n-j]
            if not remaining:  # If we remove everything
                ones_removed = servers.count('1')
                cost = max(0, ones_removed)
            else:
                # Count remaining zeros (idle servers)
                zeros_remaining = remaining.count('0')
                # Count ones removed from start and end
                ones_removed = servers[:i].count('1') + servers[n-j:].count('1')
                cost = max(zeros_remaining, ones_removed)
            min_cost = min(min_cost, cost)
    return min_cost
# Handle automatic input
t = int(input())  # Number of test cases
for _ in range(t):
    servers = input().strip()  # Read the binary string
    result = min_cost(servers)
    print(result)",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052340
1390052328,unknown,unknown,unknown,"def faulty_sensor_readings(arr, k):
    """"""
    Determines the earliest faulty reading for each consecutive batch of size k.
    Args:
        arr: A list of sensor readings.
        k: The batch size.
    Returns:
        A list containing the earliest faulty reading for each batch.
    """"""
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        fault = 0
        for num in batch:
            if num < 0:
                fault = num
                break
        result.append(fault)
    return result
if __name__ == ""__main__"":
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = faulty_sensor_readings(arr, k)
        print(*result)",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052328
1390052330,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <deque>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for (int i = 0; i < n; i++) 
            cin >> arr[i];
        deque<int> dq;
        vector<int> result;
        for (int i = 0; i < n; i++) {
            if (!dq.empty() && dq.front() == i - k) 
                dq.pop_front();
            if (arr[i] < 0) 
                dq.push_back(i);
            if (i >= k - 1) 
                result.push_back(dq.empty() ? 0 : arr[dq.front()]);
        }
        for (int num : result) 
            cout << num << "" "";
        cout << endl;
    }
    return 0;
}",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052330
1390052338,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052338
1390052313,unknown,unknown,unknown,"def solve():
    t = int(input())
    for _ in range(t):
        s = input()
        n = len(s)
        min_cost = float('inf')
        for i in range(n + 1):
            removed_start = s[:i]
            remaining = s[i:]
            for j in range(len(remaining) + 1):
                idle_remaining = remaining[:len(remaining) - j].count('0')
                removed_end = remaining[len(remaining) - j:]
                active_removed = removed_start.count('1') + removed_end.count('1')
                cost = max(idle_remaining, active_removed)
                min_cost = min(min_cost, cost)
        print(min_cost)
solve()",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052313
1390052317,unknown,unknown,unknown,"def find_faulty_readings(arr, k):
    n = len(arr)
    results = []
    for i in range(n - k + 1):
        batch = arr[i:i+k]
        faulty_index = next((j for j, value in enumerate(batch) if value < 0), None)
        if faulty_index is not None:
            results.append(batch[faulty_index])
        else:
            results.append(0)
    return results
# Read input
import sys
input = sys.stdin.read
data = input().split()
t = int(data[0])  # Number of test cases
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    k = int(data[index + 1])
    index += 2
    arr = list(map(int, data[index:index + n]))
    index += n
    results.append(find_faulty_readings(arr, k))
# Print results
for result in results:
    print("" "".join(map(str, result)))",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052317
1390052315,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Append result for first window
    result.append(arr[dq[0]] if dq else 0)
    # Process remaining windows
    for i in range(k, n):
        # Remove elements not in the current window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add new element if faulty
        if arr[i] < 0:
            dq.append(i)
        # Append result for current window
        result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases(t, test_cases):
    results = []
    for n, k, arr in test_cases:
        results.append("" "".join(map(str, earliest_faults(arr, k))))
    return ""\n"".join(results)
# Reading input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Output results
print(process_test_cases(t, test_cases))",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052315
1390052312,unknown,unknown,unknown,"def earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i+k]
        fault_found = False
        for num in batch:
            if num < 0:
                result.append(num)
                fault_found = True
                break
        if not fault_found:
            result.append(0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052312
1390052305,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of this window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052305
1390052306,unknown,unknown,unknown,"def min_effort_to_breach(test_cases):
    results = []
    for n, k, firewalls in test_cases:
        if k == n:
            results.append(""0"")
            continue
        total_effort = sum(firewalls)
        min_effort = total_effort
        current_sum = sum(firewalls[:k])
        for i in range(n - k + 1):
            increased_security = sum(range(1, min(k, n - i) + 1))
            new_effort = total_effort - current_sum + increased_security
            min_effort = min(min_effort, new_effort)
            if i + k < n:
                current_sum = current_sum - firewalls[i] + firewalls[i + k]
        results.append(str(min_effort))
    return ""\n"".join(results)
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    test_cases.append((n, k, firewalls))
# Get output and print
print(min_effort_to_breach(test_cases))",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052306
1390052310,unknown,unknown,unknown,"#include <stdio.h>
#include <string.h>
#include <limits.h>
int minDecommissionCost(char *rack) {
    int n = strlen(rack);
    int first = -1, last = -1;
    for (int i = 0; i < n; i++) {
        if (rack[i] == '1') {
            if (first == -1) first = i;
            last = i;
        }
    }
    if (first == -1) return 0;
    int zeroCount = 0, oneCount = 0;
    for (int i = first; i <= last; i++) {
        if (rack[i] == '0') zeroCount++;
        else oneCount++;
    }
    return zeroCount < oneCount ? zeroCount : oneCount;
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        char rack[100005];
        scanf(""%s"", rack);
        printf(""%d\n"", minDecommissionCost(rack));
    }
    return 0;
}",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052310
1390052295,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input()) 
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_faulty_readings(arr, k))",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052295
1390052300,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    n = len(arr)
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, n):
        while dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases(t, test_cases):
    for n, k, arr in test_cases:
        print(*earliest_faults(arr, k))
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
process_test_cases(t, test_cases)",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052300
1390052304,unknown,unknown,unknown,"from collections import deque
def find_fault_in_batches(sensor_readings, batch_size):
    total_readings = len(sensor_readings)
    results = []
    fault_indices = deque()
    for idx in range(total_readings):
        if fault_indices and fault_indices[0] < idx - batch_size + 1:
            fault_indices.popleft()
        if sensor_readings[idx] < 0:
            fault_indices.append(idx)
        if idx >= batch_size - 1:
            if fault_indices:
                results.append(sensor_readings[fault_indices[0]])
            else:
                results.append(0)
    return results
def handle_multiple_tests():
    test_cases = int(input())
    for _ in range(test_cases):
        size, batch_size = map(int, input().split())
        readings = list(map(int, input().split()))
        output = find_fault_in_batches(readings, batch_size)
        print(' '.join(map(str, output)))
handle_multiple_tests()",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052304
1390052283,unknown,unknown,unknown,"def min_effort_to_breach(test_cases):
    results = []
    for n, k, arr in test_cases:
        # Base case: If we can skip all firewalls, the effort is 0
        if k == n:
            results.append(0)
            continue
        # Calculate prefix sums
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + arr[i]
        # Minimum effort calculation by skipping up to 'k' firewalls
        min_effort = float('inf')
        for i in range(n - k + 1):
            # Effort for current window
            effort = prefix[i] + (prefix[n] - prefix[i + k]) + k
            min_effort = min(min_effort, effort)
        results.append(min_effort)
    return results
if __name__ == ""__main__"":
    t = int(input())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        test_cases.append((n, k, arr))
    results = min_effort_to_breach(test_cases)
    for res in results:
        print(res)",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052283
1390052286,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    # If we can skip all firewalls
    if k >= n:
        return 0
    memo = {}
    def dp(index, skips_used):
        if index == n:
            return 0
        if (index, skips_used) in memo:
            return memo[(index, skips_used)]
        # Option 1: Skip current firewall
        if skips_used < k:
            option1 = dp(index + 1, skips_used + 1)
        else:
            option1 = float('inf')
        # Option 2: Don't skip current firewall
        option2 = (firewalls[index] + skips_used) + dp(index + 1, skips_used)
        memo[(index, skips_used)] = min(option1, option2)
        return memo[(index, skips_used)]
    return dp(0, 0)
# Handle automatic input
t = int(input())  # Number of test cases
for _ in range(t):
    # Read n and k from first line
    n, k = map(int, input().split())
    # Read firewall strengths from second line
    firewalls = list(map(int, input().split()))
    # Calculate and print result
    result = min_effort(firewalls, k)
    print(result)",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052286
1390052290,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case
        dq = deque()
        res = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        res.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    return ""\n"".join(results)
t = int(input().strip())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
print(earliest_faulty_readings(test_cases))",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052290
1390052281,unknown,unknown,unknown,"#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t;
    cin >> t;
    while(t--) {
        int n, k;
        cin >> n >> k;
        vector<int> arr(n);
        for(int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> ans;
        for(int i = 0; i < n-k+1; i++) {
            int neg = 0;
            for(int j = 0; j < k; j++) {
                if(arr[i+j] < 0) {
                    neg = arr[i+j];
                    break;
                }
            }
            cout << neg << "" "";
        }
        cout << endl;
    }
    return 0;
}",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052281
1390052275,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    result.append(arr[dq[0]] if dq else 0)
    for i in range(k, len(arr)):
        while dq and dq[0] <= i - k:
            dq.popleft()
        if arr[i] < 0:
            dq.append(i)
        result.append(arr[dq[0]] if dq else 0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052275
1390052274,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    ans = []
    for tc in test_cases:
        n, k, arr = tc
        dq = deque()
        sol = []
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        sol.append(arr[dq[0]] if dq else 0)
        for i in range(k, n):
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            if arr[i] < 0:
                dq.append(i)
            sol.append(arr[dq[0]] if dq else 0)
        ans.append(sol)
    return ans
t = int(input())  
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
for res in earliest_faulty_readings(test_cases):
    print(*res)",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052274
1390052277,unknown,unknown,unknown,"def solve():
    t = int(input())
    for _ in range(t):
        s = input()
        n = len(s)
        min_cost = float('inf')
        for i in range(n + 1):
            for j in range(n - i + 1):
                removed_start = s[:i]
                remaining = s[i:n-j]
                removed_end = s[n-j:]
                idle_remaining = remaining.count('0')
                active_removed = removed_start.count('1') + removed_end.count('1')
                cost = max(idle_remaining, active_removed)
                min_cost = min(min_cost, cost)
        print(min_cost)
solve()",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052277
1390052262,unknown,unknown,unknown,"from collections import deque
def find_earliest_faults(num_cases, inputs):
    all_outputs = []
    for data in inputs:
        length, window, readings = data
        queue = deque()
        result = []
        for idx in range(length):
            while queue and queue[0] < idx - window + 1:
                queue.popleft()
            if readings[idx] < 0:
                queue.append(idx)
            if idx >= window - 1:
                result.append(readings[queue[0]] if queue else 0)
        all_outputs.append(result)
    return all_outputs
num_cases = int(input())
inputs = []
for _ in range(num_cases):
    length, window = map(int, input().split())
    readings = list(map(int, input().split()))
    inputs.append((length, window, readings))
all_outputs = find_earliest_faults(num_cases, inputs)
for output in all_outputs:
    print("" "".join(map(str, output)))",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052262
1390052264,unknown,unknown,unknown,"def find_faulty_readings(arr, k):
    n = len(arr)
    results = []
    for i in range(n - k + 1):
        batch = arr[i:i+k]
        faulty_index = next((j for j, value in enumerate(batch) if value < 0), None)
        if faulty_index is not None:
            results.append(batch[faulty_index])
        else:
            results.append(0)
    return results
# Read input
import sys
input = sys.stdin.read
data = input().split()
t = int(data[0])  # Number of test cases
index = 1
results = []
for _ in range(t):
    n = int(data[index])
    k = int(data[index + 1])
    index += 2
    arr = list(map(int, data[index:index + n]))
    index += n
    results.append(find_faulty_readings(arr, k))
# Print results
for result in results:
    print("" "".join(map(str, result)))",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052264
1390052270,unknown,unknown,unknown,"def earliest_faulty_reading(test_cases):
    results = []
    for n, k, arr in test_cases:
        batch_results = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            faulty = next((x for x in batch if x < 0), 0)
            batch_results.append(faulty)
        results.append(batch_results)
    return results
if __name__==""__main__"":
    t = int(input())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        test_cases.append((n, k, arr))
    results = earliest_faulty_reading(test_cases)
    for res in results:
        print(*res)",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052270
1390052252,unknown,unknown,unknown,"def earliest_faulty_reading(test_cases):
    results = []
    for n, k, arr in test_cases:
        batch_results = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            faulty = next((x for x in batch if x < 0), 0)
            batch_results.append(faulty)
        results.append(batch_results)
    return results
if __name__ == ""__main__"":
    t = int(input())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        test_cases.append((n, k, arr))
    results = earliest_faulty_reading(test_cases)
    for res in results:
        print(*res)",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052252
1390052257,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
int main() {
    int T;
    scanf(""%d"", &T);
    while (T--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int a[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &a[i]);
        }
        long long min_effort = LLONG_MAX;
        for (int i = 0; i < (1 << n); i++) {
            if (__builtin_popcount(i) == k) {
                long long current_effort = 0;
                int prev_skipped = 0;
                for (int j = 0; j < n; j++) {
                    if ((i >> j) & 1) {
                        continue;
                    } else {
                        current_effort += a[j];
                        if (prev_skipped>0) {
                            current_effort += prev_skipped;
                        }
                        prev_skipped = 1;
                    }
                }
                min_effort = (current_effort < min_effort) ? current_effort : min_effort;
            }
        }
        if(k == n){
            printf(""0\n"");
        }
        else{
            printf(""%lld\n"", min_effort);
        }
    }
    return 0;
}",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052257
1390052256,unknown,unknown,unknown,"def find_earliest_faulty(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i+k]
        for num in batch:
            if num < 0:
                result.append(num)
                break
        else:
            result.append(0)
    return result
def main():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        output = find_earliest_faulty(arr, k)
        print(' '.join(map(str, output)))
if __name__ == ""__main__"":
    main()",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052256
1390052249,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    total_effort = sum(firewalls)
    if k == 0:
        return total_effort
    if k >= n:
        return 0  # If we can skip all firewalls, effort is 0
    min_effort = total_effort
    for i in range(n - k + 1):  # Sliding window for skipping `k` firewalls
        skipped = sum(firewalls[i:i + k])  # Sum of k skipped firewalls
        penalty = sum(range(1, k + 1))  # Security increase for remaining firewalls
        remaining_effort = total_effort - skipped + penalty
        min_effort = min(min_effort, remaining_effort)
    return min_effort
def process_test_cases():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        print(min_effort_to_breach(n, k, firewalls))
if __name__ == ""__main__"":
    process_test_cases()",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052249
1390052231,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    # Base case: if we can skip all firewalls, effort is 0
    if k >= n:
        return 0
    # Initialize memoization dictionary
    memo = {}
    def dp(index, skips_used):
        # Base case: processed all firewalls
        if index == n:
            return 0
        # Check if already computed
        if (index, skips_used) in memo:
            return memo[(index, skips_used)]
        # Option 1: Skip this firewall if we have skips left
        if skips_used < k:
            option1 = dp(index + 1, skips_used + 1)
        else:
            option1 = float('inf')
        # Option 2: Don't skip this firewall
        # Its strength increases by skips_used
        option2 = (firewalls[index] + skips_used) + dp(index + 1, skips_used)
        # Store and return the minimum effort
        memo[(index, skips_used)] = min(option1, option2)
        return memo[(index, skips_used)]
    return dp(0, 0)
# Process test cases
t = int(input(""Enter number of test cases: ""))
for _ in range(t):
    # Get n (number of firewalls) and k (number of skips allowed)
    n, k = map(int, input(""Enter n and k (space-separated): "").split())
    # Get firewall strengths
    firewalls = list(map(int, input(""Enter firewall strengths (space-separated): "").split()))
    result = min_effort(firewalls, k)
    print(f""Minimum effort required: {result}"")",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052231
1390052243,unknown,unknown,unknown,"t=int(input())
for _ in range(t):
    n,k=list(map(int,input().split()))
    arr=list(map(int,input().split()))
    ans=[]
    for i in range(n-k+1):
        for j in range(i,i+k):
            if arr[j]<0:
                ans.append(arr[j])
                break
        else:ans.append(0)
    for i in ans:print(i,end=' ')
    print()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052243
1390052233,unknown,unknown,unknown,"def earliest_faulty_in_batches(arr, n, k):
    result = []
    # Traverse the array in batches of size k
    for i in range(n - k + 1):
        batch = arr[i:i + k]
        found_fault = False
        # Find the first negative number in the batch
        for num in batch:
            if num < 0:
                result.append(num)
                found_fault = True
                break
        # If no negative number is found, append 0
        if not found_fault:
            result.append(0)
    return result
# Reading input
t = int(input().strip())
outputs = []
for _ in range(t):
    n, k = map(int, input().strip().split())
    arr = list(map(int, input().strip().split()))
    outputs.append(earliest_faulty_in_batches(arr, n, k))
# Print results
for output in outputs:
    print("" "".join(map(str, output)))",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052233
1390052226,unknown,unknown,unknown,"def earliest_faulty_readings(t, test_cases):
    results = []
    for n, k, arr in test_cases:
        output = []
        for i in range(n - k + 1):
            found = 0
            for j in range(i, i + k):
                if arr[j] < 0:
                    found = arr[j]
                    break
            output.append(found)
        results.append(output)
    return results
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
for res in earliest_faulty_readings(t, test_cases):
    print(*res)",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052226
1390052225,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        result = []
        dq = deque()
        # Process first k elements
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Check first window
        result.append(arr[dq[0]] if dq else 0)
        # Process remaining windows
        for i in range(k, n):
            # Remove elements that are out of the window
            if dq and dq[0] <= i - k:
                dq.popleft()
            # Add new element if it is negative
            if arr[i] < 0:
                dq.append(i)
            # Get earliest faulty reading
            result.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, result)))
    return ""\n"".join(results)
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Get results and print
print(earliest_faulty_readings(test_cases))",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052225
1390052228,unknown,unknown,unknown,"def solve():
    t = int(input())
    for _ in range(t):
        s = input()
        n = len(s)
        min_cost = float('inf')
        for i in range(n + 1):
            for j in range(n - i + 1):
                removed_start = s[:i]
                remaining = s[i:n-j]
                removed_end = s[n-j:]
                idle_remaining = remaining.count('0')
                active_removed = removed_start.count('1') + removed_end.count('1')
                cost = max(idle_remaining, active_removed)
                min_cost = min(min_cost, cost)
        print(min_cost)
solve()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052228
1390052216,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void findEarliestFaultyReadings(int *arr, int n, int k) {
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
    int front = 0, rear = 0;
    int queue[n];
    // Process the first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
    }
    // Store result for the first batch
    result[0] = (front < rear) ? arr[queue[front]] : 0;
    // Process the remaining windows
    for (int i = k; i < n; i++) {
        // Remove elements not within the window
        while (front < rear && queue[front] <= i - k) {
            front++;
        }
        // Add new element if it's faulty
        if (arr[i] < 0) {
            queue[rear++] = i;
        }
        // Store result for current batch
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
    }
    // Print the result
    for (int i = 0; i < n - k + 1; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaultyReadings(arr, n, k);
    }
    return 0;
}",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052216
1390052217,unknown,unknown,unknown,"def min_effort(arr, k):
    n = len(arr)
    # If we can skip all firewalls, minimum effort is 0
    if k >= n:
        return 0
    # Try all configurations of which firewalls to skip
    min_effort_value = float('inf')
    # Generate all possible configurations of k skips from n firewalls
    # This would be combinatorial explosion for large n and k
    # We need a more efficient approach
    # Dynamic programming approach
    # dp[i][j] = minimum effort to handle first i firewalls with j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    # Base case: 0 effort for 0 firewalls
    dp[0][0] = 0
    for i in range(1, n + 1):
        curr_firewall = arr[i - 1]
        for j in range(k + 1):
            # Option 1: Don't skip the current firewall
            if j <= i - 1:
                dp[i][j] = dp[i - 1][j] + curr_firewall + j
            # Option 2: Skip the current firewall (if we have skips left)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
    # Find minimum across all possible numbers of skips
    return min(dp[n])
def solve():
    t = int(input())
    results = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        results.append(min_effort(arr, k))
    for result in results:
        print(result)
if __name__ == ""__main__"":
    solve()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052217
1390052224,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        res = []
        dq = deque()
        # Process the first k elements
        for i in range(k):
            if arr[i] < 0:
                dq.append(i)
        # Store the first result
        res.append(arr[dq[0]] if dq else 0)
        # Process the remaining elements
        for i in range(k, n):
            # Remove elements that are out of the current window
            while dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add new element if it is faulty
            if arr[i] < 0:
                dq.append(i)
            # Store result for current window
            res.append(arr[dq[0]] if dq else 0)
        results.append(res)
    return results
# Read input
def main():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        test_cases.append((n, k, arr))
    # Get results
    output = earliest_faulty_readings(test_cases)
    # Print results
    for res in output:
        print("" "".join(map(str, res)))
if __name__ == ""__main__"":
    main()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052224
1390052209,unknown,unknown,unknown,"import java.util.*;
public class FaultySensor {
    public static List<Integer> earliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < arr.length; i++) {
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            if (arr[i] < 0) {
                deque.offer(i);
            }
            if (i >= k - 1) {
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); 
        while (t-- > 0) {
            int n = scanner.nextInt(); 
            int k = scanner.nextInt(); 
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> faults = earliestFaults(arr, k);
            for (int val : faults) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052209
1390052197,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052197
1390052198,unknown,unknown,unknown,"#include <stdio.h>
#include <limits.h>
int findMinEffort(int arr[], int n, int k) {
    int total_effort = 0;
    for (int i = 0; i < n; i++) {
        total_effort += arr[i];
    }
    if (k == n) {
        return 0;
    }
    int min_effort = total_effort;
    for (int i = 0; i < n; i++) {
        int effort = total_effort - arr[i] + (i + 1);
        if (effort < min_effort) {
            min_effort = effort;
        }
    }
    return min_effort;
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        printf(""%d\n"", findMinEffort(arr, n, k));
    }
    return 0;
}",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052198
1390052205,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052205
1390052186,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of this window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store the first negative number in the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases():
    t = int(input().strip())  # Number of test cases
    for _ in range(t):
        n, k = map(int, input().strip().split())  # Read n (size) and k (batch size)
        arr = list(map(int, input().strip().split()))  # Read array elements
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))  # Output result
process_test_cases()",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052186
1390052193,unknown,unknown,unknown,"def min_effort(n, k, firewalls):
    total_effort = sum(firewalls)
    if k >= n:
        return 0
    min_effort = total_effort
    for i in range(n):
        skipped_effort = total_effort - firewalls[i] + k
        min_effort = min(min_effort, skipped_effort)
    return min_effort
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(n, k, firewalls))",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052193
1390052195,unknown,unknown,unknown,"from collections import deque
def identify_faulty_readings(test_cases):
    results = []
    for case in test_cases:
        n, k, arr = case['n'], case['k'], case['arr']
        faulty_readings = []
        queue = deque()
        # Process the initial window of size k
        for i in range(k):
            if arr[i] < 0:
                queue.append(i)
        # Add the first result for the initial window
        faulty_readings.append(arr[queue[0]] if queue else 0)
        # Slide the window over the rest of the array
        for i in range(k, n):
            # Remove elements that are outside the current window
            while queue and queue[0] < i - k + 1:
                queue.popleft()
            # Add the current element if it is negative
            if arr[i] < 0:
                queue.append(i)
            # Add the result for the current window
            faulty_readings.append(arr[queue[0]] if queue else 0)
        results.append(faulty_readings)
    return results
# Function to read input data
def read_input():
    t = int(input())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        test_cases.append({'n': n, 'k': k, 'arr': arr})
    return test_cases
# Main function to produce output
def main():
    test_cases = read_input()
    results = identify_faulty_readings(test_cases)
    for res in results:
        print("" "".join(map(str, res)))
if __name__ == ""__main__"":
    main()",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052195
1390052174,unknown,unknown,unknown,"def min_effort_to_breach(n, k, firewalls):
    total_effort = sum(firewalls)
    if k >= n:
        return 0  # If we can skip all firewalls, effort is 0
    min_effort = total_effort
    for i in range(n):
        temp_effort = total_effort
        skipped = 0
        for j in range(i, n):
            if skipped < k:
                temp_effort -= firewalls[j]  # Skip this firewall
                skipped += 1
            else:
                temp_effort += skipped  # Increase due to previous skips
        min_effort = min(min_effort, temp_effort)
    return min_effort
def process_test_cases():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        firewalls = list(map(int, input().split()))
        print(min_effort_to_breach(n, k, firewalls))
if __name__ == ""__main__"":
    process_test_cases()
    ",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052174
1390052176,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(arr, k):
    result = []
    dq = deque()
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, len(arr)):
        # Remove elements that are out of this window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))
    # Get earliest faulty readings for batches
    output = earliest_faulty_reading(arr, k)
    # Print result
    print("" "".join(map(str, output)))",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052176
1390052180,unknown,unknown,unknown,"import java.util.*;
public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt(); // Number of test cases
        while (t-- > 0) {
            int n = sc.nextInt(); // Size of array
            int k = sc.nextInt(); // Batch size
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            List<Integer> result = findEarliestFaults(arr, k);
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        sc.close();
    }
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> deque = new LinkedList<>(); // Stores indices of negative values
        // Process first window
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                deque.addLast(i);
            }
        }
        // Traverse the array in sliding window manner
        for (int i = k; i <= arr.length; i++) {
            // If there is any negative number in the current window
            if (!deque.isEmpty()) {
                result.add(arr[deque.peekFirst()]); // Earliest faulty reading
            } else {
                result.add(0); // No faults in this window
            }
            // Remove elements that are out of this window
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            // Add new element to deque (next window's last element)
            if (i < arr.length && arr[i] < 0) {
                deque.addLast(i);
            }
        }
        return result;
    }
}",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052180
1390052167,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052167
1390052153,unknown,unknown,unknown,"from collections import deque
def solve():
    x = int(input())
    for _ in range(x):
        y, z = map(int, input().split())
        w = list(map(int, input().split()))
        d = deque()
        r = []
        for i in range(y):
            while d and d[0] < i - z + 1:
                d.popleft()
            if w[i] < 0:
                d.append(i)
            if i >= z - 1:
                r.append(w[d[0]] if d else 0)
        print(*r)
solve()",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052153
1390052160,unknown,unknown,unknown,"from collections import deque
def earliest_faults(arr, k):
    result = []
    q = deque()
    for i in range(len(arr)):
        # Add current element if it is a faulty reading
        if arr[i] < 0:
            q.append(i)
        # Remove elements that are out of the current window
        while q and q[0] < i - k + 1:
            q.popleft()
        # Only start recording results after the first full window
        if i >= k - 1:
            if q:
                result.append(arr[q[0]])
            else:
                result.append(0)
    return result
# Main driver code
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    res = earliest_faults(arr, k)
    print(*res)",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052160
1390052166,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    # Base case: if we can skip all firewalls, effort is 0
    if k >= n:
        return 0
    # Use dynamic programming to solve the problem
    # dp[i][j] = minimum effort to breach until firewall i having used j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: no firewalls, no skips, 0 effort
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Calculate the increased strength due to skips
            strength_increase = min(j, i - 1)
            # Option 1: Don't skip the current firewall (if j skips used so far)
            if j <= i - 1:
                dp[i][j] = dp[i-1][j] + (firewalls[i-1] + strength_increase)
            # Option 2: Skip the current firewall (if j > 0)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(firewalls, k))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052166
1390052149,unknown,unknown,unknown,"import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
public class Solution {
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = scanner.nextInt();
            }
            List<Integer> result = new ArrayList<>();
            Deque<Integer> deque = new LinkedList<>();
            for (int i = 0; i < n; i++) {
                if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                    deque.poll();
                }
                if (arr[i] < 0) {
                    deque.offer(i);
                }
                if (i >= k - 1) {
                    result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
                }
            }
            for (int num : result) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
        scanner.close();
    }
}",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052149
1390052152,unknown,unknown,unknown,"from collections import deque
def earliest_fault_in_batches(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(len(arr) - k + 1):
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        while dq and dq[0] < i + 1:
            dq.popleft()
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_fault_in_batches(arr, k))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052152
1390052150,unknown,unknown,unknown,"#include <stdio.h>
void findEarliestFaults(int arr[], int n, int k) {
    for (int i = 0; i <= n - k; i++) {
        int found = 0;
        for (int j = i; j < i + k; j++) {
            if (arr[j] < 0) {
                printf(""%d "", arr[j]);
                found = 1;
                break;
            }
        }
        if (!found) {
            printf(""0 "");
        }
    }
    printf(""\n"");
}
int main() {
    int t;
    scanf(""%d"", &t);
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k);
        int arr[n];
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
        findEarliestFaults(arr, n, k);
    }
    return 0;
}",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052150
1390052137,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(array, k):
    n = len(array)
    result = []
    dq = deque()
    for i in range(k):
        if array[i] < 0:
            dq.append(i)
    for i in range(n - k + 1):
        result.append(array[dq[0]] if dq else 0)
        if dq and dq[0] == i:
            dq.popleft()
        if i + k < n and array[i + k] < 0:
            dq.append(i + k)
    return result
t = int(input().strip())
for _ in range(t):
    n, k = map(int, input().strip().split())
    array = list(map(int, input().strip().split()))
    print("" "".join(map(str, earliest_faulty_readings(array, k))))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052137
1390052147,unknown,unknown,unknown,"def min_effort(firewalls, k):
    n = len(firewalls)
    # Base case: if we can skip all firewalls, effort is 0
    if k >= n:
        return 0
    # Use dynamic programming to solve the problem
    # dp[i][j] = minimum effort to breach until firewall i having used j skips
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0  # Base case: no firewalls, no skips, 0 effort
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Calculate the increased strength due to skips
            strength_increase = min(j, i - 1)
            # Option 1: Don't skip the current firewall (if j skips used so far)
            if j <= i - 1:
                dp[i][j] = dp[i-1][j] + (firewalls[i-1] + strength_increase)
            # Option 2: Skip the current firewall (if j > 0)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
    return min(dp[n])
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    firewalls = list(map(int, input().split()))
    print(min_effort(firewalls, k))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052147
1390052148,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(test_cases):
    results = []
    for n, k, arr in test_cases:
        res = []
        dq = deque()
        for i in range(n):
            # Remove elements that are out of the current window
            if dq and dq[0] < i - k + 1:
                dq.popleft()
            # Add the new element if it's faulty (negative)
            if arr[i] < 0:
                dq.append(i)
            # Start recording results once we reach the batch size k
            if i >= k - 1:
                res.append(arr[dq[0]] if dq else 0)
        results.append("" "".join(map(str, res)))
    return ""\n"".join(results)
# Read input
t = int(input())
test_cases = []
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
# Get output and print
print(earliest_faulty_readings(test_cases))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052148
1390052130,unknown,unknown,unknown,"def earliest_faulty_reading(test_cases):
    results = []
    for n, k, arr in test_cases:
        batch_results = []
        for i in range(n - k + 1):
            batch = arr[i:i + k]
            faulty = next((x for x in batch if x < 0), 0)
            batch_results.append(faulty)
        results.append(batch_results)
    return results
if __name__ == ""__main__"":
    t = int(input())
    test_cases = []
    for _ in range(t):
        n, k = map(int, input().strip().split())
        arr = list(map(int, input().strip().split()))
        test_cases.append((n, k, arr))
    results = earliest_faulty_reading(test_cases)
    for res in results:
        print(*res)",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052130
1390052102,unknown,unknown,unknown,"def find_earliest_faults(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        batch = arr[i:i + k]
        earliest_fault = 0
        for j, reading in enumerate(batch):
            if reading < 0:
                earliest_fault = reading
                break
        result.append(earliest_fault)
    return result
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        result = find_earliest_faults(arr, k)
        print(*result)
solve()",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052102
1390052105,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052105
1390052112,unknown,unknown,unknown,"def earliest_fault(arr, k):
    result = []
    for i in range(len(arr) - k + 1):
        # Check each batch of size k
        batch = arr[i:i+k]
        fault_found = False
        # Find the earliest fault in the current batch
        for num in batch:
            if num < 0:
                result.append(num)
                fault_found = True
                break
        # If no fault is found in the batch, append 0
        if not fault_found:
            result.append(0)
    return result
# Process the input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Array size and batch size
    arr = list(map(int, input().split()))  # Array elements
    result = earliest_fault(arr, k)
    print(*result)  # Print the result",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052112
1390052084,unknown,unknown,unknown,"from collections import deque
def earliest_fault_in_batches(arr, k):
    result = []
    dq = deque()
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    for i in range(len(arr) - k + 1):
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        while dq and dq[0] < i + 1:
            dq.popleft()
        if i + k < len(arr) and arr[i + k] < 0:
            dq.append(i + k)
    return result
# Read input
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    print(*earliest_fault_in_batches(arr, k))",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052084
1390052086,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_reading(n, k, arr):
    result = []
    window = deque()
    for i in range(n):
        if window and window[0] <= i - k:
            window.popleft()
        if arr[i] < 0:
            window.append(i)
        if i >= k - 1:
            if window:
                result.append(arr[window[0]])
            else:
                result.append(0)
    return result
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_faulty_reading(n, k, arr)
    print("" "".join(map(str, result)))",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052086
1390052095,unknown,unknown,unknown,"from collections import deque
def find_earliest_faults(test_cases):
    results = []
    for n, k, arr in test_cases:
        fault_indices = deque()
        batch_results = []
        for i in range(k):
            if arr[i] < 0:
                fault_indices.append(i)
        batch_results.append(arr[fault_indices[0]] if fault_indices else 0)
        for i in range(k, n):
            if fault_indices and fault_indices[0] <= i - k:
                fault_indices.popleft()
            if arr[i] < 0:
                fault_indices.append(i)
            batch_results.append(arr[fault_indices[0]] if fault_indices else 0)
        results.append("" "".join(map(str, batch_results)))
    return ""\n"".join(results)
test_count = int(input())
test_cases = []
for _ in range(test_count):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    test_cases.append((n, k, arr))
print(find_earliest_faults(test_cases))",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052095
1390052064,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    result = []
    dq = deque()
    # Process first k elements
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the first result
    result.append(arr[dq[0]] if dq else 0)
    # Process rest of the elements
    for i in range(k, len(arr)):
        # Remove elements that are out of the window
        while dq and dq[0] <= i - k:
            dq.popleft()
        # Add new element if it's negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result
        result.append(arr[dq[0]] if dq else 0)
    return result
def process_test_cases():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        arr = list(map(int, input().split()))
        print(*earliest_faulty_readings(arr, k))
if __name__ == ""__main__"":
    process_test_cases()",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052064
1390052073,unknown,unknown,unknown,"#include <stdio.h>
#include <stdlib.h>
void find_earliest_faulty(int arr[], int n, int k) {
    for (int i = 0; i <= n - k; i++) {
        int found = 0;
        for (int j = i; j < i + k; j++) {
            if (arr[j] < 0) {
                printf(""%d "", arr[j]);
                found = 1;
                break;
            }
        }
        if (!found) {
            printf(""0 "");
        }
    }
    printf(""\n"");
}
int main() {
    int t;
    scanf(""%d"", &t); // Read number of test cases
    while (t--) {
        int n, k;
        scanf(""%d %d"", &n, &k); // Read array size and batch size
        int *arr = (int *)malloc(n * sizeof(int)); // Allocate memory for array
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]); // Read array elements
        }
        find_earliest_faulty(arr, n, k); // Process the array
        free(arr); // Free allocated memory
    }
    return 0;
}",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052073
1390052079,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result;
    deque<int> dq;  // Stores indices of negative numbers
    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process the sliding window
    for (int i = k; i <= n; i++) {
        // Append first negative number in the window
        if (!dq.empty()) 
            result.push_back(arr[dq.front()]);  // First negative in the deque
        else 
            result.push_back(0);  // No negative number
        // Remove elements that are out of the current window
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        // Add the next element if negative
        if (i < n && arr[i] < 0) {
            dq.push_back(i);
        }
    }
    return result;
}
int main() {
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int n, k;
        cin >> n >> k;  // Size of array and batch size
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        vector<int> result = earliest_faulty_readings(arr, k);
        for (int num : result) {
            cout << num << "" "";
        }
        cout << endl;
    }
    return 0;
}",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052079
1390052061,unknown,unknown,unknown,"def earliest_fault(arr, k):
    results = []
    # Loop through each possible batch
    for i in range(len(arr) - k + 1):
        fault_found = False
        # Find earliest fault in current batch
        for j in range(i, i + k):
            if arr[j] < 0:
                results.append(arr[j])
                fault_found = True
                break
        # If no fault found in batch, append 0
        if not fault_found:
            results.append(0)
    return results
# Process test cases
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    result = earliest_fault(arr, k)
    print(*result)",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052061
1390046296,unknown,unknown,unknown,"def solve(s):
    pos = [i for i, ch in enumerate(s) if ch == '1']
    n = len(pos)
    if n == 0 or pos[-1] - pos[0] == n - 1:
        print(0)
        return
    left, right = 0, n
    while right - left > 1:
        mid = (left + right) // 2
        x = n - mid
        possible = False
        for i in range(mid + 1):
            l = pos[i]
            r = pos[i + x - 1]
            if (r - l + 1) - x <= mid:
                possible = True
                break
        if possible:
            right = mid
        else:
            left = mid
    print(right)
if __name__ == ""__main__"":
    t = int(input().strip())
    for _ in range(t):
        s = input().strip()
        solve(s)",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390046296
1390052056,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, k):
    n = len(arr)
    result = []
    dq = deque()  # To store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Store the result for the first window
    result.append(arr[dq[0]] if dq else 0)
    # Process the remaining windows
    for i in range(k, n):
        # Remove elements that are out of the current window
        if dq and dq[0] < i - k + 1:
            dq.popleft()
        # Add the current element if it is negative
        if arr[i] < 0:
            dq.append(i)
        # Store the result for the current window
        result.append(arr[dq[0]] if dq else 0)
    return result
# Reading input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    # Get the results and print as space-separated values
    print(*earliest_faulty_readings(arr, k))",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052056
1390052059,unknown,unknown,unknown,"from collections import deque
def earliest_faulty_readings(arr, n, k):
    result = []
    dq = deque()  # Store indices of negative numbers
    # Process the first window
    for i in range(k):
        if arr[i] < 0:
            dq.append(i)
    # Process remaining windows
    for i in range(n - k + 1):
        # If deque is not empty, the front of the queue is the earliest negative
        if dq:
            result.append(arr[dq[0]])
        else:
            result.append(0)
        # Remove elements that are out of this window
        if dq and dq[0] == i:
            dq.popleft()
        # Add the next element of the window
        if i + k < n and arr[i + k] < 0:
            dq.append(i + k)
    print(*result)  # Print space-separated output
# Read input
t = int(input())  # Number of test cases
for _ in range(t):
    n, k = map(int, input().split())  # Size of array and batch size
    arr = list(map(int, input().split()))  # Array elements
    earliest_faulty_readings(arr, n, k)",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052059
1390046257,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
void solve() {
  string s;
  cin >> s;
  vector<int> pos;
  int n = s.length();
  for (int i = 0; i < n; ++i) {
    if (s[i] == '1') {
      pos.push_back(i);
    }
  }
  int lf = 0, rg = pos.size();
  while (rg - lf > 1) {
    int mid = (lf + rg) / 2;
    int k = pos.size();
    int x = k - mid;
    bool possible = false;
    for (int i = 0; i <= mid; ++i) {
      int l = pos[i];
      int r = pos[i + x - 1];
      if (r - l + 1 - x <= mid) {
        possible = true;
        break;
      }
    }
    if (possible) {
      rg = mid;
    } else {
      lf = mid;
    }
  }
  if (pos.empty() || pos.back() - pos[0] == pos.size() - 1) {
    cout << 0 << endl;
  } else {
    cout << rg << endl;
  }
}
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  ll t;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390046257
1390046239,unknown,unknown,unknown,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
void solve() {
  ll n, k;
  cin >> n >> k;
  vector<ll> strengths(n);
  ll tot = 0;
  for (ll i = 0; i < n; i++) {
    cin >> strengths[i];
    tot += strengths[i];
  }
  vector<ll> skip(n);
  for (ll i = 0; i < n; i++) {
    skip[i] = strengths[i] - (n - i - 1);
  }
  sort(skip.rbegin(), skip.rend());
  for (ll i = 0; i < k; i++) {
    tot -= skip[i];
  }
  tot -= k * (k - 1) / 2;
  cout << tot << '\n';
}
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  ll t;
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390046239
